 
!>>>>> build/dependencies/M_CLI2/src/M_CLI2.F90
!VERSION 1.0 20200115
!VERSION 2.0 20200802
!VERSION 3.0 20201021  LONG:SHORT syntax
!VERSION 3.1 20201115  LONG:SHORT:: syntax
!VERSION 3.2 20230205  set_mode()
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    M_CLI2(3fm) - [ARGUMENTS::M_CLI2::INTRO] command line argument
!!    parsing using a prototype command
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   Available procedures and variables:
!!
!!      ! basic procedures
!!      use M_CLI2, only : set_args, get_args, specified, set_mode
!!      ! convenience functions
!!      use M_CLI2, only : dget, iget, lget, rget, sget, cget
!!      use M_CLI2, only : dgets, igets, lgets, rgets, sgets, cgets
!!      ! variables
!!      use M_CLI2, only : unnamed, remaining, args
!!      ! working with non-allocatable strings and arrays
!!      use M_CLI2, only : get_args_fixed_length, get_args_fixed_size
!!      ! special function for creating subcommands
!!      use M_CLI2, only : get_subcommand(3f)
!!
!!##DESCRIPTION
!!    The M_CLI2 module cracks a Unix-style command line.
!!
!!    Typically one call to SET_ARGS(3f) is made to define the command
!!    arguments, set default values and parse the command line. Then a call
!!    is made to the convenience procedures or GET_ARGS(3f) proper for each
!!    command keyword to obtain the argument values.
!!
!!    Detailed descriptions of each procedure and example programs are
!!    included.
!!
!!##EXAMPLE
!!
!!
!! Sample minimal program which may be called in various ways:
!!
!!     mimimal -x 100.3 -y 3.0e4
!!     mimimal --xvalue=300 --debug
!!     mimimal --yvalue 400
!!     mimimal -x 10 file1 file2 file3
!!
!! Program example:
!!
!!     program minimal
!!     use M_CLI2,  only : set_args, lget, rget, sgets
!!     implicit none
!!     real    :: x, y
!!     integer :: i
!!     character(len=:),allocatable :: filenames(:)
!!        ! define and crack command line
!!        call set_args(' --yvalue:y 0.0 --xvalue:x 0.0 --debug F')
!!        ! get values
!!        x=rget('xvalue')
!!        y=rget('yvalue')
!!        if(lget('debug'))then
!!           write(*,*)'X=',x
!!           write(*,*)'Y=',y
!!           write(*,*)'ATAN2(Y,X)=',atan2(x=x,y=y)
!!        else
!!           write(*,*)atan2(x=x,y=y)
!!        endif
!!        filenames=sgets() ! sget with no name gets "unnamed" values
!!        if(size(filenames) > 0)then
!!           write(*,'(g0)')'filenames:'
!!           write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!        endif
!!     end program minimal
!!
!! Sample program using get_args() and variants
!!
!!     program demo_M_CLI2
!!     use M_CLI2,  only : set_args, get_args
!!     use M_CLI2,  only : filenames=>unnamed
!!     use M_CLI2,  only : get_args_fixed_length, get_args_fixed_size
!!     implicit none
!!     integer                      :: i
!!     integer,parameter            :: dp=kind(0.0d0)
!!      !
!!      ! Define ARGS
!!     real                         :: x, y, z
!!     logical                      :: l, lbig
!!     character(len=40)            :: label    ! FIXED LENGTH
!!     real(kind=dp),allocatable    :: point(:)
!!     logical,allocatable          :: logicals(:)
!!     character(len=:),allocatable :: title    ! VARIABLE LENGTH
!!     real                         :: p(3)     ! FIXED SIZE
!!     logical                      :: logi(3)  ! FIXED SIZE
!!      !
!!      ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!      !   o set a value for all keywords.
!!      !   o double-quote strings, strings must be at least one space
!!      !     because adjacent double-quotes designate a double-quote
!!      !     in the value.
!!      !   o set all logical values to F
!!      !   o numeric values support an "e" or "E" exponent
!!      !   o for lists delimit with a comma, colon, or space
!!     call set_args('                         &
!!             & -x 1 -y 2 -z 3                &
!!             & -p -1 -2 -3                   &
!!             & --point 11.11, 22.22, 33.33e0 &
!!             & --title "my title" -l F -L F  &
!!             & --logicals  F F F F F         &
!!             & --logi F T F                  &
!!             & --label " " &
!!             ! note space between quotes is required
!!             & ')
!!      ! Assign values to elements using G_ARGS(3f).
!!      ! non-allocatable scalars can be done up to twenty per call
!!     call get_args('x',x, 'y',y, 'z',z, 'l',l, 'L',lbig)
!!      ! As a convenience multiple pairs of keywords and variables may be
!!      ! specified if and only if all the values are scalars and the CHARACTER
!!      ! variables are fixed-length or pre-allocated.
!!      !
!!      ! After SET_ARGS(3f) has parsed the command line
!!      ! GET_ARGS(3f) retrieves the value of keywords accept for
!!      ! two special cases. For fixed-length CHARACTER variables
!!      ! see GET_ARGS_FIXED_LENGTH(3f). For fixed-size arrays see
!!      ! GET_ARGS_FIXED_SIZE(3f).
!!      !
!!      ! allocatables should be done one at a time
!!     call get_args('title',title) ! allocatable string
!!     call get_args('point',point) ! allocatable arrays
!!     call get_args('logicals',logicals)
!!      !
!!      ! less commonly ...
!!
!!      ! for fixed-length strings
!!     call get_args_fixed_length('label',label)
!!
!!      ! for non-allocatable arrays
!!     call get_args_fixed_size('p',p)
!!     call get_args_fixed_size('logi',logi)
!!      !
!!      ! all done parsing, use values
!!     write(*,*)'x=',x, 'y=',y, 'z=',z, x+y+z
!!     write(*,*)'p=',p
!!     write(*,*)'point=',point
!!     write(*,*)'title=',title
!!     write(*,*)'label=',label
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     write(*,*)'logicals=',logicals
!!     write(*,*)'logi=',logi
!!      !
!!      ! unnamed strings
!!      !
!!     if(size(filenames) > 0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!      !
!!     end program demo_M_CLI2
!!
!!##AUTHOR
!!     John S. Urban, 2019
!!##LICENSE
!!     Public Domain
!!##SEE ALSO
!!     + get_args(3f)
!!     + get_args_fixed_size(3f)
!!     + get_args_fixed_length(3f)
!!     + get_subcommand(3f)
!!     + set_mode(3f)
!!     + specified(3f)
!!
!! Note that the convenience routines are described under get_args(3f):
!! dget(3f), iget(3f), lget(3f), rget(3f), sget(3f), cget(3f) dgets(3f),
!! igets(3f), lgets(3f), rgets(3f), sgets(3f), cgets(3f)
!===================================================================================================================================
module M_CLI2
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT, warn=>OUTPUT_UNIT
implicit none
private

integer,parameter,private :: dp=kind(0.0d0)
integer,parameter,private :: sp=kind(0.0)

character(len=*),parameter          :: gen='(*(g0))'
character(len=:),allocatable,public :: unnamed(:)
character(len=:),allocatable,public :: args(:)
character(len=:),allocatable,public :: remaining
public                              :: set_mode
public                              :: set_args
public                              :: get_subcommand
public                              :: get_args
public                              :: get_args_fixed_size
public                              :: get_args_fixed_length
public                              :: specified
public                              :: print_dictionary

public                              :: dget, iget, lget, rget, sget, cget
public                              :: dgets, igets, lgets, rgets, sgets, cgets

type option
   character(:),allocatable :: shortname
   character(:),allocatable :: longname
   character(:),allocatable :: value
   integer                  :: length
   logical                  :: present_in
   logical                  :: mandatory
end type option

character(len=:),allocatable,save :: keywords(:)
character(len=:),allocatable,save :: shorts(:)
character(len=:),allocatable,save :: values(:)
integer,allocatable,save          :: counts(:)
logical,allocatable,save          :: present_in(:)
logical,allocatable,save          :: mandatory(:)

logical,save                      :: G_DEBUG=.false.
logical,save                      :: G_UNDERDASH=.false.
logical,save                      :: G_NODASHUNDER=.false.
logical,save                      :: G_IGNORELONGCASE=.false.  ! ignore case of long keywords
logical,save                      :: G_IGNOREALLCASE=.false.   ! ignore case of long and short keywords
logical,save                      :: G_STRICT=.false.          ! strict short and long rules or allow -longname and --shortname
logical,save                      :: G_APPEND=.true.           ! whether to append or replace when duplicate keywords found

logical,save                      :: G_keyword_single_letter=.true.
character(len=:),allocatable,save :: G_passed_in
logical,save                      :: G_remaining_on, G_remaining_option_allowed
character(len=:),allocatable,save :: G_remaining
character(len=:),allocatable,save :: G_subcommand              ! possible candidate for a subcommand
character(len=:),allocatable,save :: G_STOP_MESSAGE
integer,save                      :: G_STOP
logical,save                      :: G_QUIET
character(len=:),allocatable,save :: G_PREFIX

! try out response files
! CLI_RESPONSE_FILE is left public for backward compatibility, but should be set via "set_mode('response_file')
logical,save,public               :: CLI_RESPONSE_FILE=.false. ! allow @name abbreviations
logical,save                      :: G_OPTIONS_ONLY            ! process response file only looking for options for get_subcommand()
logical,save                      :: G_RESPONSE                ! allow @name abbreviations
character(len=:),allocatable,save :: G_RESPONSE_IGNORED

! return allocatable arrays
interface  get_args;  module  procedure  get_anyarray_d;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_i;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_r;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_x;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_c;  end interface  ! any size array and any length
interface  get_args;  module  procedure  get_anyarray_l;  end interface  ! any size array

! return scalars
interface  get_args;  module  procedure  get_scalar_d;               end interface
interface  get_args;  module  procedure  get_scalar_i;               end interface
interface  get_args;  module  procedure  get_scalar_real;            end interface
interface  get_args;  module  procedure  get_scalar_complex;         end interface
interface  get_args;  module  procedure  get_scalar_logical;         end interface
interface  get_args;  module  procedure  get_scalar_anylength_c;     end interface  ! any length

! multiple scalars
interface  get_args;  module  procedure  many_args;               end  interface

! return non-allocatable arrays
! said in conflict with get_args_*. Using class to get around that.
! that did not work either. Adding size parameter as optional parameter works; but using a different name
interface  get_args_fixed_size;  module procedure get_fixedarray_class;            end interface ! any length, fixed size array
!interface   get_args;           module procedure get_fixedarray_d;                end interface
!interface   get_args;           module procedure get_fixedarray_i;                end interface
!interface   get_args;           module procedure get_fixedarray_r;                end interface
!interface   get_args;           module procedure get_fixedarray_l;                end interface
!interface   get_args;           module procedure get_fixedarray_fixed_length_c;   end interface

interface   get_args_fixed_length;  module  procedure  get_args_fixed_length_a_array; end interface  ! fixed length any size array
interface   get_args_fixed_length;  module  procedure  get_args_fixed_length_scalar_c;  end interface       ! fixed length

! Generic subroutine inserts element into allocatable array at specified position

! find PLACE in sorted character array where value can be found or should be placed
interface  locate_;  module procedure locate_c                            ; end interface

! insert entry into a sorted allocatable array at specified position
interface  insert_;  module procedure insert_c,      insert_i,  insert_l  ; end interface

! replace entry by index from a sorted allocatable array if it is present
interface  replace_; module procedure replace_c,     replace_i, replace_l ; end interface

! delete entry by index from a sorted allocatable array if it is present
interface  remove_;  module procedure remove_c,      remove_i,  remove_l  ; end interface

! convenience functions
interface cgets;module procedure cgs, cg;end interface
interface dgets;module procedure dgs, dg;end interface
interface igets;module procedure igs, ig;end interface
interface lgets;module procedure lgs, lg;end interface
interface rgets;module procedure rgs, rg;end interface
interface sgets;module procedure sgs, sg;end interface

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    check_commandline(3f) - [ARGUMENTS:M_CLI2]check command and process
!!    pre-defined options
!!
!!##SYNOPSIS
!!
!!      subroutine check_commandline(help_text,version_text,ierr,errmsg)
!!
!!       character(len=*),intent(in),optional :: help_text(:)
!!       character(len=*),intent(in),optional :: version_text(:)
!!
!!##DESCRIPTION
!!     Checks the commandline  and processes the implicit --help, --version,
!!     --verbose, and --usage parameters.
!!
!!     If the optional text values are supplied they will be displayed by
!!     --help and --version command-line options, respectively.
!!
!!##OPTIONS
!!
!!     HELP_TEXT     if present, will be displayed if program is called with
!!                   --help switch, and then the program will terminate. If
!!                   not supplied, the command line initialized string will be
!!                   shown when --help is used on the commandline.
!!
!!     VERSION_TEXT  if present, will be displayed if program is called with
!!                   --version switch, and then the program will terminate.
!!
!!        If the first four characters of each line are "@(#)" this prefix
!!        will not be displayed and the last non-blank letter will be
!!        removed from each line. This if for support of the SCCS what(1)
!!        command. If you do not have the what(1) command on GNU/Linux and
!!        Unix platforms you can probably see how it can be used to place
!!        metadata in a binary by entering:
!!
!!         strings demo_commandline|grep '@(#)'|tr '>' '\n'|sed -e 's/  */ /g'
!!
!!##EXAMPLE
!!
!!
!! Typical usage:
!!
!!      program check_commandline
!!      use M_CLI2,  only : unnamed, set_args, get_args
!!      implicit none
!!      integer                      :: i
!!      character(len=:),allocatable :: version_text(:), help_text(:)
!!      real               :: x, y, z
!!      character(len=*),parameter :: cmd='-x 1 -y 2 -z 3'
!!         version_text=[character(len=80) :: "version 1.0","author: me"]
!!         help_text=[character(len=80) :: &
!!                 & "wish I put instructions","here","I suppose?"]
!!         call set_args(cmd,help_text,version_text)
!!         call get_args('x',x,'y',y,'z',z)
!!         ! All done cracking the command line. Use the values in your program.
!!         write (*,*)x,y,z
!!         ! the optional unnamed values on the command line are
!!         ! accumulated in the character array "UNNAMED"
!!         if(size(unnamed) > 0)then
!!            write (*,'(a)')'files:'
!!            write (*,'(i6.6,3a)') (i,'[',unnamed(i),']',i=1,size(unnamed))
!!         endif
!!      end program check_commandline
!===================================================================================================================================
subroutine check_commandline(help_text,version_text)
character(len=*),intent(in),optional :: help_text(:)
character(len=*),intent(in),optional :: version_text(:)
character(len=:),allocatable         :: line
integer                              :: i
integer                              :: istart
integer                              :: iback
   if(get('usage') == 'T')then
      call print_dictionary_usage()
      call mystop(32)
      return
   endif
   if(present(help_text))then
      if(get('help') == 'T')then
         do i=1,size(help_text)
            call journal(help_text(i))
         enddo
         call mystop(1,'displayed help text')
         return
      endif
   elseif(get('help') == 'T')then
      call default_help()
      call mystop(2,'displayed default help text')
      return
   endif
   if(present(version_text))then
      if(get('version') == 'T')then
         istart=1
         iback=0
         if(size(version_text) > 0)then
            if(index(version_text(1),'@'//'(#)') == 1)then ! allow for what(1) syntax
               istart=5
               iback=1
            endif
         endif
         do i=1,size(version_text)
            !xINTEL BUG*!call journal(version_text(i)(istart:len_trim(version_text(i))-iback))
            line=version_text(i)(istart:len_trim(version_text(i))-iback)
            call journal(line)
         enddo
         call mystop(3,'displayed version text')
         return
      endif
   elseif(get('version') == 'T')then

      if(G_QUIET)then
         G_STOP_MESSAGE = 'no version text'
      else
         call journal('*check_commandline* no version text')
      endif
      call mystop(4,'displayed default version text')
      return
   endif
contains
subroutine default_help()
character(len=:),allocatable :: cmd_name
integer :: ilength
   call get_command_argument(number=0,length=ilength)
   if(allocated(cmd_name))deallocate(cmd_name)
   allocate(character(len=ilength) :: cmd_name)
   call get_command_argument(number=0,value=cmd_name)
   G_passed_in=G_passed_in//repeat(' ',len(G_passed_in))
   G_passed_in=replace_str(G_passed_in, ' --', NEW_LINE('A')//' --')
   if(.not.G_QUIET)then
      call journal(cmd_name,G_passed_in) ! no help text, echo command and default options
   endif
   deallocate(cmd_name)
end subroutine default_help
end subroutine check_commandline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set_args(3f) - [ARGUMENTS:M_CLI2] command line argument parsing
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     subroutine set_args(prototype,help_text,version_text,ierr,errmsg)
!!
!!      character(len=*),intent(in),optional              :: prototype
!!      character(len=*),intent(in),optional              :: help_text(:)
!!      character(len=*),intent(in),optional              :: version_text(:)
!!      integer,intent(out),optional                      :: ierr
!!      character(len=:),intent(out),allocatable,optional :: errmsg
!!##DESCRIPTION
!!
!!    SET_ARGS(3f) requires a unix-like command prototype which defines
!!    the command-line options and their default values. When the program
!!    is executed this and the command-line options are applied and the
!!    resulting values are placed in an internal table for retrieval via
!!    GET_ARGS(3f).
!!
!!    The built-in --help and --version options require optional help_text
!!    and version_text values to be provided to be particularly useful.
!!
!!##OPTIONS
!!
!!    PROTOTYPE   composed of all command arguments concatenated
!!                into a Unix-like command prototype string. For
!!                example:
!!
!!                 call set_args('-L F --ints 1,2,3 --title "my title" -R 10.3')
!!
!!                The following options are predefined for all commands:
!!                '--verbose F --usage F --help F --version F'.
!!
!!                see "DEFINING THE PROTOTYPE" in the next section for
!!                further details.
!!
!!    HELP_TEXT   if present, will be displayed when the program is called with
!!                a --help switch, and then the program will terminate. If
!!                help text is not supplied the command line initialization
!!                string will be echoed.
!!
!!    VERSION_TEXT  if present, any version text defined will be displayed
!!                  when the program is called with a --version switch,
!!                  and then the program will terminate.
!!    IERR          if present a non-zero option is returned when an
!!                  error occurs instead of the program terminating.
!!    ERRMSG        a description of the error if ierr is present.
!!
!!##DEFINING THE PROTOTYPE
!!
!!    o Keywords start with a single dash for short single-character
!!      keywords, and with two dashes for longer keywords.
!!
!!    o all keywords on the prototype MUST get a value.
!!
!!       * logicals must be set to an unquoted F.
!!
!!       * strings must be delimited with double-quotes.
!!         Since internal double-quotes are represented with two
!!         double-quotes the string must be at least one space.
!!
!!    o numeric keywords are not allowed; but this allows
!!      negative numbers to be used as values.
!!
!!    o lists of values should be comma-delimited unless a
!!      user-specified delimiter is used. The prototype
!!      must use the same array delimiters as the call to
!!      get the value.
!!
!!    o to define a zero-length allocatable array make the
!!      value a delimiter (usually a comma) or an empty set
!!      of braces ("[]").
!!
!!    LONG AND SHORT NAMES
!!
!!    Long keywords start with two dashes followed by more than one letter.
!!    Short keywords are a dash followed by a single letter.
!!
!!    o It is recommended long names (--keyword) should be all lowercase
!!      but are case-sensitive by default, unless
!!      "set_mode('ignorelongcase')" of "set_mode('ignoreallcase')" is
!!      in effect.
!!
!!    o Long names should always be more than one character.
!!
!!    o The recommended way to have short names is to suffix the long
!!      name with :LETTER in the definition.
!!
!!      If this syntax is used then logical shorts may be combined on the
!!      command line when "set_mode('strict')" is in effect.
!!
!!    SPECIAL BEHAVIORS
!!
!!    o A special behavior occurs if a keyword name ends in ::.
!!      When the program is called the next parameter is taken as
!!      a value even if it starts with -. This is not generally
!!      recommended but is useful in rare cases where non-numeric
!!      values starting with a dash are desired.
!!
!!    o If the prototype ends with "--" a special mode is turned
!!      on where anything after "--" on input goes into the variable
!!      REMAINING with values double-quoted and also into the array ARGS
!!      instead of becoming elements in the UNNAMED array. This is not
!!      needed for normal processing, but was needed for a program that
!!      needed this behavior for its subcommands.
!!
!!      That is, for a normal call all unnamed values go into UNNAMED
!!      and ARGS and REMAINING are ignored. So for
!!
!!          call set_args('-x 10 -y 20 ')
!!
!!      A program invocation such as
!!
!!          xx a b c -- A B C " dd "
!!
!!      results in
!!
!!       UNNAMED= ['a','b','c','A','B','C',' dd']
!!       REMAINING= ''
!!       ARGS= [character(len=0) :: ] ! ie, an empty character array
!!
!!      Whereas
!!
!!       call set_args('-x 10 -y 20 --')
!!
!!      generates the following output from the same program execution:
!!
!!       UNNAMED= ['a','b','c']
!!       REMAINING= '"A" "B" "C" " dd "'
!!       ARGS= ['A','B','C,' dd']
!!
!!##USAGE NOTES
!!      When invoking the program line note the (subject to change)
!!      following restrictions (which often differ between various
!!      command-line parsers):
!!
!!      o values for duplicate keywords are appended together with a space
!!        separator when a command line is executed by default.
!!
!!      o shuffling is not supported. Values immediately follow their
!!        keywords.
!!
!!      o Only short Boolean keywords can be bundled together.
!!        If allowing bundling is desired call "set_mode('strict')".
!!        This will require prefixing long names with "--" and short
!!        names with "-". Otherwise M_CLI2 relaxes that requirement
!!        and mostly does not care what prefix is used for a keyword.
!!        But this would make it unclear what was meant by "-ox" if
!!        allowed options were "-o F -x F --ox F " for example, so
!!        "strict" mode is required to remove the ambiguity.
!!
!!      o if a parameter value of just "-" is supplied it is
!!        converted to the string "stdin".
!!
!!      o values not needed for a keyword value go into the character
!!        array "UNNAMED".
!!
!!        In addition if the keyword "--" is encountered on the command
!!        line the rest of the command line goes into the character array
!!        "UNNAMED".
!!
!!##EXAMPLE
!!
!!
!! Sample program:
!!
!!     program demo_set_args
!!     use M_CLI2,  only : filenames=>unnamed, set_args, get_args
!!     use M_CLI2,  only : get_args_fixed_size
!!     implicit none
!!     integer                      :: i
!!     ! DEFINE ARGS
!!     real                         :: x, y, z
!!     real                         :: p(3)
!!     character(len=:),allocatable :: title
!!     logical                      :: l, lbig
!!     integer,allocatable          :: ints(:)
!!     !
!!     !  DEFINE COMMAND (TO SET INITIAL VALUES AND ALLOWED KEYWORDS)
!!     !  AND READ COMMAND LINE
!!     call set_args(' &
!!        ! reals
!!        & -x 1 -y 2.3 -z 3.4e2 &
!!        ! integer array
!!        & -p -1,-2,-3 &
!!        ! always double-quote strings
!!        & --title "my title" &
!!        ! string should be a single character at a minimum
!!        & --label " ", &
!!        ! set all logical values to F
!!        & -l F -L F &
!!        ! set allocatable size to zero if you like by using a delimiter
!!        & --ints , &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!     !     SCALARS
!!     call get_args('x',x)
!!     call get_args('y',y)
!!     call get_args('z',z)
!!     call get_args('l',l)
!!     call get_args('L',lbig)
!!     call get_args('ints',ints)      ! ALLOCATABLE ARRAY
!!     call get_args('title',title)    ! ALLOCATABLE STRING
!!     call get_args_fixed_size('p',p) ! NON-ALLOCATABLE ARRAY
!!     ! USE VALUES
!!     write(*,*)'x=',x
!!     write(*,*)'y=',y
!!     write(*,*)'z=',z
!!     write(*,*)'p=',p
!!     write(*,*)'title=',title
!!     write(*,*)'ints=',ints
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     ! UNNAMED VALUES
!!     if(size(filenames) > 0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     end program demo_set_args
!!
!!##RESPONSE FILES
!!
!!  If you have no interest in using external files as abbreviations
!!  you can ignore this section. Otherwise, before calling set_args(3f)
!!  add:
!!
!!     use M_CLI2, only : set_mode
!!     call set_mode('response_file')
!!
!!  M_CLI2 Response files are small files containing CLI (Command Line
!!  Interface) arguments that end with ".rsp" that can be used when command
!!  lines are so long that they would exceed line length limits or so complex
!!  that it is useful to have a platform-independent method of creating
!!  an abbreviation.
!!
!!  Shell aliases and scripts are often used for similar purposes (and
!!  allow for much more complex conditional execution, of course), but
!!  they generally cannot be used to overcome line length limits and are
!!  typically platform-specific.
!!
!!  Examples of commands that support similar response files are the Clang
!!  and Intel compilers, although there is no standard format for the files.
!!
!!  They are read if you add options of the syntax "@NAME" as the FIRST
!!  parameters on your program command line calls. They are not recursive --
!!  that is, an option in a response file cannot be given the value "@NAME2"
!!  to call another response file.
!!
!!  More than one response name may appear on a command line.
!!
!!  They are case-sensitive names.
!!
!!  Note "@" s a special character in Powershell, and requires being escaped
!!  with a grave character.
!!
!!   LOCATING RESPONSE FILES
!!
!!  A search for the response file always starts with the current directory.
!!  The search then proceeds to look in any additional directories specified
!!  with the colon-delimited environment variable CLI_RESPONSE_PATH.
!!
!!  The first resource file found that results in lines being processed
!!  will be used and processing stops after that first match is found. If
!!  no match is found an error occurs and the program is stopped.
!!
!!   RESPONSE FILE SECTIONS
!!
!!  A simple response file just has options for calling the program in it
!!  prefixed with the word "options".
!!  But they can also contain section headers to denote selections that are
!!  only executed when a specific OS is being used, print messages, and
!!  execute system commands.
!!
!!   SEARCHING FOR OSTYPE IN REGULAR FILES
!!
!!  So assuming the name @NAME was specified on the command line a file
!!  named NAME.rsp will be searched for in all the search directories
!!  and then in that file a string that starts with the string @OSTYPE
!!  (if the environment variables $OS and $OSTYPE are not blank. $OSTYPE
!!  takes precedence over $OS).
!!
!!   SEARCHING FOR UNLABELED DIRECTIVES IN REGULAR FILES
!!
!!  Then, the same files will be searched for lines above any line starting
!!  with "@". That is, if there is no special section for the current OS
!!  it just looks at the top of the file for unlabeled options.
!!
!!   SEARCHING FOR OSTYPE AND NAME IN THE COMPOUND FILE
!!
!!  In addition or instead of files with the same name as the @NAME option
!!  on the command line, you can have one file named after the executable
!!  name that contains multiple abbreviation names.
!!
!!  So if your program executable is named EXEC you create a single file
!!  called EXEC.rsp and can append all the simple files described above
!!  separating them with lines of the form @OSTYPE@NAME or just @NAME.
!!
!!  So if no specific file for the abbreviation is found a file called
!!  "EXEC.rsp" is searched for where "EXEC" is the name of the executable.
!!  This file is always a "compound" response file that uses the following format:
!!
!!  Any compound EXEC.rsp file found in the current or searched directories
!!  will be searched for the string @OSTYPE@NAME first.
!!
!!  Then if nothing is found, the less specific line @NAME is searched for.
!!
!!   THE SEARCH IS OVER
!!
!!  Sounds complicated but actually works quite intuitively. Make a file in
!!  the current directory and put options in it and it will be used. If that
!!  file ends up needing different cases for different platforms add a line
!!  like "@Linux" to the file and some more lines and that will only be
!!  executed if the environment variable OSTYPE or OS is "Linux". If no match
!!  is found for named sections the lines at the top before any "@" lines
!!  will be used as a default if no match is found.
!!
!!  If you end up using a lot of files like this you can combine them all
!!  together and put them into a file called "program_name".rsp and just
!!  put lines like @NAME or @OSTYPE@NAME at that top of each selection.
!!
!!  Now, back to the details on just what you can put in the files.
!!
!!##SPECIFICATION FOR RESPONSE FILES
!!
!!   SIMPLE RESPONSE FILES
!!
!!  The first word of a line is special and has the following meanings:
!!
!!    options|-  Command options following the rules of the SET_ARGS(3f)
!!               prototype. So
!!                o It is preferred to specify a value for all options.
!!                o double-quote strings.
!!                o give a blank string value as " ".
!!                o use F|T for lists of logicals,
!!                o lists of numbers should be comma-delimited.
!!                o --usage, --help, --version, --verbose, and unknown
!!                  options are ignored.
!!
!!    comment|#  Line is a comment line
!!    system|!   System command.
!!               System commands are executed as a simple call to
!!               system (so a cd(1) or setting a shell variable
!!               would not effect subsequent lines, for example)
!!               BEFORE the command being processed.
!!    print|>    Message to screen
!!    stop       display message and stop program.
!!
!!  NOTE: system commands are executed when encountered, but options are
!!  gathered from multiple option lines and passed together at the end of
!!  processing of the block; so all commands will be executed BEFORE the
!!  command for which options are being supplied no matter where they occur.
!!
!!  So if a program that does nothing but echos its parameters
!!
!!    program testit
!!    use M_CLI2, only : set_args, rget, sget, lget, set_mode
!!    implicit none
!!       real :: x,y                           ; namelist/args/ x,y
!!       character(len=:),allocatable :: title ; namelist/args/ title
!!       logical :: big                        ; namelist/args/ big
!!       call set_mode('response_file')
!!       call set_args('-x 10.0 -y 20.0 --title "my title" --big F')
!!       x=rget('x')
!!       y=rget('y')
!!       title=sget('title')
!!       big=lget('big')
!!       write(*,nml=args)
!!    end program testit
!!
!!  And a file in the current directory called "a.rsp" contains
!!
!!     # defaults for project A
!!     options -x 1000 -y 9999
!!     options --title " "
!!     options --big T
!!
!!  The program could be called with
!!
!!     $myprog     # normal call
!!      X=10.0 Y=20.0 TITLE="my title"
!!
!!     $myprog @a  # change defaults as specified in "a.rsp"
!!     X=1000.0 Y=9999.0 TITLE=" "
!!
!!     # change defaults but use any option as normal to override defaults
!!     $myprog @a -y 1234
!!      X=1000.0 Y=1234.0 TITLE=" "
!!
!!   COMPOUND RESPONSE FILES
!!
!!  A compound response file has the same basename as the executable with a
!!  ".rsp" suffix added. So if your program is named "myprg" the filename
!!  must be "myprg.rsp".
!!
!!    Note that here `basename` means the last leaf of the
!!    name of the program as returned by the Fortran intrinsic
!!    GET_COMMAND_ARGUMENT(0,...) trimmed of anything after a period ("."),
!!    so it is a good idea not to use hidden files.
!!
!!  Unlike simple response files compound response files can contain multiple
!!  setting names.
!!
!!  Specifically in a compound file
!!  if the environment variable $OSTYPE (first) or $OS is set the first search
!!  will be for a line of the form (no leading spaces should be used):
!!
!!    @OSTYPE@alias_name
!!
!!  If no match or if the environment variables $OSTYPE and $OS were not
!!  set or a match is not found then a line of the form
!!
!!    @alias_name
!!
!!  is searched for in simple or compound files. If found subsequent lines
!!  will be ignored that start with "@" until a line not starting with
!!  "@" is encountered. Lines will then be processed until another line
!!  starting with "@" is found or end-of-file is encountered.
!!
!!   COMPOUND RESPONSE FILE EXAMPLE
!!  An example compound file
!!
!!    #################
!!    @if
!!    > RUNNING TESTS USING RELEASE VERSION AND ifort
!!    options test --release --compiler ifort
!!    #################
!!    @gf
!!    > RUNNING TESTS USING RELEASE VERSION AND gfortran
!!    options test --release --compiler gfortran
!!    #################
!!    @nv
!!    > RUNNING TESTS USING RELEASE VERSION AND nvfortran
!!    options test --release --compiler nvfortran
!!    #################
!!    @nag
!!    > RUNNING TESTS USING RELEASE VERSION AND nagfor
!!    options test --release --compiler nagfor
!!    #
!!    #################
!!    # OS-specific example:
!!    @Linux@install
!!    #
!!    # install executables in directory (assuming install(1) exists)
!!    #
!!    system mkdir -p ~/.local/bin
!!    options run --release T --runner "install -vbp -m 0711 -t ~/.local/bin"
!!    @install
!!    STOP INSTALL NOT SUPPORTED ON THIS PLATFORM OR $OSTYPE NOT SET
!!    #
!!    #################
!!    @fpm@testall
!!    #
!!    !fpm test --compiler nvfortran
!!    !fpm test --compiler ifort
!!    !fpm test --compiler gfortran
!!    !fpm test --compiler nagfor
!!    STOP tests complete. Any additional parameters were ignored
!!    #################
!!
!!  Would be used like
!!
!!    fpm @install
!!    fpm @nag --
!!    fpm @testall
!!
!!   NOTES
!!
!!    The intel Fortran compiler now calls the response files "indirect
!!    files" and does not add the implied suffix ".rsp" to the files
!!    anymore. It also allows the @NAME syntax anywhere on the command line,
!!    not just at the beginning. -- 20201212
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_args(prototype,help_text,version_text,string,prefix,ierr,errmsg)

! ident_1="@(#) M_CLI2 set_args(3f) parse prototype string"

character(len=*),intent(in)                       :: prototype
character(len=*),intent(in),optional              :: help_text(:)
character(len=*),intent(in),optional              :: version_text(:)
character(len=*),intent(in),optional              :: string
character(len=*),intent(in),optional              :: prefix
integer,intent(out),optional                      :: ierr
character(len=:),intent(out),allocatable,optional :: errmsg
character(len=:),allocatable                      :: hold               ! stores command line argument
integer                                           :: ibig
character(len=:),allocatable                      :: debug_mode

   debug_mode= upper(get_env('CLI_DEBUG_MODE','FALSE'))//' '
   select case(debug_mode(1:1))
   case('Y','T')
      G_DEBUG=.true.
   end select

   G_response=CLI_RESPONSE_FILE
   G_options_only=.false.
   G_passed_in=''
   G_STOP=0
   G_STOP_MESSAGE=''
   if(present(prefix))then
      G_PREFIX=prefix
   else
      G_PREFIX=''
   endif
   if(present(ierr))then
      G_QUIET=.true.
   else
      G_QUIET=.false.
   endif
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   IF(ALLOCATED(UNNAMED)) DEALLOCATE(UNNAMED)
   ALLOCATE(CHARACTER(LEN=IBIG) :: UNNAMED(0))
   if(allocated(args)) deallocate(args)
   allocate(character(len=ibig) :: args(0))

   call wipe_dictionary()
   hold='--version F --usage F --help F --version F '//adjustl(prototype)
   call prototype_and_cmd_args_to_nlist(hold,string)
   if(allocated(G_RESPONSE_IGNORED))then
      if(G_DEBUG)write(*,gen)'<DEBUG>SET_ARGS:G_RESPONSE_IGNORED:',G_RESPONSE_IGNORED
      if(size(unnamed) /= 0)write(*,*)'LOGIC ERROR'
      call split(G_RESPONSE_IGNORED,unnamed)
   endif

   if(.not.allocated(unnamed))then
       allocate(character(len=0) :: unnamed(0))
   endif
   if(.not.allocated(args))then
       allocate(character(len=0) :: args(0))
   endif
   call check_commandline(help_text,version_text) ! process --help, --version, --usage
   if(present(ierr))then
      ierr=G_STOP
   endif
   if(present(errmsg))then
      errmsg=G_STOP_MESSAGE
   endif
end subroutine set_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_subcommand(3f) - [ARGUMENTS:M_CLI2] special-case routine for
!!    handling subcommands on a command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function get_subcommand()
!!
!!     character(len=:),allocatable :: get_subcommand
!!
!!##DESCRIPTION
!!    In the special case when creating a program with subcommands it
!!    is assumed the first word on the command line is the subcommand. A
!!    routine is required to handle response file processing, therefore
!!    this routine (optionally processing response files) returns that
!!    first word as the subcommand name.
!!
!!    It should not be used by programs not building a more elaborate
!!    command with subcommands.
!!
!!##RETURNS
!!    NAME   name of subcommand
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!    program demo_get_subcommand
!!    !x! SUBCOMMANDS
!!    !x! For a command with subcommands like git(1)
!!    !x! you can make separate namelists for each subcommand.
!!    !x! You can call this program which has two subcommands (run, test),
!!    !x! like this:
!!    !x!    demo_get_subcommand --help
!!    !x!    demo_get_subcommand run -x -y -z --title -l -L
!!    !x!    demo_get_subcommand test --title -l -L --testname
!!    !x!    demo_get_subcommand run --help
!!       implicit none
!!    !x! DEFINE VALUES TO USE AS ARGUMENTS WITH INITIAL VALUES
!!       real               :: x=-999.0,y=-999.0,z=-999.0
!!       character(len=80)  :: title="not set"
!!       logical            :: l=.false.
!!       logical            :: l_=.false.
!!       character(len=80)  :: testname="not set"
!!       character(len=20)  :: name
!!       call parse(name) !x! DEFINE AND PARSE COMMAND LINE
!!       !x! ALL DONE CRACKING THE COMMAND LINE.
!!       !x! USE THE VALUES IN YOUR PROGRAM.
!!       write(*,*)'command was ',name
!!       write(*,*)'x,y,z .... ',x,y,z
!!       write(*,*)'title .... ',title
!!       write(*,*)'l,l_ ..... ',l,l_
!!       write(*,*)'testname . ',testname
!!    contains
!!    subroutine parse(name)
!!    !x! PUT EVERYTHING TO DO WITH COMMAND PARSING HERE FOR CLARITY
!!    use M_CLI2, only : set_args, get_args, get_args_fixed_length
!!    use M_CLI2, only : get_subcommand, set_mode
!!    character(len=*)              :: name    ! the subcommand name
!!    character(len=:),allocatable  :: help_text(:), version_text(:)
!!       call set_mode('response_file')
!!    ! define version text
!!       version_text=[character(len=80) :: &
!!          '@(#)PROGRAM:     demo_get_subcommand            >', &
!!          '@(#)DESCRIPTION: My demo program  >', &
!!          '@(#)VERSION:     1.0 20200715     >', &
!!          '@(#)AUTHOR:      me, myself, and I>', &
!!          '@(#)LICENSE:     Public Domain    >', &
!!          '' ]
!!        ! general help for "demo_get_subcommand --help"
!!        help_text=[character(len=80) :: &
!!         ' allowed subcommands are          ', &
!!         '   * run  -l -L --title -x -y -z  ', &
!!         '   * test -l -L --title           ', &
!!         '' ]
!!       ! find the subcommand name by looking for first word on command
!!       ! not starting with dash
!!       name = get_subcommand()
!!       select case(name)
!!       case('run')
!!        help_text=[character(len=80) :: &
!!         '                                  ', &
!!         ' Help for subcommand "run"        ', &
!!         '                                  ', &
!!         '' ]
!!        call set_args( &
!!        & '-x 1 -y 2 -z 3 --title "my title" -l F -L F',&
!!        & help_text,version_text)
!!        call get_args('x',x)
!!        call get_args('y',y)
!!        call get_args('z',z)
!!        call get_args_fixed_length('title',title)
!!        call get_args('l',l)
!!        call get_args('L',l_)
!!       case('test')
!!        help_text=[character(len=80) :: &
!!         '                                  ', &
!!         ' Help for subcommand "test"       ', &
!!         '                                  ', &
!!         '' ]
!!        call set_args(&
!!        & '--title "my title" -l F -L F --testname "Test"',&
!!        & help_text,version_text)
!!        call get_args_fixed_length('title',title)
!!        call get_args('l',l)
!!        call get_args('L',l_)
!!        call get_args_fixed_length('testname',testname)
!!       case default
!!        ! process help and version
!!        call set_args(' ',help_text,version_text)
!!        write(*,'(*(a))')'unknown or missing subcommand [',trim(name),']'
!!        write(*,'(a)')[character(len=80) ::  &
!!        ' allowed subcommands are          ', &
!!        '   * run  -l -L -title -x -y -z   ', &
!!        '   * test -l -L -title            ', &
!!        '' ]
!!        stop
!!       end select
!!    end subroutine parse
!!    end program demo_get_subcommand
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
function get_subcommand() result(sub)

! ident_2="@(#) M_CLI2 get_subcommand(3f) parse prototype string to get subcommand allowing for response files"

character(len=:),allocatable  :: sub
character(len=:),allocatable  :: cmdarg
character(len=:),allocatable  :: array(:)
character(len=:),allocatable  :: prototype
integer                       :: ilongest
integer                       :: i
integer                       :: j
   G_subcommand=''
   G_options_only=.true.
   sub=''

   if(.not.allocated(unnamed))then
      allocate(character(len=0) :: unnamed(0))
   endif

   ilongest=longest_command_argument()
   allocate(character(len=max(63,ilongest)):: cmdarg)
   cmdarg(:) = ''
   ! look for @NAME if CLI_RESPONSE_FILE=.TRUE. AND LOAD THEM
   do i = 1, command_argument_count()
      call get_command_argument(i, cmdarg)
      if(scan(adjustl(cmdarg(1:1)),'@')  ==  1)then
         call get_prototype(cmdarg,prototype)
         call split(prototype,array)
         ! assume that if using subcommands first word not starting with dash is the subcommand
         do j=1,size(array)
            if(adjustl(array(j)(1:1))  /=  '-')then
            G_subcommand=trim(array(j))
            sub=G_subcommand
            exit
         endif
         enddo
      endif
   enddo

   if(G_subcommand /= '')then
      sub=G_subcommand
   elseif(size(unnamed) /= 0)then
      sub=unnamed(1)
   else
      cmdarg(:) = ''
      do i = 1, command_argument_count()
         call get_command_argument(i, cmdarg)
         if(adjustl(cmdarg(1:1))  /=  '-')then
            sub=trim(cmdarg)
           exit
        endif
      enddo
   endif
   G_options_only=.false.
end function get_subcommand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set_usage(3f) - [ARGUMENTS:M_CLI2] allow setting a short description
!!    for keywords for the --usage switch
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     subroutine set_usage(keyword,description)
!!
!!      character(len=*),intent(in)     ::  keyword
!!      character(len=*),intent(in)     ::  description
!!
!!##DESCRIPTION
!!
!!##OPTIONS
!!     KEYWORD      the name of a command keyword
!!     DESCRIPTION  a brief one-line description of the keyword
!!
!!
!!##EXAMPLE
!!
!! sample program:
!!
!!     Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine set_usage(keyword,description,value)
character(len=*),intent(in) :: keyword
character(len=*),intent(in) :: description
character(len=*),intent(in) :: value
write(*,*)keyword
write(*,*)description
write(*,*)value
! store the descriptions in an array and then apply them when set_args(3f) is called.
! alternatively, could allow for a value as well in lieu of the prototype
end subroutine set_usage
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    prototype_to_dictionary(3f) - [ARGUMENTS:M_CLI2] parse user command
!!    and store tokens into dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     recursive subroutine prototype_to_dictionary(string)
!!
!!      character(len=*),intent(in)     ::  string
!!
!!##DESCRIPTION
!!      given a string of form
!!
!!        -var value -var value
!!
!!      define dictionary of form
!!
!!        keyword(i), value(i)
!!
!!      o  string values
!!
!!          o must be delimited with double quotes.
!!          o adjacent double quotes put one double quote into value
!!          o must not be null. A blank is specified as " ", not "".
!!
!!      o  logical values
!!
!!          o logical values must have a value. Use F.
!!
!!      o  leading and trailing blanks are removed from unquoted values
!!
!!
!!##OPTIONS
!!      STRING   string is character input string to define command
!!
!!##RETURNS
!!
!!##EXAMPLE
!!
!! sample program:
!!
!!     call prototype_to_dictionary(' -l F --ignorecase F --title "my title string" -x 10.20')
!!     call prototype_to_dictionary(' --ints 1,2,3,4')
!!
!! Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
recursive subroutine prototype_to_dictionary(string)

! ident_3="@(#) M_CLI2 prototype_to_dictionary(3f) parse user command and store tokens into dictionary"

character(len=*),intent(in)       :: string ! string is character input string of options and values

character(len=:),allocatable      :: dummy   ! working copy of string
character(len=:),allocatable      :: value
character(len=:),allocatable      :: keyword
character(len=3)                  :: delmt   ! flag if in a delimited string or not
character(len=1)                  :: currnt  ! current character being processed
character(len=1)                  :: prev    ! character to left of CURRNT
character(len=1)                  :: forwrd  ! character to right of CURRNT
integer,dimension(2)              :: ipnt
integer                           :: islen   ! number of characters in input string
integer                           :: ipoint
integer                           :: itype
integer,parameter                 :: VAL=1, KEYW=2
integer                           :: ifwd
integer                           :: ibegin
integer                           :: iend
integer                           :: place

   islen=len_trim(string)                               ! find number of characters in input string
   if(islen  ==  0)then                                 ! if input string is blank, even default variable will not be changed
      return
   endif
   dummy=adjustl(string)//'  '

   keyword=""          ! initial variable name
   value=""            ! initial value of a string
   ipoint=0            ! ipoint is the current character pointer for (dummy)
   ipnt(2)=2           ! pointer to position in keyword
   ipnt(1)=1           ! pointer to position in value
   itype=VAL           ! itype=1 for value, itype=2 for variable

   delmt="off"
   prev=" "

   G_keyword_single_letter=.true.
   do
      ipoint=ipoint+1               ! move current character pointer forward
      currnt=dummy(ipoint:ipoint)   ! store current character into currnt
      ifwd=min(ipoint+1,islen)      ! ensure not past end of string
      forwrd=dummy(ifwd:ifwd)       ! next character (or duplicate if last)

      if((currnt=="-" .and. prev==" " .and. delmt == "off" .and. index("0123456789.",forwrd) == 0).or.ipoint > islen)then
         ! beginning of a keyword
         if(forwrd == '-')then                      ! change --var to -var so "long" syntax is supported
            !x!dummy(ifwd:ifwd)='_'
            ipoint=ipoint+1                         ! ignore second - instead (was changing it to _)
            G_keyword_single_letter=.false.         ! flag this is a long keyword
         else
            G_keyword_single_letter=.true.          ! flag this is a short (single letter) keyword
         endif
         if(ipnt(1)-1 >= 1)then                     ! position in value
            ibegin=1
            iend=len_trim(value(:ipnt(1)-1))
            TESTIT: do
               if(iend  ==  0)then                  ! len_trim returned 0, value is blank
                  iend=ibegin
                  exit TESTIT
               elseif(value(ibegin:ibegin) == " ")then
                  ibegin=ibegin+1
               else
                  exit TESTIT
               endif
            enddo TESTIT
            if(keyword /= ' ')then
               if(value=='[]')value=','
               call update(keyword,value)            ! store name and its value
            elseif( G_remaining_option_allowed)then  ! meaning "--" has been encountered
               if(value=='[]')value=','
               call update('_args_',trim(value))
            else
               !x!write(warn,'(*(g0))')'*prototype_to_dictionary* warning: ignoring string [',trim(value),'] for ',trim(keyword)
               G_RESPONSE_IGNORED=TRIM(VALUE)
               if(G_DEBUG)write(*,gen)'<DEBUG>PROTOTYPE_TO_DICTIONARY:G_RESPONSE_IGNORED:',G_RESPONSE_IGNORED
            endif
         else
            call locate_key(keyword,place)
            if(keyword /= ' '.and.place < 0)then
               call update(keyword,'F')           ! store name and null value (first pass)
            elseif(keyword /= ' ')then
               call update(keyword,' ')           ! store name and null value (second pass)
            elseif(.not.G_keyword_single_letter.and.ipoint-2 == islen) then ! -- at end of line
               G_remaining_option_allowed=.true.  ! meaning for "--" is that everything on commandline goes into G_remaining
            endif
         endif
         itype=KEYW                            ! change to expecting a keyword
         value=""                              ! clear value for this variable
         keyword=""                            ! clear variable name
         ipnt(1)=1                             ! restart variable value
         ipnt(2)=1                             ! restart variable name

      else       ! currnt is not one of the special characters
         ! the space after a keyword before the value
         if(currnt == " " .and. itype  ==  KEYW)then
            ! switch from building a keyword string to building a value string
            itype=VAL
            ! beginning of a delimited value
         elseif(currnt  ==  """".and.itype  ==  VAL)then
            ! second of a double quote, put quote in
            if(prev  ==  """")then
               if(itype == VAL)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
               delmt="on"
            elseif(delmt  ==  "on")then     ! first quote of a delimited string
               delmt="off"
            else
               delmt="on"
            endif
            if(prev /= """")then  ! leave quotes where found them
               if(itype == VAL)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
            endif
         else     ! add character to current keyword or value
            if(itype == VAL)then
               value=value//currnt
            else
               keyword=keyword//currnt
            endif
            ipnt(itype)=ipnt(itype)+1
         endif

      endif

      prev=currnt
      if(ipoint <= islen)then
         cycle
      else
         exit
      endif
   enddo

end subroutine prototype_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    specified(3f) - [ARGUMENTS:M_CLI2] return true if keyword was present
!!    on command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental impure function specified(name)
!!
!!     character(len=*),intent(in) :: name
!!     logical :: specified
!!
!!##DESCRIPTION
!!
!!    specified(3f) returns .true. if the specified keyword was present on
!!    the command line.
!!
!!    M_CLI2 intentionally does not have validators except for SPECIFIED(3f)
!!    and of course a check whether the input conforms to the type when
!!    requesting a value (with get_args(3f) or the convenience functions
!!    like inum(3f)).
!!
!!    Fortran already has powerful validation capabilities. Logical
!!    expressions ANY(3f) and ALL(3f) are standard Fortran features which
!!    easily allow performing the common validations for command line
!!    arguments without having to learn any additional syntax or methods.
!!
!!##OPTIONS
!!
!!    NAME   name of commandline argument to query the presence of. Long
!!           names should always be used.
!!
!!##RETURNS
!!    SPECIFIED  returns .TRUE. if specified NAME was present on the command
!!               line when the program was invoked.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!    program demo_specified
!!    use, intrinsic :: iso_fortran_env, only : &
!!    & stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
!!    use M_CLI2,  only : set_args, igets, rgets, specified, sget, lget
!!    implicit none
!!
!!    ! Define args
!!    integer,allocatable  :: ints(:)
!!    real,allocatable     :: floats(:)
!!    logical              :: flag
!!    character(len=:),allocatable :: color
!!    character(len=:),allocatable :: list(:)
!!    integer :: i
!!
!!     call set_args('&
!!        & --color:c "red"       &
!!        & --flag:f F            &
!!        & --ints:i 1,10,11      &
!!        & --floats:T 12.3, 4.56 &
!!        & ')
!!     ints=igets('ints')
!!     floats=rgets('floats')
!!     flag=lget('flag')
!!     color=sget('color')
!!
!!     write(*,*)'color=',color
!!     write(*,*)'flag=',flag
!!     write(*,*)'ints=',ints
!!     write(*,*)'floats=',floats
!!
!!     write(*,*)'was -flag specified?',specified('flag')
!!
!!     ! elemental
!!     write(*,*)specified(['floats','ints  '])
!!
!!     ! If you want to know if groups of parameters were specified use
!!     ! ANY(3f) and ALL(3f)
!!     write(*,*)'ANY:',any(specified(['floats','ints  ']))
!!     write(*,*)'ALL:',all(specified(['floats','ints  ']))
!!
!!     ! For mutually exclusive
!!     if (all(specified(['floats','ints  '])))then
!!         write(*,*)'You specified both names --ints and --floats'
!!     endif
!!
!!     ! For required parameter
!!     if (.not.any(specified(['floats','ints  '])))then
!!         write(*,*)'You must specify --ints or --floats'
!!     endif
!!
!!    ! check if all values are in range from 10 to 30 and even
!!    write(*,*)'are all numbers good?',all([ints>=10,ints<= 30,(ints/2)*2==ints])
!!
!!    ! perhaps you want to check one value at a time
!!    do i=1,size(ints)
!!       write(*,*)ints(i),[ints(i) >= 10,ints(i) <= 30,(ints(i)/2)*2 == ints(i)]
!!       if(all([ints(i) >= 10,ints(i) <= 30,(ints(i)/2)*2 == ints(i)]) )then
!!          write(*,*)ints(i),'is an even number from 10 to 30 inclusive'
!!       else
!!          write(*,*)ints(i),'is not an even number from 10 to 30 inclusive'
!!       endif
!!    enddo
!!
!!    list = [character(len=10) :: 'red','white','blue']
!!    if( any(color == list) )then
!!       write(*,*)color,'matches a value in the list'
!!    else
!!       write(*,*)color,'not in the list'
!!    endif
!!
!!    if(size(ints).eq.3)then
!!       write(*,*)'ints(:) has expected number of values'
!!    else
!!       write(*,*)'ints(:) does not have expected number of values'
!!    endif
!!
!!    end program demo_specified
!!
!! Default output
!!
!!  > color=red
!!  > flag= F
!!  > ints=           1          10          11
!!  > floats=   12.3000002       4.55999994
!!  > was -flag specified? F
!!  > F F
!!  > ANY: F
!!  > ALL: F
!!  > You must specify --ints or --floats
!!  >           1 F T F
!!  >           1  is not an even number from 10 to 30 inclusive
!!  >          10 T T T
!!  >          10  is an even number from 10 to 30 inclusive
!!  >          11 T T F
!!  >          11  is not an even number from 10 to 30 inclusive
!!  > red matches a value in the list
!!  > ints(:) has expected number of values
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
elemental impure function specified(key)
character(len=*),intent(in) :: key
logical                     :: specified
integer                     :: place
   call locate_key(key,place)                   ! find where string is or should be
   if(place < 1)then
      specified=.false.
   else
      specified=present_in(place)
   endif
end function specified
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    update(3f) - [ARGUMENTS:M_CLI2] update internal dictionary given
!!    keyword and value
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine update(key,val)
!!
!!      character(len=*),intent(in)           :: key
!!      character(len=*),intent(in),optional  :: val
!!##DESCRIPTION
!!      Update internal dictionary in M_CLI2(3fm) module.
!!##OPTIONS
!!      key  name of keyword to add, replace, or delete from dictionary
!!      val  if present add or replace value associated with keyword. If not
!!           present remove keyword entry from dictionary.
!!
!!           If "present" is true, a value will be appended
!!##EXAMPLE
!!
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine update(key,val)
character(len=*),intent(in)           :: key
character(len=*),intent(in),optional  :: val
integer                               :: place, ii
integer                               :: iilen
character(len=:),allocatable          :: val_local
character(len=:),allocatable          :: short
character(len=:),allocatable          :: long
character(len=:),allocatable          :: long_short(:)
integer                               :: isize
logical                               :: set_mandatory
   set_mandatory=.false.
   if(G_IGNOREALLCASE) then
      call split(lower(trim(key)),long_short,':',nulls='return') ! split long:short keyword or long:short:: or long:: or short::
   else
      call split(trim(key),long_short,':',nulls='return') ! split long:short keyword or long:short:: or long:: or short::
   endif
   ! check for :: on end
   isize=size(long_short)

   if(isize > 0)then                     ! very special-purpose syntax where if ends in :: next field is a value even
      if(long_short(isize) == '')then    ! if it starts with a dash, for --flags option on fpm(1).
         set_mandatory=.true.
         long_short=long_short(:isize-1)
      endif
   endif

   select case(size(long_short))
   case(0)
      long=''
      short=''
   case(1)
      long=trim(long_short(1))
      if(len_trim(long) == 1)then
         !x!ii= findloc (shorts, long, dim=1) ! if parsing arguments on line and a short keyword look up long value
         ii=maxloc([0,merge(1, 0, shorts == long)],dim=1)
         if(ii > 1)then
            long=keywords(ii-1)
         endif
         short=long
      else
         short=''
      endif
   case(2)
      long=trim(long_short(1))
      short=trim(long_short(2))
   case default
      write(warn,*)'WARNING: incorrect syntax for key: ',trim(key)
      long=trim(long_short(1))
      short=trim(long_short(2))
   end select
   if(G_UNDERDASH) long=replace_str(long,'-','_')
   if(G_NODASHUNDER)then
      long=replace_str(long,'-','')
      long=replace_str(long,'_','')
   endif
   if(G_IGNORELONGCASE.and.len_trim(long) > 1)long=lower(long)
   if(present(val))then
      val_local=val
      iilen=len_trim(val_local)
      call locate_key(long,place)                  ! find where string is or should be
      if(place < 1)then                                ! if string was not found insert it
         call insert_(keywords,long,iabs(place))
         call insert_(values,val_local,iabs(place))
         call insert_(counts,iilen,iabs(place))
         call insert_(shorts,short,iabs(place))
         call insert_(present_in,.true.,iabs(place))
         call insert_(mandatory,set_mandatory,iabs(place))
      else
         if(present_in(place))then                      ! if multiple keywords append values with space between them
            if(G_append)then
               if(values(place)(1:1) == '"')then
               ! UNDESIRABLE: will ignore previous blank entries
                  val_local='"'//trim(unquote(values(place)))//' '//trim(unquote(val_local))//'"'
               else
                  val_local=clipends(values(place))//' '//val_local
               endif
            endif
            iilen=len_trim(val_local)
         endif
         call replace_(values,val_local,place)
         call replace_(counts,iilen,place)
         call replace_(present_in,.true.,place)
      endif
   else                                                 ! if no value is present remove the keyword and related values
      call locate_key(long,place)                       ! check name as long and short
      if(place > 0)then
         call remove_(keywords,place)
         call remove_(values,place)
         call remove_(counts,place)
         call remove_(shorts,place)
         call remove_(present_in,place)
         call remove_(mandatory,place)
      endif
   endif
end subroutine update
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    wipe_dictionary(3fp) - [ARGUMENTS:M_CLI2] reset private M_CLI2(3fm)
!!    dictionary to empty
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!      subroutine wipe_dictionary()
!!##DESCRIPTION
!!      reset private M_CLI2(3fm) dictionary to empty
!!##EXAMPLE
!!
!! Sample program:
!!
!!      program demo_wipe_dictionary
!!      use M_CLI2, only : dictionary
!!         call wipe_dictionary()
!!      end program demo_wipe_dictionary
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine wipe_dictionary()
   if(allocated(keywords))deallocate(keywords)
   allocate(character(len=0) :: keywords(0))
   if(allocated(values))deallocate(values)
   allocate(character(len=0) :: values(0))
   if(allocated(counts))deallocate(counts)
   allocate(counts(0))
   if(allocated(shorts))deallocate(shorts)
   allocate(character(len=0) :: shorts(0))
   if(allocated(present_in))deallocate(present_in)
   allocate(present_in(0))
   if(allocated(mandatory))deallocate(mandatory)
   allocate(mandatory(0))
end subroutine wipe_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get(3f) - [ARGUMENTS:M_CLI2] get dictionary value associated with
!!    key name in private M_CLI2(3fm) dictionary
!!##SYNOPSIS
!!
!!
!!##DESCRIPTION
!!    Get dictionary value associated with key name in private M_CLI2(3fm)
!!    dictionary.
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!===================================================================================================================================
function get(key) result(valout)
character(len=*),intent(in)   :: key
character(len=:),allocatable  :: valout
integer                       :: place
   ! find where string is or should be
   call locate_key(key,place)
   if(place < 1)then
      valout=''
   else
      valout=values(place)(:counts(place))
   endif
end function get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    prototype_and_cmd_args_to_nlist(3f) - [ARGUMENTS:M_CLI2] convert
!!    Unix-like command arguments to table
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine prototype_and_cmd_args_to_nlist(prototype)
!!
!!      character(len=*) :: prototype
!!##DESCRIPTION
!!    create dictionary with character keywords, values, and value lengths
!!    using the routines for maintaining a list from command line arguments.
!!##OPTIONS
!!      prototype
!!##EXAMPLE
!!
!! Sample program
!!
!!      program demo_prototype_and_cmd_args_to_nlist
!!      use M_CLI2,  only : prototype_and_cmd_args_to_nlist, unnamed
!!      implicit none
!!      character(len=:),allocatable :: readme
!!      character(len=256)           :: message
!!      integer                      :: ios
!!      integer                      :: i
!!      doubleprecision              :: something
!!
!!      ! define arguments
!!      logical            :: l,h,v
!!      real               :: p(2)
!!      complex            :: c
!!      doubleprecision    :: x,y,z
!!
!!      ! uppercase keywords get an underscore to make it easier to remember
!!      logical            :: l_,h_,v_
!!      ! character variables must be long enough to hold returned value
!!      character(len=256) :: a_,b_
!!      integer            :: c_(3)
!!
!!         ! give command template with default values
!!         ! all values except logicals get a value.
!!         ! strings must be delimited with double quotes
!!         ! A string has to have at least one character as for -A
!!         ! lists of numbers should be comma-delimited.
!!         ! No spaces are allowed in lists of numbers
!!         call prototype_and_cmd_args_to_nlist('&
!!         & -l -v -h -LVH -x 0 -y 0.0 -z 0.0d0 -p 0,0 &
!!         & -A " " -B "Value B" -C 10,20,30 -c (-123,-456)',readme)
!!
!!         call get_args('x',x,'y',y,'z',z)
!!            something=sqrt(x**2+y**2+z**2)
!!            write (*,*)something,x,y,z
!!            if(size(unnamed) > 0)then
!!               write (*,'(a)')'files:'
!!               write (*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!            endif
!!      end program demo_prototype_and_cmd_args_to_nlist
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine prototype_and_cmd_args_to_nlist(prototype,string)

! ident_4="@(#) M_CLI2 prototype_and_cmd_args_to_nlist create dictionary from prototype if not null and update from command line"

character(len=*),intent(in)           :: prototype
character(len=*),intent(in),optional  :: string
integer                               :: ibig
integer                               :: itrim
integer                               :: iused

   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:START'
   G_passed_in=prototype                            ! make global copy for printing
   ibig=longest_command_argument()                  ! bug in gfortran. len=0 should be fine
   ibig=max(ibig,1)
   IF(ALLOCATED(UNNAMED))DEALLOCATE(UNNAMED)
   ALLOCATE(CHARACTER(LEN=IBIG) :: UNNAMED(0))
   if(allocated(args))deallocate(args)
   allocate(character(len=ibig) :: args(0))

   G_remaining_option_allowed=.false.
   G_remaining_on=.false.
   G_remaining=''
   if(prototype /= '')then
      call prototype_to_dictionary(prototype)       ! build dictionary from prototype

      ! if short keywords not used by user allow them for standard options

      call locate_key('h',iused)
      if(iused <= 0)then
         call update('help')
         call update('help:h','F')
      endif

      call locate_key('v',iused)
      if(iused <= 0)then
         call update('version')
         call update('version:v','F')
      endif

      call locate_key('V',iused)
      if(iused <= 0)then
         call update('verbose')
         call update('verbose:V','F')
      endif

      call locate_key('u',iused)
      if(iused <= 0)then
         call update('usage')
         call update('usage:u','F')
      endif

      present_in=.false.                            ! reset all values to false so everything gets written
   endif

   if(present(string))then                          ! instead of command line arguments use another prototype string
      if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:CALL PROTOTYPE_TO_DICTIONARY:STRING=',STRING
      call prototype_to_dictionary(string)          ! build dictionary from prototype
   else
      if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:CALL CMD_ARGS_TO_DICTIONARY:CHECK=',.true.
      call cmd_args_to_dictionary()
   endif

   if( len(G_remaining) > 1)then                    ! if -- was in prototype then after -- on input return rest in this string
      itrim=len(G_remaining)
      if(G_remaining(itrim:itrim) == ' ')then       ! was adding a space at end as building it, but do not want to remove blanks
         G_remaining=G_remaining(:itrim-1)
      endif
      remaining=G_remaining
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:NORMAL END'
end subroutine prototype_and_cmd_args_to_nlist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine expand_response(name)
character(len=*),intent(in)  :: name
character(len=:),allocatable :: prototype
logical                      :: hold

   if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:START:NAME=',name

   call get_prototype(name,prototype)

   if(prototype /= '')then
      hold=G_append
      G_append=.false.
      if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:CALL PROTOTYPE_TO_DICTIONARY:PROTOTYPE=',prototype
      call prototype_to_dictionary(prototype)       ! build dictionary from prototype
      G_append=hold
   endif

   if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:END'

end subroutine expand_response
!===================================================================================================================================
subroutine get_prototype(name,prototype) ! process @name abbreviations
character(len=*),intent(in) :: name
character(len=:),allocatable,intent(out) :: prototype
character(len=:),allocatable             :: filename
character(len=:),allocatable             :: os
character(len=:),allocatable             :: plain_name
character(len=:),allocatable             :: search_for
integer                                  :: lun
integer                                  :: ios
integer                                  :: itrim
character(len=4096)                      :: line !x! assuming input never this long
character(len=256)                       :: message
character(len=:),allocatable             :: array(:) ! output array of tokens
integer                                  :: lines_processed

   lines_processed=0
   plain_name=name//'  '
   plain_name=trim(name(2:))
   os= '@' // get_env('OSTYPE',get_env('OS'))
   if(G_DEBUG)write(*,gen)'<DEBUG>GET_PROTOTYPE:OS=',OS

   search_for=''
   ! look for NAME.rsp and see if there is an @OS  section in it and position to it and read
   if(os /= '@')then
      search_for=os
      call find_and_read_response_file(plain_name)
      if(lines_processed /= 0)return
   endif

   ! look for NAME.rsp and see if there is anything before an OS-specific section
   search_for=''
   call find_and_read_response_file(plain_name)
   if(lines_processed /= 0)return

   ! look for ARG0.rsp  with @OS@NAME  section in it and position to it
   if(os /= '@')then
      search_for=os//name
      call find_and_read_response_file(basename(get_name(),suffix=.false.))
      if(lines_processed /= 0)return
   endif

   ! look for ARG0.rsp  with a section called @NAME in it and position to it
   search_for=name
   call find_and_read_response_file(basename(get_name(),suffix=.false.))
   if(lines_processed /= 0)return

   write(*,gen)'<ERROR> response name ['//trim(name)//'] not found'
   stop 1
contains
!===================================================================================================================================
subroutine find_and_read_response_file(rname)
! search for a simple file named the same as the @NAME field with one entry assumed in it
character(len=*),intent(in)  :: rname
character(len=:),allocatable :: paths(:)
character(len=:),allocatable :: testpath
character(len=256)           :: message
integer                      :: i
integer                      :: ios
   prototype=''
   ! look for NAME.rsp
   ! assume if have / or \ a full filename was supplied to support ifort(1)
   if((index(rname,'/') /= 0.or.index(rname,'\') /= 0) .and. len(rname) > 1 )then
      filename=rname
      lun=fileopen(filename,message)
      if(lun /= -1)then
         call process_response()
         close(unit=lun,iostat=ios)
      endif
      return
   else
      filename=rname//'.rsp'
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:FILENAME=',filename

   ! look for name.rsp in directories from environment variable assumed to be a colon-separated list of directories
   call split(get_env('CLI_RESPONSE_PATH','~/.local/share/rsp'),paths)
   paths=[character(len=len(paths)) :: ' ',paths]
   if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:PATHS=',paths

   do i=1,size(paths)
      testpath=join_path(paths(i),filename)
      lun=fileopen(testpath,message)
      if(lun /= -1)then
         if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:SEARCH_FOR=',search_for
         if(search_for /= '') call position_response() ! set to end of file or where string was found
         call process_response()
         if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:LINES_PROCESSED=',LINES_PROCESSED
         close(unit=lun,iostat=ios)
         if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:CLOSE:LUN=',LUN,' IOSTAT=',IOS
         if(lines_processed /= 0)exit
      endif
   enddo

end subroutine find_and_read_response_file
!===================================================================================================================================
subroutine position_response()
integer :: ios
   line=''
   INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         if(G_DEBUG)write(*,gen)'<DEBUG>POSITION_RESPONSE:EOF'
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios /= 0)then
         write(*,gen)'<ERROR>*position_response*:'//trim(message)
         exit INFINITE
      endif
      line=adjustl(line)
      if(line == search_for)return
   enddo INFINITE
end subroutine position_response
!===================================================================================================================================
subroutine process_response()
character(len=:),allocatable :: padded
character(len=:),allocatable :: temp
   line=''
   lines_processed=0
      INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios /= 0)then
         write(*,gen)'<ERROR>*process_response*:'//trim(message)
         exit INFINITE
      endif
      line=clipends(line)
      temp=line
      if(index(temp//' ','#') == 1)cycle
      if(temp /= '')then

         if(index(temp,'@') == 1.and.lines_processed /= 0)exit INFINITE

         call split(temp,array) ! get first word
         itrim=len_trim(array(1))+2
         temp=temp(itrim:)

         PROCESS: select case(lower(array(1)))
         case('comment','#','')
         case('system','!','$')
            if(G_options_only)exit PROCESS
            lines_processed= lines_processed+1
            call execute_command_line(temp)
         case('options','option','-')
            lines_processed= lines_processed+1
            prototype=prototype//' '//trim(temp)
         case('print','>','echo')
            if(G_options_only)exit PROCESS
            lines_processed= lines_processed+1
            write(*,'(a)')trim(temp)
         case('stop')
            if(G_options_only)exit PROCESS
            write(*,'(a)')trim(temp)
            stop
         case default
            if(array(1)(1:1) == '-')then
               ! assume these are simply options to support ifort(1)
               ! if starts with a single dash must assume a single argument
               ! and rest is value to support -Dname and -Ifile option
               ! which currently is not supported, so multiple short keywords
               ! does not work. Just a ifort(1) test at this point, so do not document
               if(G_options_only)exit PROCESS
               padded=trim(line)//'  '
               if(padded(2:2) == '-')then
                  prototype=prototype//' '//trim(line)
               else
                  prototype=prototype//' '//padded(1:2)//' '//trim(padded(3:))
               endif
               lines_processed= lines_processed+1
            else
               if(array(1)(1:1) == '@')cycle INFINITE !skip adjacent @ lines from first
               lines_processed= lines_processed+1
               write(*,'(*(g0))')'unknown response keyword [',array(1),'] with options of [',trim(temp),']'
            endif
         end select PROCESS

      endif
      enddo INFINITE
end subroutine process_response

end subroutine get_prototype
!===================================================================================================================================
function fileopen(filename,message) result(lun)
character(len=*),intent(in)              :: filename
character(len=*),intent(out),optional    :: message
integer                                  :: lun
integer                                  :: ios
character(len=256)                       :: message_local

   ios=0
   message_local=''
   open(file=filename,newunit=lun,&
    & form='formatted',access='sequential',action='read',&
    & position='rewind',status='old',iostat=ios,iomsg=message_local)

   if(ios /= 0)then
      lun=-1
      if(present(message))then
         message=trim(message_local)
      else
         write(*,gen)trim(message_local)
      endif
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>FILEOPEN:FILENAME=',filename,' LUN=',lun,' IOS=',IOS,' MESSAGE=',trim(message_local)

end function fileopen
!===================================================================================================================================
function get_env(NAME,DEFAULT) result(VALUE)
character(len=*),intent(in)          :: NAME
character(len=*),intent(in),optional :: DEFAULT
character(len=:),allocatable         :: VALUE
integer                              :: howbig
integer                              :: stat
integer                              :: length
   ! get length required to hold value
   length=0
   if(NAME /= '')then
      call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)
      select case (stat)
      case (1)
          !x!print *, NAME, " is not defined in the environment. Strange..."
          VALUE=''
      case (2)
          !x!print *, "This processor doesn't support environment variables. Boooh!"
          VALUE=''
      case default
          ! make string to hold value of sufficient size
          if(allocated(value))deallocate(value)
          allocate(character(len=max(howbig,1)) :: VALUE)
          ! get value
         call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)
          if(stat /= 0)VALUE=''
      end select
   else
      VALUE=''
   endif
   if(VALUE == ''.and.present(DEFAULT))VALUE=DEFAULT
end function get_env
!===================================================================================================================================
function join_path(a1,a2,a3,a4,a5) result(path)
   ! Construct path by joining strings with os file separator
   !
   character(len=*), intent(in)           :: a1, a2
   character(len=*), intent(in), optional :: a3, a4, a5
   character(len=:), allocatable          :: path
   character(len=1)                       :: filesep

   filesep = separator()
   if(a1 /= '')then
      path = trim(a1) // filesep // trim(a2)
   else
      path = trim(a2)
   endif
   if (present(a3)) path = path // filesep // trim(a3)
   if (present(a4)) path = path // filesep // trim(a4)
   if (present(a5)) path = path // filesep // trim(a5)
   path=adjustl(path//'  ')
   path=path(1:1)//replace_str(path,filesep//filesep,'') ! some systems allow names starting with '//' or '\\'
   path=trim(path)
end function join_path
!===================================================================================================================================
function get_name() result(name)
! get the pathname of arg0
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: istat
character(len=4096)          :: long_name
character(len=:),allocatable :: name
   arg0_length=0
   name=''
   long_name=''
   call get_command_argument(0,length=arg0_length,status=istat)
   if(istat == 0)then
      if(allocated(arg0))deallocate(arg0)
      allocate(character(len=arg0_length) :: arg0)
      call get_command_argument(0,arg0,status=istat)
      if(istat == 0)then
         inquire(file=arg0,iostat=istat,name=long_name)
         name=trim(long_name)
      else
         name=arg0
      endif
   endif
end function get_name
!===================================================================================================================================
function basename(path,suffix) result (base)
    ! Extract filename from path with/without suffix
    !
character(*), intent(In) :: path
logical, intent(in), optional :: suffix
character(:), allocatable :: base

character(:), allocatable :: file_parts(:)
logical :: with_suffix

   if (.not.present(suffix)) then
      with_suffix = .true.
   else
      with_suffix = suffix
   endif

   if (with_suffix) then
      call split(path,file_parts,delimiters='\/')
      if(size(file_parts) > 0)then
         base = trim(file_parts(size(file_parts)))
      else
         base = ''
      endif
   else
      call split(path,file_parts,delimiters='\/.')
      if(size(file_parts) >= 2)then
         base = trim(file_parts(size(file_parts)-1))
      elseif(size(file_parts) == 1)then
         base = trim(file_parts(1))
      else
         base = ''
      endif
   endif
end function basename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!! !>
!!##NAME
!!     separator(3f) - [M_io:ENVIRONMENT] try to determine pathname directory
!!     separator character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     function separator() result(sep)
!!
!!      character(len=1) :: sep
!!
!!##DESCRIPTION
!!    First testing for the existence of "/.",  then if that fails a list
!!    of variable names assumed to contain directory paths {PATH|HOME} are
!!    examined first for a backslash, then a slash. Assuming basically the
!!    choice is a ULS or MSWindows system, and users can do weird things like
!!    put a backslash in a ULS path and break it.
!!
!!    Therefore can be very system dependent. If the queries fail the
!!    default returned is "/".
!!
!!##EXAMPLE
!!
!!
!!    sample usage
!!
!!     program demo_separator
!!     use M_io, only : separator
!!     implicit none
!!        write(*,*)'separator=',separator()
!!     end program demo_separator
!===================================================================================================================================
function separator() result(sep)
! use the pathname returned as arg0 to determine pathname separator
integer                      :: ios
integer                      :: i
logical                      :: existing=.false.
character(len=1)             :: sep
!x!IFORT BUG:character(len=1),save        :: sep_cache=' '
integer,save                 :: isep=-1
character(len=4096)          :: name
character(len=:),allocatable :: envnames(:)

    ! NOTE:  A parallel code might theoretically use multiple OS
    !x!FORT BUG:if(sep_cache /= ' ')then  ! use cached value.
    !x!FORT BUG:    sep=sep_cache
    !x!FORT BUG:    return
    !x!FORT BUG:endif
    if(isep /= -1)then  ! use cached value.
        sep=char(isep)
        return
    endif
    FOUND: block
    ! simple, but does not work with ifort
    ! most MSWindows environments see to work with backslash even when
    ! using POSIX filenames to do not rely on '\.'.
    inquire(file='/.',exist=existing,iostat=ios,name=name)
    if(existing.and.ios == 0)then
        sep='/'
        exit FOUND
    endif
    ! check variables names common to many platforms that usually have a
    ! directory path in them although a ULS file can contain a backslash
    ! and vice-versa (eg. "touch A\\B\\C"). Removed HOMEPATH because it
    ! returned a name with backslash on CygWin, Mingw, WLS even when using
    ! POSIX filenames in the environment.
    envnames=[character(len=10) :: 'PATH', 'HOME']
    do i=1,size(envnames)
       if(index(get_env(envnames(i)),'\') /= 0)then
          sep='\'
          exit FOUND
       elseif(index(get_env(envnames(i)),'/') /= 0)then
          sep='/'
          exit FOUND
       endif
    enddo

    write(*,*)'<WARNING>unknown system directory path separator'
    sep='\'
    endblock FOUND
    !x!IFORT BUG:sep_cache=sep
    isep=ichar(sep)
end function separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine cmd_args_to_dictionary()
! convert command line arguments to dictionary entries
!x!logical                      :: guess_if_value
integer                      :: pointer
character(len=:),allocatable :: lastkeyword
integer                      :: i, jj, kk
integer                      :: ilength, istatus, imax
character(len=1)             :: letter
character(len=:),allocatable :: current_argument
character(len=:),allocatable :: current_argument_padded
character(len=:),allocatable :: dummy
character(len=:),allocatable :: oldvalue
logical                      :: nomore
logical                      :: next_mandatory
   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START'
   next_mandatory=.false.
   nomore=.false.
   pointer=0
   lastkeyword=' '
   G_keyword_single_letter=.true.
   i=1
   current_argument=''
   GET_ARGS: do while (get_next_argument()) ! insert and replace entries
      if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:WHILE:CURRENT_ARGUMENT=',current_argument

      if( current_argument  ==  '-' .and. nomore .eqv. .true. )then   ! sort of
      elseif( current_argument  ==  '-')then                          ! sort of
         current_argument='"stdin"'
      endif
      if( current_argument  ==  '--' .and. nomore .eqv. .true. )then  ! -- was already encountered
      elseif( current_argument  ==  '--' )then                        ! everything after this goes into the unnamed array
         nomore=.true.
         pointer=0
         if(G_remaining_option_allowed)then
            G_remaining_on=.true.
         endif
         cycle GET_ARGS
      endif

      dummy=current_argument//'   '
      current_argument_padded=current_argument//'   '

      if(.not.next_mandatory.and..not.nomore.and.current_argument_padded(1:2) == '--')then    ! beginning of long word
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START_LONG:'
         G_keyword_single_letter=.false.
         if(lastkeyword /= '')then
            call ifnull()
         endif
         call locate_key(current_argument_padded(3:),pointer)
         if(pointer <= 0)then
            if(G_QUIET)then
               lastkeyword="UNKNOWN"
               pointer=0
               cycle GET_ARGS
            endif
            call print_dictionary('UNKNOWN LONG KEYWORD: '//current_argument)
            call mystop(1)
            return
         endif
         lastkeyword=trim(current_argument_padded(3:))
         next_mandatory=mandatory(pointer)
      elseif(.not.next_mandatory &
      & .and..not.nomore &
      & .and.current_argument_padded(1:1) == '-' &
      & .and.index("0123456789.",dummy(2:2)) == 0)then
      ! short word
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START_SHORT'
         G_keyword_single_letter=.true.
         if(lastkeyword /= '')then
            call ifnull()
         endif
         call locate_key(current_argument_padded(2:),pointer)
         jj=len(current_argument)
         if( (pointer <= 0.or.jj.ge.3).and.(G_STRICT) )then  ! name not found
            if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:SHORT NOT FOUND:',current_argument_padded(2:)
            ! in strict mode this might be multiple single-character values
            do kk=2,jj
               letter=current_argument_padded(kk:kk)
               call locate_key(letter,pointer)
               if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:LETTER:',letter,pointer
               if(pointer > 0)then
                  call update(keywords(pointer),'T')
               else
                  if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:UNKNOWN SHORT:',letter
                  call print_dictionary('UNKNOWN SHORT KEYWORD:'//letter) ! //' in '//current_argument)
                  if(G_QUIET)then
                     lastkeyword="UNKNOWN"
                     pointer=0
                     cycle GET_ARGS
                  endif
                  call mystop(2)
                  return
               endif
               current_argument='-'//current_argument_padded(jj:jj)
            enddo
            !--------------
            lastkeyword=""
            pointer=0
            if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:SHORT_END:2:'
            cycle GET_ARGS
            !--------------
         elseif(pointer<0)then
            if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:UNKNOWN SHORT_CONFIRMED:',letter
            call print_dictionary('UNKNOWN SHORT KEYWORD:'//current_argument_padded(2:))
            if(G_QUIET)then
               lastkeyword="UNKNOWN"
               pointer=0
               cycle GET_ARGS
            endif
            call mystop(2)
            return
         endif
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:SHORT_END:1:'
         lastkeyword=trim(current_argument_padded(2:))
         next_mandatory=mandatory(pointer)
      elseif(pointer == 0)then                                       ! unnamed arguments
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:UNNAMED ARGUMENT:',current_argument
         if(G_remaining_on)then
            if(len(current_argument) < 1)then
               G_remaining=G_remaining//'"" '
            elseif(current_argument(1:1) == '-')then
               !get fancier to handle spaces and =!G_remaining=G_remaining//current_argument//' '
               G_remaining=G_remaining//'"'//current_argument//'" '
            else
               G_remaining=G_remaining//'"'//current_argument//'" '
            endif
            imax=max(len(args),len(current_argument))
            args=[character(len=imax) :: args,current_argument]
         else
            imax=max(len(unnamed),len(current_argument))
            if(scan(current_argument//' ','@') == 1.and.G_response)then
               if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:1:CALL EXPAND_RESPONSE:CURRENT_ARGUMENT=',current_argument
               call expand_response(current_argument)
            else
               unnamed=[character(len=imax) :: unnamed,current_argument]
            endif
         endif
      else
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:FOUND:',current_argument
         oldvalue=get(keywords(pointer))//' '
         if(oldvalue(1:1) == '"')then
            current_argument=quote(current_argument(:ilength))
         endif
         if(upper(oldvalue) == 'F'.or.upper(oldvalue) == 'T')then  ! assume boolean parameter
            if(current_argument /= ' ')then
               if(G_remaining_on)then
                  if(len(current_argument) < 1)then
                        G_remaining=G_remaining//'"" '
                  elseif(current_argument(1:1) == '-')then
                       !get fancier to handle spaces and =!G_remaining=G_remaining//current_argument//' '
                        G_remaining=G_remaining//'"'//current_argument//'" '
                  else
                        G_remaining=G_remaining//'"'//current_argument//'" '
                  endif
                  imax=max(len(args),len(current_argument))
                  args=[character(len=imax) :: args,current_argument]
               else
                  imax=max(len(unnamed),len(current_argument))
                  if(scan(current_argument//' ','@') == 1.and.G_response)then
                    if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:2:CALL EXPAND_RESPONSE:CURRENT_ARGUMENT=',current_argument
                    call expand_response(current_argument)
                  else
                    unnamed=[character(len=imax) :: unnamed,current_argument]
                  endif
               endif
            endif
            current_argument='T'
         endif
         call update(keywords(pointer),current_argument)
         pointer=0
         lastkeyword=''
         next_mandatory=.false.
      endif
   enddo GET_ARGS
   if(lastkeyword /= '')then
      call ifnull()
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:NORMAL END'

contains

subroutine ifnull()

   oldvalue=clipends(get(lastkeyword))//' '

   if(upper(oldvalue(1:1)) == 'F'.or.upper(oldvalue(1:1)) == 'T')then
      call update(lastkeyword,'T')
   elseif(oldvalue(1:1) == '"')then
      call update(lastkeyword,'" "')
   else
      call update(lastkeyword,' ')
   endif

end subroutine ifnull

function get_next_argument()
!
! get next argument from command line into allocated variable current_argument
!
logical,save :: hadequal=.false.
character(len=:),allocatable,save :: right_hand_side
logical :: get_next_argument
integer :: iright
integer :: iequal

   if(hadequal)then  ! use left-over value from previous -NAME=VALUE syntax
      current_argument=right_hand_side
      right_hand_side=''
      hadequal=.false.
      get_next_argument=.true.
      ilength=len(current_argument)
      return
   endif

   if(i>command_argument_count())then
      get_next_argument=.false.
      return
   else
      get_next_argument=.true.
   endif

   call get_command_argument(number=i,length=ilength,status=istatus)                              ! get next argument
   if(istatus /= 0) then                                                                          ! on error
      write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
         &'status=',istatus,&
         &'length=',ilength
      get_next_argument=.false.
   else
      ilength=max(ilength,1)
      if(allocated(current_argument))deallocate(current_argument)
      allocate(character(len=ilength) :: current_argument)
      call get_command_argument(number=i,value=current_argument,length=ilength,status=istatus)    ! get next argument
      if(istatus /= 0) then                                                                       ! on error
         write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
            &'status=',istatus,&
            &'length=',ilength,&
            &'target length=',len(current_argument)
         get_next_argument=.false.
       endif

       ! if an argument keyword and an equal before a space split on equal and save right hand side for next call
       if(nomore)then
       elseif( len(current_argument) == 0)then
       else
          iright=index(current_argument,' ')
          if(iright == 0)iright=len(current_argument)
          iequal=index(current_argument(:iright),'=')
          if(next_mandatory)then
          elseif(iequal /= 0.and.current_argument(1:1) == '-')then
             if(iequal /= len(current_argument))then
                right_hand_side=current_argument(iequal+1:)
             else
                right_hand_side=''
             endif
             hadequal=.true.
             current_argument=current_argument(:iequal-1)
          endif
       endif
   endif
   i=i+1
end function get_next_argument

end subroutine cmd_args_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    print_dictionary(3f) - [ARGUMENTS:M_CLI2] print internal dictionary
!!    created by calls to set_args(3f)
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine print_dictionary(header,stop)
!!
!!      character(len=*),intent(in),optional :: header
!!      logical,intent(in),optional          :: stop
!!##DESCRIPTION
!!    Print the internal dictionary created by calls to set_args(3f).
!!    This routine is intended to print the state of the argument list
!!    if an error occurs in using the set_args(3f) procedure.
!!##OPTIONS
!!     HEADER  label to print before printing the state of the command
!!             argument list.
!!     STOP    logical value that if true stops the program after displaying
!!             the dictionary.
!!##EXAMPLE
!!
!!
!!
!! Typical usage:
!!
!!       program demo_print_dictionary
!!       use M_CLI2,  only : set_args, get_args
!!       implicit none
!!       real :: x, y, z
!!          call set_args('-x 10 -y 20 -z 30')
!!          call get_args('x',x,'y',y,'z',z)
!!          ! all done cracking the command line; use the values in your program.
!!          write(*,*)x,y,z
!!       end program demo_print_dictionary
!!
!!      Sample output
!!
!!      Calling the sample program with an unknown parameter or the --usage
!!      switch produces the following:
!!
!!         $ ./demo_print_dictionary -A
!!         UNKNOWN SHORT KEYWORD: -A
!!         KEYWORD             PRESENT  VALUE
!!         z                   F        [3]
!!         y                   F        [2]
!!         x                   F        [1]
!!         help                F        [F]
!!         version             F        [F]
!!         usage               F        [F]
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine print_dictionary(header,stop)
character(len=*),intent(in),optional :: header
logical,intent(in),optional          :: stop
integer          :: i
   if(G_QUIET)return
   if(present(header))then
      if(header /= '')then
         write(warn,'(a)')header
      endif
   endif
   if(allocated(keywords))then
      if(size(keywords) > 0)then
         write(warn,'(a,1x,a,1x,a,1x,a)')atleast('KEYWORD',max(len(keywords),8)),'SHORT','PRESENT','VALUE'
         write(warn,'(*(a,1x,a5,1x,l1,8x,"[",a,"]",/))') &
         & (atleast(keywords(i),max(len(keywords),8)),shorts(i),present_in(i),values(i)(:counts(i)),i=size(keywords),1,-1)
      endif
   endif
   if(allocated(unnamed))then
      if(size(unnamed) > 0)then
         write(warn,'(a)')'UNNAMED'
         write(warn,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
      endif
   endif
   if(allocated(args))then
      if(size(args) > 0)then
         write(warn,'(a)')'ARGS'
         write(warn,'(i6.6,3a)')(i,'[',args(i),']',i=1,size(args))
      endif
   endif
   if(G_remaining /= '')then
      write(warn,'(a)')'REMAINING'
      write(warn,'(a)')G_remaining
   endif
   if(present(stop))then
      if(stop) call mystop(5)
   endif
end subroutine print_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_args(3f) - [ARGUMENTS:M_CLI2] return keyword values when parsing
!!    command line arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   get_args(3f) and its convenience functions:
!!
!!     use M_CLI2, only : get_args
!!     ! convenience functions
!!     use M_CLI2, only : dget, iget, lget, rget, sget, cget
!!     use M_CLI2, only : dgets, igets, lgets, rgets, sgets, cgets
!!
!!     subroutine get_args(name,value,delimiters)
!!
!!      character(len=*),intent(in) :: name
!!
!!      type(${TYPE}),allocatable,intent(out) :: value(:)
!!      ! or
!!      type(${TYPE}),allocatable,intent(out) :: value
!!
!!      character(len=*),intent(in),optional :: delimiters
!!
!!      where ${TYPE} may be from the set
!!              {real,doubleprecision,integer,logical,complex,character(len=:)}
!!##DESCRIPTION
!!
!!    GET_ARGS(3f) returns the value of keywords after SET_ARGS(3f) has
!!    been called to parse the command line. For fixed-length CHARACTER
!!    variables see GET_ARGS_FIXED_LENGTH(3f). For fixed-size arrays see
!!    GET_ARGS_FIXED_SIZE(3f).
!!
!!    As a convenience multiple pairs of keywords and variables may be
!!    specified if and only if all the values are scalars and the CHARACTER
!!    variables are fixed-length or pre-allocated.
!!
!!##OPTIONS
!!
!!     NAME        name of commandline argument to obtain the value of
!!     VALUE       variable to hold returned value. The kind of the value
!!                 is used to determine the type of returned value. May
!!                 be a scalar or allocatable array. If type is CHARACTER
!!                 the scalar must have an allocatable length.
!!     DELIMITERS  By default the delimiter for array values are comma,
!!                 colon, and whitespace. A string containing an alternate
!!                 list of delimiter characters may be supplied.
!!
!!##CONVENIENCE FUNCTIONS
!!    There are convenience functions that are replacements for calls to
!!    get_args(3f) for each supported default intrinsic type
!!
!!      o scalars -- dget(3f), iget(3f), lget(3f), rget(3f), sget(3f),
!!                   cget(3f)
!!      o vectors -- dgets(3f), igets(3f), lgets(3f), rgets(3f),
!!                   sgets(3f), cgets(3f)
!!
!!    D is for DOUBLEPRECISION, I for INTEGER, L for LOGICAL, R for REAL,
!!    S for string (CHARACTER), and C for COMPLEX.
!!
!!    If the functions are called with no argument they will return the
!!    UNNAMED array converted to the specified type.
!!
!!##EXAMPLE
!!
!!
!! Sample program:
!!
!!     program demo_get_args
!!     use M_CLI2,  only : filenames=>unnamed, set_args, get_args
!!     implicit none
!!     integer                      :: i
!!      ! Define ARGS
!!     real                         :: x, y, z
!!     real,allocatable             :: p(:)
!!     character(len=:),allocatable :: title
!!     logical                      :: l, lbig
!!      ! Define and parse (to set initial values) command line
!!      !   o only quote strings and use double-quotes
!!      !   o set all logical values to F or T.
!!     call set_args('         &
!!        & -x 1 -y 2 -z 3     &
!!        & -p -1,-2,-3        &
!!        & --title "my title" &
!!        & -l F -L F          &
!!        & --label " "        &
!!        & ')
!!      ! Assign values to elements
!!      ! Scalars
!!     call get_args('x',x,'y',y,'z',z,'l',l,'L',lbig)
!!      ! Allocatable string
!!     call get_args('title',title)
!!      ! Allocatable arrays
!!     call get_args('p',p)
!!      ! Use values
!!     write(*,'(1x,g0,"=",g0)')'x',x, 'y',y, 'z',z
!!     write(*,*)'p=',p
!!     write(*,*)'title=',title
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     if(size(filenames) > 0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     end program demo_get_args
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!>
!!##NAME
!!    get_args_fixed_length(3f) - [ARGUMENTS:M_CLI2] return keyword values
!!    for fixed-length string when parsing command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine get_args_fixed_length(name,value)
!!
!!     character(len=*),intent(in)  :: name
!!     character(len=:),allocatable :: value
!!     character(len=*),intent(in),optional :: delimiters
!!
!!##DESCRIPTION
!!
!!    get_args_fixed_length(3f) returns the value of a string
!!    keyword when the string value is a fixed-length CHARACTER
!!    variable.
!!
!!##OPTIONS
!!
!!    NAME   name of commandline argument to obtain the value of
!!
!!    VALUE  variable to hold returned value.
!!           Must be a fixed-length CHARACTER variable.
!!
!!    DELIMITERS  By default the delimiter for array values are comma,
!!                colon, and whitespace. A string containing an alternate
!!                list of delimiter characters may be supplied.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_get_args_fixed_length
!!     use M_CLI2,  only : set_args, get_args_fixed_length
!!     implicit none
!!
!!      ! Define args
!!     character(len=80)   :: title
!!      ! Parse command line
!!     call set_args(' --title "my title" ')
!!      ! Assign values to variables
!!     call get_args_fixed_length('title',title)
!!      ! Use values
!!     write(*,*)'title=',title
!!
!!     end program demo_get_args_fixed_length
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!>
!!##NAME
!!    get_args_fixed_size(3f) - [ARGUMENTS:M_CLI2] return keyword values
!!    for fixed-size array when parsing command line arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine get_args_fixed_size(name,value)
!!
!!     character(len=*),intent(in) :: name
!!     [real|doubleprecision|integer|logical|complex] :: value(NNN)
!!        or
!!     character(len=MMM) :: value(NNN)
!!
!!     character(len=*),intent(in),optional :: delimiters
!!
!!##DESCRIPTION
!!
!!    get_args_fixed_size(3f) returns the value of keywords for fixed-size
!!    arrays after set_args(3f) has been called. On input on the command
!!    line all values of the array must be specified.
!!
!!##OPTIONS
!!    NAME        name of commandline argument to obtain the value of
!!
!!    VALUE       variable to hold returned values. The kind of the value
!!                is used to determine the type of returned value. Must be
!!                a fixed-size array. If type is CHARACTER the length must
!!                also be fixed.
!!
!!    DELIMITERS  By default the delimiter for array values are comma,
!!                colon, and whitespace. A string containing an alternate
!!                list of delimiter characters may be supplied.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_get_args_fixed_size
!!     use M_CLI2,  only : set_args, get_args_fixed_size
!!     implicit none
!!     integer,parameter   :: dp=kind(0.0d0)
!!     ! DEFINE ARGS
!!     real                :: x(2)
!!     real(kind=dp)       :: y(2)
!!     integer             :: p(3)
!!     character(len=80)   :: title(1)
!!     logical             :: l(4), lbig(4)
!!     complex             :: cmp(2)
!!     ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!     !   o only quote strings
!!     !   o set all logical values to F or T.
!!     call set_args(' &
!!        & -x 10.0,20.0 &
!!        & -y 11.0,22.0 &
!!        & -p -1,-2,-3 &
!!        & --title "my title" &
!!        & -l F,T,F,T -L T,F,T,F  &
!!        & --cmp 111,222.0,333.0e0,4444 &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!        call get_args_fixed_size('x',x)
!!        call get_args_fixed_size('y',y)
!!        call get_args_fixed_size('p',p)
!!        call get_args_fixed_size('title',title)
!!        call get_args_fixed_size('l',l)
!!        call get_args_fixed_size('L',lbig)
!!        call get_args_fixed_size('cmp',cmp)
!!     ! USE VALUES
!!        write(*,*)'x=',x
!!        write(*,*)'p=',p
!!        write(*,*)'title=',title
!!        write(*,*)'l=',l
!!        write(*,*)'L=',lbig
!!        write(*,*)'cmp=',cmp
!!     end program demo_get_args_fixed_size
!!   Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine get_fixedarray_class(keyword,generic,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
class(*)                             :: generic(:)
character(len=*),intent(in),optional :: delimiters
   select type(generic)
    type is (character(len=*));  call get_fixedarray_fixed_length_c(keyword,generic,delimiters)
    type is (integer);           call get_fixedarray_i(keyword,generic,delimiters)
    type is (real);              call get_fixedarray_r(keyword,generic,delimiters)
    type is (complex);           call get_fixed_size_complex(keyword,generic,delimiters)
    type is (real(kind=dp));     call get_fixedarray_d(keyword,generic,delimiters)
    type is (logical);           call get_fixedarray_l(keyword,generic,delimiters)
    class default
      call mystop(-7,'*get_fixedarray_class* crud -- procedure does not know about this type')
   end select
end subroutine get_fixedarray_class
!===================================================================================================================================
! return allocatable arrays
!===================================================================================================================================
subroutine get_anyarray_l(keyword,larray,delimiters)

! ident_5="@(#) M_CLI2 get_anyarray_l(3f) given keyword fetch logical array from string in dictionary(F on err)"

character(len=*),intent(in)  :: keyword                    ! the dictionary keyword (in form VERB_KEYWORD) to retrieve
logical,allocatable          :: larray(:)                  ! convert value to an array
character(len=*),intent(in),optional   :: delimiters
character(len=:),allocatable :: carray(:)                  ! convert value to an array
character(len=:),allocatable :: val
integer                      :: i
integer                      :: place
integer                      :: iichar                     ! point to first character of word unless first character is "."
   call locate_key(keyword,place)                          ! find where string is or should be
   if(place > 0)then                                      ! if string was found
      val=values(place)(:counts(place))
      call split(adjustl(upper(val)),carray,delimiters=delimiters)  ! convert value to uppercase, trimmed; then parse into array
   else
      call journal('*get_anyarray_l* unknown keyword',keyword)
      call mystop(8 ,'*get_anyarray_l* unknown keyword '//keyword)
      if(allocated(larray))deallocate(larray)
      allocate(larray(0))
      return
   endif
   if(size(carray) > 0)then                                  ! if not a null string
      if(allocated(larray))deallocate(larray)
      allocate(larray(size(carray)))                          ! allocate output array
      do i=1,size(carray)
         larray(i)=.false.                                    ! initialize return value to .false.
         if(carray(i)(1:1) == '.')then                        ! looking for fortran logical syntax .STRING.
            iichar=2
         else
            iichar=1
         endif
         select case(carray(i)(iichar:iichar))             ! check word to see if true or false
         case('T','Y',' '); larray(i)=.true.               ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
         case('F','N');     larray(i)=.false.              ! assume this is false or no
         case default
            call journal("*get_anyarray_l* bad logical expression for ",(keyword),'=',carray(i))
         end select
      enddo
   else                                                       ! for a blank string return one T
      if(allocated(larray))deallocate(larray)
      allocate(larray(1))                                     ! allocate output array
      larray(1)=.true.
   endif
end subroutine get_anyarray_l
!===================================================================================================================================
subroutine get_anyarray_d(keyword,darray,delimiters)

! ident_6="@(#) M_CLI2 get_anyarray_d(3f) given keyword fetch dble value array from Language Dictionary (0 on err)"

character(len=*),intent(in)           :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp),allocatable,intent(out) :: darray(:)    ! function type
character(len=*),intent(in),optional  :: delimiters

character(len=:),allocatable          :: carray(:)    ! convert value to an array using split(3f)
integer                               :: i
integer                               :: place
integer                               :: ierr
character(len=:),allocatable          :: val
!-----------------------------------------------------------------------------------------------------------------------------------
   call locate_key(keyword,place)                    ! find where string is or should be
   if(place > 0)then                                 ! if string was found
      val=values(place)(:counts(place))
      val=replace_str(val,'(','')
      val=replace_str(val,')','')
      call split(val,carray,delimiters=delimiters)    ! find value associated with keyword and split it into an array
   else
      call journal('*get_anyarray_d* unknown keyword '//keyword)
      call mystop(9 ,'*get_anyarray_d* unknown keyword '//keyword)
      if(allocated(darray))deallocate(darray)
      allocate(darray(0))
      return
   endif
   if(allocated(darray))deallocate(darray)
   allocate(darray(size(carray)))                     ! create the output array
   do i=1,size(carray)
      call a2d(carray(i), darray(i),ierr) ! convert the string to a numeric value
      if(ierr /= 0)then
         call mystop(10 ,'*get_anyarray_d* unreadable value '//carray(i)//' for keyword '//keyword)
      endif
   enddo
end subroutine get_anyarray_d
!===================================================================================================================================
subroutine get_anyarray_i(keyword,iarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
integer,allocatable                  :: iarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray,delimiters)
   iarray=nint(darray)
end subroutine get_anyarray_i
!===================================================================================================================================
subroutine get_anyarray_r(keyword,rarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real,allocatable                     :: rarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray,delimiters)
   rarray=real(darray)
end subroutine get_anyarray_r
!===================================================================================================================================
subroutine get_anyarray_x(keyword,xarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
complex(kind=sp),allocatable         :: xarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: half,sz,i
   call get_anyarray_d(keyword,darray,delimiters)
   sz=size(darray)
   half=sz/2
   if(sz /= half+half)then
      call journal('*get_anyarray_x* uneven number of values defining complex value '//keyword)
      call mystop(11,'*get_anyarray_x* uneven number of values defining complex value '//keyword)
      if(allocated(xarray))deallocate(xarray)
      allocate(xarray(0))
   endif

   !x!================================================================================================
   !x!IFORT,GFORTRAN OK, NVIDIA RETURNS NULL ARRAY: xarray=cmplx(real(darray(1::2)),real(darray(2::2)))
   if(allocated(xarray))deallocate(xarray)
   allocate(xarray(half))
   do i=1,sz,2
      xarray((i+1)/2)=cmplx( darray(i),darray(i+1),kind=sp )
   enddo
   !x!================================================================================================

end subroutine get_anyarray_x
!===================================================================================================================================
subroutine get_anyarray_c(keyword,strings,delimiters)

! ident_7="@(#) M_CLI2 get_anyarray_c(3f) Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)          :: keyword       ! name to look up in dictionary
character(len=:),allocatable         :: strings(:)
character(len=*),intent(in),optional :: delimiters
integer                              :: place
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,strings,delimiters=delimiters)   ! find value associated with keyword and split it into an array
   else
      call journal('*get_anyarray_c* unknown keyword '//keyword)
      call mystop(12,'*get_anyarray_c* unknown keyword '//keyword)
      if(allocated(strings))deallocate(strings)
      allocate(character(len=0)::strings(0))
   endif
end subroutine get_anyarray_c
!===================================================================================================================================
subroutine get_args_fixed_length_a_array(keyword,strings,delimiters)

! ident_8="@(#) M_CLI2 get_args_fixed_length_a_array(3f) Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)          :: keyword       ! name to look up in dictionary
character(len=*),allocatable         :: strings(:)
character(len=*),intent(in),optional :: delimiters
character(len=:),allocatable         :: strings_a(:)
integer                              :: place
character(len=:),allocatable         :: val
integer                              :: ibug
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,strings_a,delimiters=delimiters)   ! find value associated with keyword and split it into an array
      if( len(strings_a) <= len(strings) )then
         strings=strings_a
      else
         ibug=len(strings)
         call journal('*get_args_fixed_length_a_array* values too long. Longest is',len(strings_a),'allowed is',ibug)
         write(*,'("strings=",3x,*(a,1x))')strings
         call journal('*get_args_fixed_length_a_array* keyword='//keyword)
         call mystop(13,'*get_args_fixed_length_a_array* keyword='//keyword)
         strings=[character(len=len(strings)) ::]
      endif
   else
      call journal('*get_args_fixed_length_a_array* unknown keyword '//keyword)
      call mystop(14,'*get_args_fixed_length_a_array* unknown keyword '//keyword)
      strings=[character(len=len(strings)) ::]
   endif
end subroutine get_args_fixed_length_a_array
!===================================================================================================================================
! return non-allocatable arrays
!===================================================================================================================================
subroutine get_fixedarray_i(keyword,iarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
integer                              :: iarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_d(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(iarray,dim=1) == dsize)then
      iarray=nint(darray)
   else
      ibug=size(iarray)
      call journal('*get_fixedarray_i* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(33)
      iarray=0
   endif
end subroutine get_fixedarray_i
!===================================================================================================================================
subroutine get_fixedarray_r(keyword,rarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real                                 :: rarray(:)
character(len=*),intent(in),optional :: delimiters
real,allocatable                     :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_r(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(rarray,dim=1) == dsize)then
      rarray=darray
   else
      ibug=size(rarray)
      call journal('*get_fixedarray_r* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(33)
      rarray=0.0
   endif
end subroutine get_fixedarray_r
!===================================================================================================================================
subroutine get_fixed_size_complex(keyword,xarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
complex                              :: xarray(:)
character(len=*),intent(in),optional :: delimiters
complex,allocatable                  :: darray(:)    ! function type
integer                              :: half, sz
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_x(keyword,darray,delimiters)
   dsize=size(darray)
   sz=dsize*2
   half=sz/2
   if(sz /= half+half)then
      call journal('*get_fixed_size_complex* uneven number of values defining complex value '//keyword)
      call mystop(15,'*get_fixed_size_complex* uneven number of values defining complex value '//keyword)
      xarray=0
      return
   endif
   if(ubound(xarray,dim=1) == dsize)then
      xarray=darray
   else
      ibug=size(xarray)
      call journal('*get_fixed_size_complex* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(34)
      xarray=cmplx(0.0,0.0)
   endif
end subroutine get_fixed_size_complex
!===================================================================================================================================
subroutine get_fixedarray_d(keyword,darr,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp)                        :: darr(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_d(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(darr,dim=1) == dsize)then
      darr=darray
   else
      ibug=size(darr)
      call journal('*get_fixedarray_d* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(35)
      darr=0.0d0
   endif
end subroutine get_fixedarray_d
!===================================================================================================================================
subroutine get_fixedarray_l(keyword,larray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
logical                              :: larray(:)
character(len=*),intent(in),optional :: delimiters
logical,allocatable                  :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_l(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(larray,dim=1) == dsize)then
      larray=darray
   else
      ibug=size(larray)
      call journal('*get_fixedarray_l* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(36)
      larray=.false.
   endif
end subroutine get_fixedarray_l
!===================================================================================================================================
subroutine get_fixedarray_fixed_length_c(keyword,strings,delimiters)

! ident_9="@(#) M_CLI2 get_fixedarray_fixed_length_c(3f) Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*)                     :: strings(:)
character(len=*),intent(in),optional :: delimiters
character(len=:),allocatable         :: str(:)
character(len=*),intent(in)          :: keyword   ! name to look up in dictionary
integer                              :: place
integer                              :: ssize
integer                              :: ibug
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                 ! find where string is or should be
   if(place > 0)then                              ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,str,delimiters=delimiters)   ! find value associated with keyword and split it into an array
      ssize=size(str)
      if(ssize==size(strings))then
         strings(:ssize)=str
      else
         ibug=size(strings)
         call journal('*get_fixedarray_fixed_length_c* wrong number of values for keyword',&
            & keyword,'got',ssize,'expected ',ibug) !,ubound(strings,dim=1)
         call print_dictionary_usage()
         call mystop(30,'*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
         strings=''
      endif
   else
      call journal('*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
      call mystop(16,'*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
      strings=''
   endif
end subroutine get_fixedarray_fixed_length_c
!===================================================================================================================================
! return scalars
!===================================================================================================================================
subroutine get_scalar_d(keyword,d)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp)                 :: d
real(kind=dp),allocatable     :: darray(:)    ! function type
integer                       :: ibug
   call get_anyarray_d(keyword,darray)
   if(size(darray) == 1)then
      d=darray(1)
   else
      ibug=size(darray)
      call journal('*get_anyarray_d* incorrect number of values for keyword "',keyword,'" expected one found',ibug)
      call print_dictionary_usage()
      call mystop(31,'*get_anyarray_d* incorrect number of values for keyword "'//keyword//'" expected one')
   endif
end subroutine get_scalar_d
!===================================================================================================================================
subroutine get_scalar_real(keyword,r)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
real,intent(out)              :: r
real(kind=dp)                 :: d
   call get_scalar_d(keyword,d)
   r=real(d)
end subroutine get_scalar_real
!===================================================================================================================================
subroutine get_scalar_i(keyword,i)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
integer,intent(out)           :: i
real(kind=dp)                 :: d
   call get_scalar_d(keyword,d)
   i=nint(d)
end subroutine get_scalar_i
!===================================================================================================================================
subroutine get_scalar_anylength_c(keyword,string)

! ident_10="@(#) M_CLI2 get_scalar_anylength_c(3f) Fetch string value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)   :: keyword              ! name to look up in dictionary
character(len=:),allocatable,intent(out)  :: string
integer                       :: place
   call locate_key(keyword, place)                     ! find where string is or should be
   if (place > 0) then                                  ! if index is valid return string
      string = unquote(values(place) (:counts(place)))
   else
      call journal('*get_anyarray_c* unknown keyword '//keyword)
      call mystop(17, '*get_anyarray_c* unknown keyword '//keyword)
      string = ''
   endif
end subroutine get_scalar_anylength_c
!===================================================================================================================================
elemental impure subroutine get_args_fixed_length_scalar_c(keyword,string)

! ident_11="@(#) M_CLI2 get_args_fixed_length_scalar_c(3f) Fetch string value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)   :: keyword              ! name to look up in dictionary
character(len=*),intent(out)  :: string
integer                       :: place
integer                       :: unlen
integer                       :: ibug
   call locate_key(keyword, place)                     ! find where string is or should be

   if (place > 0) then                                  ! if index is valid return string
      string = unquote(values(place) (:counts(place)))
   else
      call mystop(18, '*get_args_fixed_length_scalar_c* unknown keyword '//keyword)
      string = ''
   endif

   unlen = len_trim(unquote(values(place) (:counts(place))))
   if (unlen > len(string)) then
      ibug = len(string)
      call journal('*get_args_fixed_length_scalar_c* value too long for', keyword, 'allowed is', ibug,&
      & 'input string [', values(place), '] is', unlen)
      call mystop(19, '*get_args_fixed_length_scalar_c* value too long')
      string = ''
   endif

end subroutine get_args_fixed_length_scalar_c
!===================================================================================================================================
subroutine get_scalar_complex(keyword,x)
character(len=*),intent(in) :: keyword      ! keyword to retrieve value from dictionary
complex,intent(out)         :: x
real(kind=dp)               :: d(2)

   call get_fixedarray_d(keyword,d)
   x=cmplx(d(1),d(2),kind=sp)

end subroutine get_scalar_complex
!===================================================================================================================================
subroutine get_scalar_logical(keyword,l)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
logical                       :: l
logical,allocatable           :: larray(:)    ! function type
integer                       :: ibug

   l = .false.

   call get_anyarray_l(keyword, larray)

   if (.not. allocated(larray)) then
      call journal('*get_scalar_logical* expected one value found not allocated')
      call mystop(37, '*get_scalar_logical* incorrect number of values for keyword "'//keyword//'"')
   elseif (size(larray) == 1) then
      l = larray(1)
   else
      ibug = size(larray)
      call journal('*get_scalar_logical* expected one value found', ibug)
      call mystop(21, '*get_scalar_logical* incorrect number of values for keyword "'//keyword//'"')
   endif

end subroutine get_scalar_logical
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! THE REMAINDER SHOULD BE ROUTINES EXTRACTED FROM OTHER MODULES TO MAKE THIS MODULE STANDALONE BY POPULAR REQUEST
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!use M_strings,                     only : UPPER, LOWER, QUOTE, REPLACE_STR=>REPLACE, UNQUOTE, SPLIT, STRING_TO_VALUE
!use M_list,                        only : insert, locate, remove, replace
!use M_journal,                     only : JOURNAL

!use M_args,                        only : LONGEST_COMMAND_ARGUMENT
! routines extracted from other modules
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_command_argument(3f) - [ARGUMENTS:M_args] length of longest
!!    argument on command line
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function longest_command_argument() result(ilongest)
!!
!!     integer :: ilongest
!!
!!##DESCRIPTION
!!    length of longest argument on command line. Useful when allocating
!!    storage for holding arguments.
!!##RESULT
!!    longest_command_argument  length of longest command argument
!!##EXAMPLE
!!
!! Sample program
!!
!!      program demo_longest_command_argument
!!      use M_args, only : longest_command_argument
!!         write(*,*)'longest argument is ',longest_command_argument()
!!      end program demo_longest_command_argument
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function longest_command_argument() result(ilongest)
integer :: i
integer :: ilength
integer :: istatus
integer :: ilongest

   ilength = 0
   ilongest = 0

   GET_LONGEST: do i = 1, command_argument_count()                          ! loop throughout command line arguments to find longest

      call get_command_argument(number=i, length=ilength, status=istatus)   ! get next argument

      if (istatus /= 0) then                                                ! on error
         write (warn, *) '*prototype_and_cmd_args_to_nlist* error obtaining length for argument ', i
         exit GET_LONGEST
      elseif (ilength > 0) then
         ilongest = max(ilongest, ilength)
      endif

   end do GET_LONGEST

end function longest_command_argument
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    journal(3f) - [M_CLI2] converts a list of standard scalar types to a string and writes message
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine journal(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,line)
!!
!!     class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     character(len=*),intent(in),optional :: sep
!!     character(len=:),intent(out),allocatable,optional :: line
!!
!!##DESCRIPTION
!!    journal(3f) builds and prints a space-separated string from up to twenty scalar values.
!!
!!##OPTIONS
!!    g[0-9a-j]   optional value to print the value of after the message. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!
!!    sep         separator to place between values. Defaults to a space.
!!    line        if present, the output is placed in the variable instead of
!!                being written
!!##RETURNS
!!    journal     description to print
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_journal
!!     use M_CLI2, only : journal
!!     implicit none
!!     character(len=:),allocatable :: frmt
!!     integer                      :: biggest
!!
!!     call journal('HUGE(3f) integers',huge(0),'and real',&
!!               & huge(0.0),'and double',huge(0.0d0))
!!     call journal('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
!!     call journal('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!     call journal('complex         :',cmplx(huge(0.0),tiny(0.0)) )
!!
!!     end program demo_journal
!!
!!  Output
!!
!!     HUGE(3f) integers 2147483647 and real 3.40282347E+38 and
!!     double 1.7976931348623157E+308
!!     real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!     doubleprecision : 1.7976931348623157E+308 0.0000000000000000
!!     12345.678900000001 2.2250738585072014E-308
!!     complex         : (3.40282347E+38,1.17549435E-38)
!!      format=(*(i9:,1x))
!!      program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine journal(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep,line)

! ident_12="@(#) M_CLI2 journal(3fp) writes a message to stdout or a string composed of any standard scalar types"

class(*),intent(in),optional         :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
character(len=*),intent(in),optional :: sep
character(len=:),intent(out),allocatable,optional :: line
character(len=:),allocatable         :: sep_local
character(len=4096)                  :: local_line
integer                              :: istart
integer                              :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep_local)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   local_line=''
   if(present(g0))call print_generic(g0)
   if(present(g1))call print_generic(g1)
   if(present(g2))call print_generic(g2)
   if(present(g3))call print_generic(g3)
   if(present(g4))call print_generic(g4)
   if(present(g5))call print_generic(g5)
   if(present(g6))call print_generic(g6)
   if(present(g7))call print_generic(g7)
   if(present(g8))call print_generic(g8)
   if(present(g9))call print_generic(g9)
   if(present(ga))call print_generic(ga)
   if(present(gb))call print_generic(gb)
   if(present(gc))call print_generic(gc)
   if(present(gd))call print_generic(gd)
   if(present(ge))call print_generic(ge)
   if(present(gf))call print_generic(gf)
   if(present(gg))call print_generic(gg)
   if(present(gh))call print_generic(gh)
   if(present(gi))call print_generic(gi)
   if(present(gj))call print_generic(gj)
   if(present(line))then
      line=trim(local_line)
   else
      write(*,'(a)')trim(local_line)
   endif
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(local_line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(local_line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(local_line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(local_line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(local_line(istart:),'(1pg0)') generic
      type is (real(kind=real64))
         write(local_line(istart:),'(1pg0)') generic
      !x! DOES NOT WORK WITH NVFORTRAN: type is (real(kind=real128));     write(local_line(istart:),'(1pg0)') generic
      type is (logical)
         write(local_line(istart:),'(l1)') generic
      type is (character(len=*))
         write(local_line(istart:),'(a)') trim(generic)
      type is (complex);                write(local_line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(local_line)+increment
   local_line=trim(local_line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end subroutine journal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep) result(line)

! ident_13="@(#) M_CLI2 str(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional         :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
character(len=*),intent(in),optional :: sep
character(len=:),allocatable         :: line
call journal(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep,line)

end function str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function upper(str) result (string)

! ident_14="@(#) M_CLI2 upper(3f) Changes a string to uppercase"

character(*), intent(in)      :: str
character(:),allocatable      :: string
integer                       :: i
   string = str
   do i = 1, len_trim(str)
       select case (str(i:i))
       case ('a':'z')
          string(i:i) = char(iachar(str(i:i))-32)
       end select
   end do
end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lower(str) result (string)

! ident_15="@(#) M_CLI2 lower(3f) Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(:),allocatable     :: string
integer                      :: i
   string = str
   do i = 1, len_trim(str)
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)
      end select
   end do
end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine a2i(chars,valu,ierr)

! ident_16="@(#) M_CLI2 a2i(3fp) subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
integer,parameter           :: ihuge=huge(0)

   valu8 = 0.0d0
   call a2d(chars, valu8, ierr, onerr=0.0d0)

   if (valu8 <= huge(valu)) then

      if (valu8 <= huge(valu)) then
         valu = int(valu8)
      else
         call journal('*a2i*', '- value too large', valu8, '>', ihuge)
         valu = huge(valu)
         ierr = -1
      endif

   endif

end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_17="@(#) M_CLI2 a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   local_chars=replace_str(local_chars,',','')                  ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         write(frmt,"('(Z',i0,')')")len(local_chars)
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         write(frmt,"('(B',i0,')')")len(local_chars)
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         write(frmt,"('(O',i0,')')")len(local_chars)
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(f3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         call journal('*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg /= '')then
            call journal('*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_CLI2:TOKENS] parse string into an array using specified
!!    delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!##DESCRIPTION
!!    SPLIT(3f) parses a string using specified delimiter characters and
!!    store tokens into an allocatable array
!!
!!##OPTIONS
!!
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!
!!    NULLS IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_split
!!     use M_CLI2, only: split
!!     character(len=*),parameter     :: &
!!     & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!     character(len=:),allocatable :: array(:) ! output array of tokens
!!        write(*,*)'INPUT LINE:['//LINE//']'
!!        write(*,'(80("="))')
!!        write(*,*)'typical call:'
!!        CALL split(line,array)
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)'custom list of delimiters (colon and vertical line):'
!!        CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)&
!!      &'custom list of delimiters, reverse array order and count null fields:'
!!        CALL split(line,array,delimiters=':|',order='reverse',nulls='return')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)'INPUT LINE:['//LINE//']'
!!        write(*,*)&
!!        &'default delimiters and reverse array order and return null fields:'
!!        CALL split(line,array,delimiters='',order='reverse',nulls='return')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!     end program demo_split
!!
!!   Output
!!
!!    > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!    > ===========================================================================
!!    >  typical call:
!!    > 1 ==> aBcdef
!!    > 2 ==> ghijklmnop
!!    > 3 ==> qrstuvwxyz
!!    > 4 ==> 1:|:2
!!    > 5 ==> 333|333
!!    > 6 ==> a
!!    > 7 ==> B
!!    > 8 ==> cc
!!    >  SIZE:           8
!!    > --------------------------------------------------------------------------
!!    >  custom list of delimiters (colon and vertical line):
!!    > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!    > 2 ==> 2     333
!!    > 3 ==> 333 a B cc
!!    >  SIZE:           3
!!    > --------------------------------------------------------------------------
!!    >  custom list of delimiters, reverse array order and return null fields:
!!    > 1 ==> 333 a B cc
!!    > 2 ==> 2     333
!!    > 3 ==>
!!    > 4 ==>
!!    > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!    >  SIZE:           5
!!    > --------------------------------------------------------------------------
!!    >  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!    >  default delimiters and reverse array order and count null fields:
!!    > 1 ==>
!!    > 2 ==>
!!    > 3 ==>
!!    > 4 ==> cc
!!    > 5 ==> B
!!    > 6 ==> a
!!    > 7 ==> 333|333
!!    > 8 ==>
!!    > 9 ==>
!!    > 10 ==>
!!    > 11 ==>
!!    > 12 ==> 1:|:2
!!    > 13 ==>
!!    > 14 ==> qrstuvwxyz
!!    > 15 ==> ghijklmnop
!!    > 16 ==>
!!    > 17 ==>
!!    > 18 ==> aBcdef
!!    > 19 ==>
!!    > 20 ==>
!!    >  SIZE:          20
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine split(input_line,array,delimiters,order,nulls)

! ident_18="@(#) M_CLI2 split(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
intrinsic index, min, present, len
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: iilen                  ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)//',:' ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)//',:'    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ???
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   if(allocated(iterm))deallocate(iterm)      !x! intel compiler says allocated already ???
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   iilen=len(input_line)                                          ! IILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
   if(iilen > 0)then                                              ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,iilen,1                                  ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iterm(i30)=iilen                                      ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):iilen),dlim(i10:i10))
               IF(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > iilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (clipends(nlls))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   if(allocated(array))deallocate(array)
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                      ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (clipends(ordr))                                   ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20) < ibegin(i20))then
         select case (clipends(nlls))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace_str(3f) - [M_CLI2:EDITING] function globally replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function replace_str(targetline,old,new,range,ierr) result (newline)
!!
!!     character(len=*)               :: targetline
!!     character(len=*),intent(in)    :: old
!!     character(len=*),intent(in)    :: new
!!     integer,intent(in),optional    :: range(2)
!!     integer,intent(out),optional   :: ierr
!!     logical,intent(in),optional    :: clip
!!     character(len=:),allocatable   :: newline
!!##DESCRIPTION
!!    Globally replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     range       if present, only change range(1) to range(2) of
!!                 occurrences of old string
!!     ierr        error code. If ier = -1 bad directive, >= 0 then
!!                 count of changes made
!!     clip        whether to return trailing spaces or not. Defaults to .false.
!!##RETURNS
!!     newline     allocatable string returned
!!
!!##EXAMPLES
!!
!! Sample Program:
!!
!!       program demo_replace_str
!!       use M_CLI2, only : replace_str
!!       implicit none
!!       character(len=:),allocatable :: targetline
!!
!!       targetline='this is the input string'
!!
!!       call testit('th','TH','THis is THe input string')
!!
!!       ! a null old substring means "at beginning of line"
!!       call testit('','BEFORE:', 'BEFORE:THis is THe input string')
!!
!!       ! a null new string deletes occurrences of the old substring
!!       call testit('i','', 'BEFORE:THs s THe nput strng')
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','A')
!!       write(*,*)'replace a with A ['//targetline//']'
!!
!!       write(*,*)'Examples of the use of RANGE='
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','A',range=[3,5])
!!       write(*,*)'replace a with A instances 3 to 5 ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','',range=[3,5])
!!       write(*,*)'replace a with null instances 3 to 5 ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!        & 'aa','CCCC',range=[3,5])
!!       write(*,*)'replace aa with CCCC instances 3 to 5 ['//targetline//']'
!!
!!       contains
!!       subroutine testit(old,new,expected)
!!       character(len=*),intent(in) :: old,new,expected
!!       write(*,*)repeat('=',79)
!!       write(*,*)':STARTED ['//targetline//']'
!!       write(*,*)':OLD['//old//']', ' NEW['//new//']'
!!       targetline=replace_str(targetline,old,new)
!!       write(*,*)':GOT     ['//targetline//']'
!!       write(*,*)':EXPECTED['//expected//']'
!!       write(*,*)':TEST    [',targetline == expected,']'
!!       end subroutine testit
!!
!!       end program demo_replace_str
!!
!!   Expected output
!!
!!     ===============================================================================
!!     STARTED [this is the input string]
!!     OLD[th] NEW[TH]
!!     GOT     [THis is THe input string]
!!     EXPECTED[THis is THe input string]
!!     TEST    [ T ]
!!     ===============================================================================
!!     STARTED [THis is THe input string]
!!     OLD[] NEW[BEFORE:]
!!     GOT     [BEFORE:THis is THe input string]
!!     EXPECTED[BEFORE:THis is THe input string]
!!     TEST    [ T ]
!!     ===============================================================================
!!     STARTED [BEFORE:THis is THe input string]
!!     OLD[i] NEW[]
!!     GOT     [BEFORE:THs s THe nput strng]
!!     EXPECTED[BEFORE:THs s THe nput strng]
!!     TEST    [ T ]
!!     replace a with A [A b Ab bAAA AAAA]
!!     Examples of the use of RANGE=
!!     replace a with A instances 3 to 5 [a b ab bAAA aaaa]
!!     replace a with null instances 3 to 5 [a b ab b aaaa]
!!     replace aa with CCCC instances 3 to 5 [a b ab baaa aaCCCC CCCC CCCC
!!     a a a aa aaaaaa]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function replace_str(targetline,old,new,ierr,range) result (newline)

! ident_19="@(#) M_CLI2 replace_str(3f) Globally replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in)            :: old          ! old substring to replace
character(len=*),intent(in)            :: new          ! new substring
integer,intent(out),optional           :: ierr         ! error code. If ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional            :: range(2)     ! start and end of which changes to make
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
integer  :: icount,ichange
integer  :: original_input_length
integer  :: len_old, len_new
integer  :: ladd
integer  :: left_margin, right_margin
integer  :: ind
integer  :: ic
integer  :: iichar
integer  :: range_local(2)
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(range))then
      range_local=range
   else
      range_local=[1,original_input_length]
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      iichar=len_new + original_input_length
      if(len_new > 0)then
         newline=new(:len_new)//targetline(left_margin:original_input_length)
      else
         newline=targetline(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   iichar=left_margin                                  ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1 ! try finding start of OLD in remaining part of input in change window
      if(ind == ic-1.or.ind > right_margin)then           ! did not find old string or found old string past edit window
         exit loop                                        ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind > ic)then                                 ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:iichar-1)//targetline(ic:ind-1)
         iichar=iichar+ladd
      endif
      if(icount >= range_local(1).and.icount <= range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new /= 0)then                                          ! put in new string
            newline=newline(:iichar-1)//new(:len_new)
            iichar=iichar+len_new
         endif
      else
         if(len_old /= 0)then                                          ! put in copy of old string
            newline=newline(:iichar-1)//old(:len_old)
            iichar=iichar+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline                               ! if no changes made output should be input
   case default
      if(ic <= len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:iichar-1)//targetline(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    quote(3f) - [M_CLI2:QUOTES] add quotes to string as if written with
!!    list-directed input
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed input. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str         input string to add quotes to, using the rules of
!!                list-directed input (single quotes are replaced by two
!!                adjacent quotes)
!!    mode        alternate quoting methods are supported:
!!
!!                   DOUBLE   default. replace quote with double quotes
!!                   ESCAPE   replace quotes with backslash-quote instead
!!                            of double quotes
!!
!!    clip        default is to trim leading and trailing spaces from the
!!                string. If CLIP
!!                is .FALSE. spaces are not trimmed
!!
!!##RESULT
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_quote
!!     use M_CLI2, only : quote
!!     implicit none
!!     character(len=:),allocatable :: str
!!     character(len=1024)          :: msg
!!     integer                      :: ios
!!     character(len=80)            :: inline
!!        do
!!           write(*,'(a)',advance='no')'Enter test string:'
!!           read(*,'(a)',iostat=ios,iomsg=msg)inline
!!           if(ios /= 0)then
!!              write(*,*)trim(inline)
!!              exit
!!           endif
!!
!!           ! the original string
!!           write(*,'(a)')'ORIGINAL     ['//trim(inline)//']'
!!
!!           ! the string processed by quote(3f)
!!           str=quote(inline)
!!           write(*,'(a)')'QUOTED     ['//str//']'
!!
!!           ! write the string list-directed to compare the results
!!           write(*,'(a)',iostat=ios,iomsg=msg) 'LIST DIRECTED:'
!!           write(*,*,iostat=ios,iomsg=msg,delim='none') inline
!!           write(*,*,iostat=ios,iomsg=msg,delim='quote') inline
!!           write(*,*,iostat=ios,iomsg=msg,delim='apostrophe') inline
!!        enddo
!!     end program demo_quote
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
logical                              :: clip_local
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode

   if(present(mode))then
      local_mode=mode
   else
      local_mode='DOUBLE'
   endif

   if(present(clip))then
      clip_local=clip
   else
      clip_local=.false.
   endif

   if(clip_local)then
      quoted_str=adjustl(str)
   else
      quoted_str=str
   endif

   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace_str(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace_str(quoted_str,'"','\"'))//double_quote
   case default
      call journal('*quote* ERROR: unknown quote mode ',local_mode)
      quoted_str=str
   end select

end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    unquote(3f) - [M_CLI2:QUOTES] remove quotes from string as if read
!!    with list-directed input
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   pure function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!##RESULT
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!##EXAMPLE
!!
!! Sample program:
!!
!!       program demo_unquote
!!       use M_CLI2, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: msg
!!       integer                      :: ios
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=ios,iomsg=msg)quoted_str
!!          if(ios /= 0)then
!!             write(*,*)trim(msg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=ios,iomsg=msg)dummy
!!          if(ios /= 0)then
!!             write(*,*)trim(msg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!       end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
pure function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=ichar(esc)                             ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   if(allocated(unquoted_str))deallocate(unquoted_str)
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen >= 1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1) == single_quote)then
         quote=ichar(single_quote)
      else
         quote=ichar(double_quote)
      endif
   else
      quote=ichar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=ichar(quoted_str(i:i))
      if(before == iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current == quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_CLI2:BASE] convert whole number string in base
!!                     [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!      program demo_decodebase
!!      use M_CLI2, only : codebase, decodebase
!!      implicit none
!!      integer           :: ba,bd
!!      character(len=40) :: x,y
!!      integer           :: r
!!
!!      print *,' BASE CONVERSION'
!!      write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!      write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!      INFINITE: do
!!         print *,''
!!         write(*,'("Enter number in start base: ")',advance='no'); read *, x
!!         if(x == '0') exit INFINITE
!!         if(decodebase(x,bd,r)) then
!!            if(codebase(r,ba,y)) then
!!              write(*,'("In base ",I2,": ",A20)')  ba, y
!!            else
!!              print *,'Error in coding number.'
!!            endif
!!         else
!!            print *,'Error in decoding number.'
!!         endif
!!      enddo INFINITE
!!
!!      end program demo_decodebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function decodebase(string,basein,out_baseten)

! ident_20="@(#) M_CLI2 decodebase(3f) convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(clipends(string))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                  ! split string into two values
     call a2i(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        IF(CH == '-'.AND.K == 1)THEN
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    locate_(3f) - [M_CLI2] finds the index where a string is found or
!!                  should be in a sorted array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine locate_(list,value,place,ier,errmsg)
!!
!!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:)
!!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value
!!    integer, intent(out)                  :: PLACE
!!
!!    integer, intent(out),optional         :: IER
!!    character(len=*),intent(out),optional :: ERRMSG
!!
!!##DESCRIPTION
!!
!!    LOCATE_(3f) finds the index where the VALUE is found or should
!!    be found in an array. The array must be sorted in descending
!!    order (highest at top). If VALUE is not found it returns the index
!!    where the name should be placed at with a negative sign.
!!
!!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL,INTEGER)
!!
!!##OPTIONS
!!
!!    VALUE         the value to locate in the list.
!!    LIST          is the list array.
!!
!!##RETURNS
!!    PLACE         is the subscript that the entry was found at if it is
!!                  greater than zero(0).
!!
!!                  If PLACE is negative, the absolute value of
!!                  PLACE indicates the subscript value where the
!!                  new entry should be placed in order to keep the
!!                  list alphabetized.
!!
!!    IER           is zero(0) if no error occurs.
!!                  If an error occurs and IER is not
!!                  present, the program is stopped.
!!
!!    ERRMSG        description of any error
!!
!!##EXAMPLES
!!
!!
!! Find if a string is in a sorted array, and insert the string into
!! the list if it is not present ...
!!
!!     program demo_locate
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate_
!!     implicit none
!!     character(len=:),allocatable  :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     call update_dic(arr,'b')
!!     call update_dic(arr,'[')
!!     call update_dic(arr,'c')
!!     call update_dic(arr,'ZZ')
!!     call update_dic(arr,'ZZZZ')
!!     call update_dic(arr,'z')
!!
!!     contains
!!     subroutine update_dic(arr,string)
!!     character(len=:),intent(in),allocatable :: arr(:)
!!     character(len=*),intent(in)  :: string
!!     integer                      :: place, plus, ii, end
!!     ! find where string is or should be
!!     call locate_(arr,string,place)
!!     write(*,*)'for "'//string//'" index is ',place, size(arr)
!!     ! if string was not found insert it
!!     if(place < 1)then
!!        plus=abs(place)
!!        ii=len(arr)
!!        end=size(arr)
!!        ! empty array
!!        if(end == 0)then
!!           arr=[character(len=ii) :: string ]
!!        ! put in front of array
!!        elseif(plus == 1)then
!!           arr=[character(len=ii) :: string, arr]
!!        ! put at end of array
!!        elseif(plus == end)then
!!           arr=[character(len=ii) :: arr, string ]
!!        ! put in middle of array
!!        else
!!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ]
!!        endif
!!        ! show array
!!        write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     endif
!!     end subroutine update_dic
!!     end program demo_locate
!!
!!   Results:
!!
!!     for "b" index is            2           5
!!     for "[" index is           -4           5
!!    SIZE=5 xxx,b,aaa,[,ZZZ,
!!     for "c" index is           -2           6
!!    SIZE=6 xxx,c,b,aaa,[,ZZZ,
!!     for "ZZ" index is           -7           7
!!    SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     for "ZZZZ" index is           -6           8
!!    SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!     for "z" index is           -1           9
!!    SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine locate_c(list,value,place,ier,errmsg)

! ident_21="@(#) M_CLI2 locate_c(3f) find PLACE in sorted character array LIST where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)

   error=0
   if(arraysize == 0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value == list(PLACE))then
         exit LOOP
      elseif(value > list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin > imax)then
         place=-imin
         if(iabs(place) > arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place > arraysize.or.place <= 0)then
         message='*locate_* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate_* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   elseif(error /= 0)then
      write(warn,*)message//' VALUE=',trim(value)//' PLACE=',place
      call mystop(-24,'(*locate_c* '//message)
   endif
   if(present(errmsg))then
      errmsg=message
   endif
end subroutine locate_c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    remove_(3f) - [M_CLI2] remove entry from an allocatable array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine remove_(list,place)
!!
!!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)
!!    integer, intent(out) :: PLACE
!!
!!##DESCRIPTION
!!
!!    Remove a value from an allocatable array at the specified index.
!!    The array is assumed to be sorted in descending order. It may be of
!!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!
!!##OPTIONS
!!
!!    list    is the list array.
!!    PLACE   is the subscript for the entry that should be removed
!!
!!##EXAMPLES
!!
!!
!! Sample program
!!
!!     program demo_remove
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate_, remove_
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!     integer                       :: end
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'Z', 'aaa', 'b', 'b', 'ab', 'bb', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove_(arr,1)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove_(arr,4)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end program demo_remove
!!
!!   Results:
!!
!!    Expected output
!!
!!     SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=7 bb,b,b,aaa,ZZZ,Z,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine remove_c(list,place)

! ident_22="@(#) M_CLI2 remove_c(3fp) remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place <= 0.or.place > end)then                       ! index out of bounds of array
   elseif(place == end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
end subroutine remove_c
subroutine remove_l(list,place)

! ident_23="@(#) M_CLI2 remove_l(3fp) remove value from allocatable array at specified position"

logical,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(place <= 0.or.place > end)then                       ! index out of bounds of array
   elseif(place == end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_l
subroutine remove_i(list,place)

! ident_24="@(#) M_CLI2 remove_i(3fp) remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place <= 0.or.place > end)then                       ! index out of bounds of array
   elseif(place == end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    replace_(3f) - [M_CLI2] replace entry in a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine replace_(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer, intent(out) :: place
!!
!!##DESCRIPTION
!!
!!    replace a value in an allocatable array at the specified index. Unless the
!!    array needs the string length to increase this is merely an assign of a value
!!    to an array element.
!!
!!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER>
!!    It is assumed to be sorted in descending order without duplicate values.
!!
!!    The value and list must be of the same type.
!!
!!##OPTIONS
!!
!!    VALUE         the value to place in the array
!!    LIST          is the array.
!!    PLACE         is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!! Replace key-value pairs in a dictionary
!!
!!     program demo_replace
!!     use M_CLI2, only  : insert_, locate_, replace_
!!     ! Find if a key is in a list and insert it
!!     ! into the key list and value list if it is not present
!!     ! or replace the associated value if the key existed
!!     implicit none
!!     character(len=20)            :: key
!!     character(len=100)           :: val
!!     character(len=:),allocatable :: keywords(:)
!!     character(len=:),allocatable :: values(:)
!!     integer                      :: i
!!     integer                      :: place
!!     call update_dic('b','value of b')
!!     call update_dic('a','value of a')
!!     call update_dic('c','value of c')
!!     call update_dic('c','value of c again')
!!     call update_dic('d','value of d')
!!     call update_dic('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>",a,/))')(trim(keywords(i)),trim(values(i)),i=1,size(keywords))
!!
!!     call locate_key('a',place)
!!     if(place > 0)then
!!        write(*,*)'The value of "a" is',trim(values(place))
!!     else
!!        write(*,*)'"a" not found'
!!     endif
!!
!!     contains
!!     subroutine update_dic(key,val)
!!     character(len=*),intent(in)  :: key
!!     character(len=*),intent(in)  :: val
!!     integer                      :: place
!!
!!     ! find where string is or should be
!!     call locate_key(key,place)
!!     ! if string was not found insert it
!!     if(place < 1)then
!!        call insert_(keywords,key,abs(place))
!!        call insert_(values,val,abs(place))
!!     else ! replace
!!        call replace_(values,val,place)
!!     endif
!!
!!     end subroutine update_dic
!!    end program demo_replace
!!
!!   Expected output
!!
!!    d==>value of d
!!    c==>value of c again
!!    b==>value of b
!!    a==>value of a again
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine replace_c(list,value,place)

! ident_25="@(#) M_CLI2 replace_c(3fp) replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len_trim(value)
   end=size(list)
   if(place < 0.or.place > end)then
           write(warn,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len_trim(value) <= len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
end subroutine replace_c
subroutine replace_l(list,value,place)

! ident_26="@(#) M_CLI2 replace_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place > 0.and.place <= end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(warn,*)'*replace_l* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_l
subroutine replace_i(list,value,place)

! ident_27="@(#) M_CLI2 replace_i(3fp) place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place > 0.and.place <= end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(warn,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    insert_(3f) - [M_CLI2] insert entry into a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine insert_(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer,intent(in)    :: place
!!
!!##DESCRIPTION
!!
!!    Insert a value into an allocatable array at the specified index.
!!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL, or INTEGER)
!!
!!##OPTIONS
!!
!!    list    is the list array. Must be sorted in descending order.
!!    value   the value to place in the array
!!    PLACE   is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!! Find if a string is in a sorted array, and insert the string into
!! the list if it is not present ...
!!
!!     program demo_insert
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate_, insert_
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!     ! add or replace values
!!     call update_dic(arr,'b')
!!     call update_dic(arr,'[')
!!     call update_dic(arr,'c')
!!     call update_dic(arr,'ZZ')
!!     call update_dic(arr,'ZZZ')
!!     call update_dic(arr,'ZZZZ')
!!     call update_dic(arr,'')
!!     call update_dic(arr,'z')
!!
!!     contains
!!     subroutine update_dic(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, end
!!
!!     end=size(arr)
!!     ! find where string is or should be
!!     call locate_(arr,string,place)
!!     ! if string was not found insert it
!!     if(place < 1)then
!!        call insert_(arr,string,abs(place))
!!     endif
!!     ! show array
!!     end=size(arr)
!!     write(*,'("array is now SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end subroutine update_dic
!!     end program demo_insert
!!
!!   Results:
!!
!!     array is now SIZE=5 xxx,b,aaa,ZZZ,,
!!     array is now SIZE=6 xxx,b,aaa,[,ZZZ,,
!!     array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,
!!     array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!     array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine insert_c(list,value,place)

! ident_28="@(#) M_CLI2 insert_c(3fp) place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end

   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif

   ii=max(len_trim(value),len(list),2)
   end=size(list)

   if(end == 0)then                                        ! empty array
      list=[character(len=ii) :: value ]
   elseif(place == 1)then                                  ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place > end)then                                 ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place >= 2.and.place <= end)then                 ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(warn,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_c
subroutine insert_l(list,value,place)

! ident_29="@(#) M_CLI2 insert_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place == 1)then                                    ! put in front of array
      list=[value, list]
   elseif(place > end)then                                   ! put at end of array
      list=[list, value ]
   elseif(place >= 2.and.place <= end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(warn,*)'*insert_l* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_l
subroutine insert_i(list,value,place)

! ident_30="@(#) M_CLI2 insert_i(3fp) place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place == 1)then                                    ! put in front of array
      list=[value, list]
   elseif(place > end)then                                   ! put at end of array
      list=[list, value ]
   elseif(place >= 2.and.place <= end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(warn,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine many_args(n0,g0, n1,g1, n2,g2, n3,g3, n4,g4, n5,g5, n6,g6, n7,g7, n8,g8, n9,g9, &
                   & na,ga, nb,gb, nc,gc, nd,gd, ne,ge, nf,gf, ng,gg, nh,gh, ni,gi, nj,gj )

! ident_31="@(#) M_CLI2 many_args(3fp) allow for multiple calls to get_args(3f)"

character(len=*),intent(in)          :: n0, n1
character(len=*),intent(in),optional :: n2, n3, n4, n5, n6, n7, n8, n9, na, nb, nc, nd, ne, nf, ng, nh, ni, nj
class(*),intent(out)           :: g0, g1
class(*),intent(out),optional  :: g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
   call get_generic(n0,g0)
   call get_generic(n1,g1)
   if( present(n2) .and. present(g2) )call get_generic(n2,g2)
   if( present(n3) .and. present(g3) )call get_generic(n3,g3)
   if( present(n4) .and. present(g4) )call get_generic(n4,g4)
   if( present(n5) .and. present(g5) )call get_generic(n5,g5)
   if( present(n6) .and. present(g6) )call get_generic(n6,g6)
   if( present(n7) .and. present(g7) )call get_generic(n7,g7)
   if( present(n8) .and. present(g8) )call get_generic(n8,g8)
   if( present(n9) .and. present(g9) )call get_generic(n9,g9)
   if( present(na) .and. present(ga) )call get_generic(na,ga)
   if( present(nb) .and. present(gb) )call get_generic(nb,gb)
   if( present(nc) .and. present(gc) )call get_generic(nc,gc)
   if( present(nd) .and. present(gd) )call get_generic(nd,gd)
   if( present(ne) .and. present(ge) )call get_generic(ne,ge)
   if( present(nf) .and. present(gf) )call get_generic(nf,gf)
   if( present(ng) .and. present(gg) )call get_generic(ng,gg)
   if( present(nh) .and. present(gh) )call get_generic(nh,gh)
   if( present(ni) .and. present(gi) )call get_generic(ni,gi)
   if( present(nj) .and. present(gj) )call get_generic(nj,gj)
contains
!===================================================================================================================================
function c(generic)
class(*),intent(in) :: generic
character(len=:),allocatable :: c
   select type(generic)
      type is (character(len=*)); c=trim(generic)
      class default
         c='unknown'
         stop 'get_many:: parameter name is not character'
   end select
end function c
!===================================================================================================================================
subroutine get_generic(name,generic)
use,intrinsic :: iso_fortran_env, only : real64
character(len=*),intent(in)  :: name
class(*),intent(out)         :: generic
   select type(generic)
      type is (integer);                        call get_args(name,generic)
      type is (real);                           call get_args(name,generic)
      type is (real(kind=real64));              call get_args(name,generic)
      type is (logical);                        call get_args(name,generic)
      !x!type is (character(len=:),allocatable ::);   call get_args(name,generic)
      type is (character(len=*));
      call get_args_fixed_length(name,generic)
      type is (complex);                        call get_args(name,generic)
      class default
         stop 'unknown type in *get_generic*'
   end select
end subroutine get_generic
!===================================================================================================================================
end subroutine many_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function iget(n); integer                      :: iget; character(len=*),intent(in) :: n; call get_args(n,iget); end function iget
function rget(n); real                         :: rget; character(len=*),intent(in) :: n; call get_args(n,rget); end function rget
function dget(n); real(kind=dp)                :: dget; character(len=*),intent(in) :: n; call get_args(n,dget); end function dget
function sget(n); character(len=:),allocatable :: sget; character(len=*),intent(in) :: n; call get_args(n,sget); end function sget
function cget(n); complex                      :: cget; character(len=*),intent(in) :: n; call get_args(n,cget); end function cget
function lget(n); logical                      :: lget; character(len=*),intent(in) :: n; call get_args(n,lget); end function lget

function igs(n); integer,allocatable          :: igs(:); character(len=*),intent(in) :: n; call get_args(n,igs); end function igs
function rgs(n); real,allocatable             :: rgs(:); character(len=*),intent(in) :: n; call get_args(n,rgs); end function rgs
function dgs(n); real(kind=dp),allocatable    :: dgs(:); character(len=*),intent(in) :: n; call get_args(n,dgs); end function dgs
function sgs(n,delims)
character(len=:),allocatable         :: sgs(:)
character(len=*),optional,intent(in) :: delims
character(len=*),intent(in)          :: n
   call get_args(n,sgs,delims)
end function sgs
function cgs(n); complex,allocatable          :: cgs(:); character(len=*),intent(in) :: n; call get_args(n,cgs); end function cgs
function lgs(n); logical,allocatable          :: lgs(:); character(len=*),intent(in) :: n; call get_args(n,lgs); end function lgs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function ig()
integer,allocatable :: ig(:)
integer             :: i, ierr
   if(allocated(ig))deallocate(ig)
   allocate(ig(size(unnamed)))
   do i=1,size(ig)
      call a2i(unnamed(i),ig(i),ierr)
   enddo
end function ig
!===================================================================================================================================
function rg()
real,allocatable :: rg(:)
   rg=real(dg())
end function rg
!===================================================================================================================================
function dg()
real(kind=dp),allocatable :: dg(:)
integer                   :: i
integer                   :: ierr
   if(allocated(dg))deallocate(dg)
   allocate(dg(size(unnamed)))
   do i=1,size(dg)
      call a2d(unnamed(i),dg(i),ierr)
   enddo
end function dg
!===================================================================================================================================
function lg()
logical,allocatable   :: lg(:)
integer               :: i
integer               :: iichar
character,allocatable :: hold
   if(allocated(lg))deallocate(lg)
   allocate(lg(size(unnamed)))
   do i=1,size(lg)
      hold=upper(clipends(unnamed(i)))
      if(hold(1:1) == '.')then                 ! looking for fortran logical syntax .STRING.
         iichar=2
      else
         iichar=1
      endif
      select case(hold(iichar:iichar))         ! check word to see if true or false
      case('T','Y',' '); lg(i)=.true.          ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
      case('F','N');     lg(i)=.false.         ! assume this is false or no
      case default
         call journal("*lg* bad logical expression for element",i,'=',hold)
      end select
   enddo
end function lg
!===================================================================================================================================
function cg()
complex,allocatable :: cg(:)
integer             :: i, ierr
real(kind=dp)       :: rc, ic
   if(allocated(cg))deallocate(cg)
   allocate(cg(size(unnamed)))
   do i=1,size(cg),2
      call a2d(unnamed(i),rc,ierr)
      call a2d(unnamed(i+1),ic,ierr)
      cg(i)=cmplx(rc,ic,kind=sp)
   enddo
end function cg
!===================================================================================================================================
! Does not work with gcc 5.3
!function sg()
!character(len=:),allocatable :: sg(:)
!   sg=unnamed
!end function sg

!===================================================================================================================================
function sg()
character(len=:),allocatable :: sg(:)
   if(allocated(sg))deallocate(sg)
   allocate(sg,source=unnamed)
end function sg
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine mystop(sig,msg)
! negative signal means always stop program
! else do not stop and set G_STOP_MESSAGE if G_QUIET is true
! or
! print message and stop if G_QUIET is false
! the MSG is NOT for displaying except for internal errors when the program will be stopped.
! It is for returning a value when the stop is being ignored
!
integer,intent(in) :: sig
character(len=*),intent(in),optional :: msg
   if(sig < 0)then
      if(present(msg))call journal(msg)
      stop 1
   elseif(.not.G_QUIET)then
      stop
   else
      if(present(msg)) then
         G_STOP_MESSAGE=msg
      else
         G_STOP_MESSAGE=''
      endif
      G_STOP=sig
   endif
end subroutine mystop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function atleast(line,length,pattern) result(strout)

! ident_32="@(#) M_strings atleast(3f) return string padded to at least specified length"

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=*),intent(in),optional       :: pattern
character(len=max(length,len(trim(line)))) :: strout
if(present(pattern))then
   strout=line//repeat(pattern,len(strout)/len(pattern)+1)
else
   strout=line
endif
end function atleast
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function clipends(string) result(lopped)
! trim leading and trailings spaces from resulting string
character(len=*),intent(in)  :: string
character(len=:),allocatable :: lopped
integer                      :: ends(2)
   ends=verify( string, " ", [.false.,.true.] )
   if(ends(1) == 0)then
      lopped=""
   else
      lopped=string(ends(1):ends(2))
   endif
end function clipends
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine locate_key(keyname,place)

! ident_33="@(#) M_CLI2 locate_key(3f) find PLACE in sorted character array where KEYNAME can be found or should be placed"

character(len=*),intent(in)             :: keyname
integer,intent(out)                     :: place
integer                                 :: ii
character(len=:),allocatable            :: keyword_local

   if(G_UNDERDASH)then
      keyword_local=trim(replace_str(keyname,'-','_'))
   else
      keyword_local=trim(keyname)
   endif

   if(G_NODASHUNDER)then
      keyword_local=replace_str(keyword_local,'-','')
      keyword_local=replace_str(keyword_local,'_','')
   endif

   if(G_IGNORELONGCASE.and.len_trim(keyword_local) > 1)keyword_local=lower(keyword_local)
   if(G_IGNOREALLCASE)keyword_local=lower(keyword_local)

   if(len(keyword_local) == 1)then
      !x!ii=findloc(shorts,keyword_local,dim=1)
      ii=maxloc([0,merge(1, 0, shorts == keyword_local)],dim=1)
      if(ii > 1)then
         place=ii-1
      else
         call locate_(keywords,keyword_local,place)
      endif
   else
      call locate_(keywords,keyword_local,place)
   endif

   if(G_DEBUG) write(*,gen)'<DEBUG>LOCATE_KEY:KEYNAME:',trim(keyname),':KEYWORD:',keyword_local

end subroutine locate_key
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set_mode(3f) - [ARGUMENTS:M_CLI2] turn on optional modes
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine set_mode(key,mode)
!!
!!     character(len=*),intent(in) :: key
!!     logical,intent(in),optional :: mode
!!
!!##DESCRIPTION
!!     Allow optional behaviors.
!!
!!##OPTIONS
!!    KEY    name of option
!!
!!    The following values are allowed:
!!
!!    o  response_file - enable use of response file
!!
!!    o  ignorelongcase - ignore case in long key names. So the user
!!       does not have to remember if the option is --CurtMode or --curtmode
!!       or --curtMode .
!!
!!    o  ignoreallcase - ignore case in long and short key names.
!!       This is similar to Powershell, which is case-insensitive.
!!
!!    o  dashunder  - treat dash in keyword as an underscore.
!!       So the user should not have to remember if the option is
!!       --ignore_case or --ignore-case.
!!
!!    o  nodashunder  - ignore dash and underscore in keywords.
!!
!!    o  strict - allow Boolean keys to be bundled, but requires
!!       a single dash prefix be used for short key names and long names
!!       must be prefixed with two dashes.
!!
!!    o  lastonly  - when multiple keywords occur keep the rightmost
!!       value specified instead of appending the values together.
!!
!!    MODE   set to .true. to activate the optional mode.
!!           Set to .false. to deactivate the mode.
!!           It is .true. by default.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!    program demo_set_mode
!!    use M_CLI2,  only : set_args, lget, set_mode
!!    implicit none
!!    character(len=*),parameter :: all='(*(g0))'
!!       !
!!       ! enable use of response files
!!       call set_mode('response_file')
!!       !
!!       ! Any dash in a keyword is treated as an underscore
!!       call set_mode('underdash')
!!       !
!!       ! The case of long keywords are ignored.
!!       ! Values and short names remain case-sensitive
!!       call set_mode('ignorelongcase')
!!       ! The case of short and long keywords are ignored
!!       call set_mode('ignoreallcase')
!!       !
!!       ! short single-character boolean keys may be bundled
!!       ! but it is required that a single dash is used for
!!       ! short keys and a double dash for long keywords.
!!       call set_mode('strict')
!!       !
!!       call set_args(' --switch_X:X F --switch-Y:Y F --ox:O F -t F -x F -o F')
!!       !
!!       ! show the results
!!       print all,'--switch_X or -X ... ',lget('switch_X')
!!       print all,'--switch_Y or -Y ... ',lget('switch_Y')
!!       print all,'--ox or -O       ... ',lget('ox')
!!       print all,'-o               ... ',lget('o')
!!       print all,'-x               ... ',lget('x')
!!       print all,'-t               ... ',lget('t')
!!    end program demo_set_mode
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
elemental impure subroutine set_mode(key,mode)
character(len=*),intent(in) :: key
logical,intent(in),optional :: mode
logical :: local_mode

   if(present(mode))then
      local_mode=mode
   else
      local_mode=.true.
   endif

   select case(lower(key))
   case('response_file','response file'); CLI_RESPONSE_FILE=local_mode
   case('debug');                         G_DEBUG=local_mode
   case('ignorecase','ignorelongcase');   G_IGNORELONGCASE=local_mode
   case('ignoreallcase');   G_IGNOREALLCASE=local_mode
   case('underdash','dashunder');         G_UNDERDASH=local_mode
   case('nodashunder','nounderdash');     G_NODASHUNDER=local_mode
   case('strict');                        G_STRICT=local_mode
   case('lastonly');                      G_APPEND=.not.local_mode
   case default
      call journal('*set_mode* unknown key name ',key)
   end select

   if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:END'

end subroutine set_mode
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_dictionary_usage()
   if(G_DEBUG)then
      call print_dictionary( str('response_file=', CLI_RESPONSE_FILE, &
                                &'ignorelongcase=', G_IGNORELONGCASE,&
                                &'ignoreallcase=', G_IGNOREALLCASE,&
                                &'underdash=', G_UNDERDASH,&
                                &'strict=', G_STRICT,&
                                &'lastonly=', G_APPEND,&
                                &'NODASHUNDER=', G_NODASHUNDER,&
                                &'debug=', G_DEBUG) )
   else
      call print_dictionary('USAGE:')
   endif
end subroutine print_dictionary_usage
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_CLI2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
 
 
!>>>>> build/dependencies/M_strings/src/M_strings.F90
!>
!!##NAME
!!    M_strings(3f) - [M_strings::INTRO] Fortran string module
!!
!!##DESCRIPTION
!!    The M_strings(3fm) module is a collection of Fortran procedures
!!    that supplement the built-in intrinsic string routines. Routines
!!    for parsing, tokenizing, changing case, substituting new strings for
!!    substrings, locating strings with simple wildcard expressions, removing
!!    tabs and line terminators and other string manipulations are included.
!!
!!    M_strings__oop(3fm) is a companion module that provides an OOP
!!    interface to the M_strings module.
!!
!!##SYNOPSIS
!!
!!  public entities:
!!
!!      use M_strings,only : split, slice, sep, delim, chomp, strtok
!!      use M_strings,only : split2020, find_field
!!      use M_strings,only : substitute, change, modif, transliterate, &
!!              & reverse, squeeze
!!      use M_strings,only : replace, join
!!      use M_strings,only : upper, lower, upper_quoted
!!      use M_strings,only : rotate13, percent_encode
!!      use M_strings,only : adjustc, compact, nospace, indent
!!      use M_strings,only : crop, clip, unquote, quote, matching_delimiter
!!      use M_strings,only : len_white, pad, lpad, cpad, rpad, zpad, &
!!              & stretch, lenset, merge_str
!!      use M_strings,only : switch, s2c, c2s
!!      use M_strings,only : noesc, notabs, dilate, expand, visible
!!      use M_strings,only : longest_common_substring
!!      use M_strings,only : string_to_value, string_to_values, s2v, s2vs
!!      use M_strings,only : int, real, dble, nint
!!      use M_strings,only : atoi, atol, aton
!!      use M_strings,only : value_to_string, v2s, msg
!!      use M_strings,only : listout, getvals
!!      use M_strings,only : glob, ends_with
!!      use M_strings,only : paragraph
!!      use M_strings,only : base, decodebase, codebase, base2
!!      use M_strings,only : isalnum, isalpha, iscntrl, isdigit
!!      use M_strings,only : isgraph, islower, isprint, ispunct
!!      use M_strings,only : isspace, isupper, isascii, isblank, isxdigit
!!      use M_strings,only : isnumber
!!      use M_strings,only : fortran_name
!!      use M_strings,only : describe
!!      use M_strings,only : edit_distance
!!      use M_strings,only : bundle
!!
!!   TOKENS
!!
!!       split   subroutine parses string using specified delimiter characters
!!               and stores tokens into an array
!!       sep     function interface to split(3f)
!!       slice   subroutine parses string using specified delimiter characters
!!               and stores beginning and ending positions in arrays
!!       delim   subroutine parses string using specified delimiter characters
!!               and store tokens into an array and records beginning and end
!!       chomp   function consumes input line as it returns next token in a
!!               string using specified delimiters
!!       paragraph    convert a string into a paragraph
!!       strtok  tokenize a string like C strtok(3c) routine
!!
!!       CONTRIBUTIONS
!!
!!       split2020   split a string using prototype of proposed standard
!!                   procedure
!!       find_field  token a string
!!
!!   EDITING
!!
!!       substitute     subroutine non-recursively globally replaces old
!!                      substring with new substring
!!       replace        function non-recursively globally replaces old
!!                      substring with new substring using allocatable string
!!                      (version of substitute(3f) without limitation on
!!                      length of output string)
!!       change         subroutine non-recursively globally replaces old
!!                      substring with new substring with a directive like
!!                      line editor
!!       modif          subroutine modifies a string with a directive like the
!!                      XEDIT line editor MODIFY command
!!       transliterate  replace characters found in set one with characters
!!                      from set two
!!       reverse        reverse character order in a string
!!       join           join an array of CHARACTER variables with specified
!!                      separator
!!       rotate13       apply trivial encryption algorithm ROT13 to a string
!!       percent_encode apply percent-encryption (aka. URL encryption) to characters
!!       squeeze        delete adjacent duplicate characters from a string
!!
!!   CASE
!!
!!       upper          function converts string to uppercase
!!       lower          function converts string to miniscule
!!       upper_quoted   function converts string to uppercase skipping strings
!!                      quoted per Fortran rules
!!
!!   STRING LENGTH AND PADDING
!!
!!       len_white  find location of last non-whitespace character
!!       lenset     return a string of specified length
!!       pad        return a string of at least specified length
!!       zpad       pad integer or string to length with zero characters
!!                  on left
!!       lpad       convert scalar intrinsic to a string padded on left to
!!                  specified length
!!       cpad       convert scalar intrinsic to a centered string of the
!!                  specified length
!!       rpad       convert scalar intrinsic to a string padded on right to
!!                  specified length
!!       stretch    return a string of at least specified length with suffix
!!       merge_str  make strings of equal length and then call MERGE(3f)
!!                  intrinsic
!!   WHITE SPACE
!!
!!       adjustc  elemental function centers text within the length of the
!!                input string
!!       compact  left justify string and replace duplicate whitespace with
!!                single characters or nothing
!!       nospace  function replaces whitespace with nothing
!!       indent   find number of leading spaces
!!       crop     function trims leading and trailing spaces and control
!!                characters
!!       clip     function trims leading and trailing spaces
!!
!!       See Also: squeeze
!!
!!   QUOTES
!!
!!       matching_delimiter  find position of matching delimiter
!!       unquote  remove quotes from string as if read with list-directed input
!!       quote    add quotes to string as if written with list-directed output
!!
!!
!!   CHARACTER ARRAY VERSUS STRING
!!
!!       switch  switch between a string and an array of single characters
!!       s2c     convert string to array of single characters and add null
!!               terminator for passing to C
!!       c2s     convert null-terminated array of single characters to
!!               string for converting strings returned from C
!!
!!   NONALPHA
!!
!!       noesc    convert non-printable ASCII8 characters to a space
!!       notabs   convert tabs to spaces while maintaining columns,
!!                assuming tabs are set every 8 characters
!!       dilate   function to convert tabs to spaces assuming tabs are set
!!                every 8 characters
!!       expand   expand escape sequences in a string
!!       visible  expand escape sequences in a string to "control" and
!!                meta-control representations
!!
!!   NUMERIC STRINGS
!!
!!       string_to_value   generic subroutine returns numeric value (REAL,
!!                         DOUBLEPRECISION, INTEGER) from string
!!       string_to_values  subroutine reads an array of numbers from a string
!!       getvals           subroutine reads a relatively arbitrary number
!!                         of values from a string using list-directed read
!!       s2v               function returns DOUBLEPRECISION numeric value
!!                         from string
!!       s2vs              function returns a DOUBLEPRECISION array of numbers
!!                         from a string
!!       s2vs              function returns a DOUBLEPRECISION array of numbers
!!                         from a string
!!       atoi              function returns INTEGER(kind=int32)  from a string
!!       atol              function returns INTEGER(kind=int64)  from a string
!!       aton              changes string to numeric value
!!       msg               append the values of up to nine values into a string
!!
!!       value_to_string   generic subroutine returns string given numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )
!!       v2s               generic function returns string from numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER )
!!       listout           expand a list of numbers where negative numbers
!!                         denote range ends (1 -10 means 1 thru 10)
!!       isnumber          determine if string represents a number
!!
!!   CHARACTER TESTS
!!
!!       glob        compares given string for match to pattern which may
!!                   contain wildcard characters
!!       ends_with   test whether strings ends with one of the specified suffixes
!!
!!       o isalnum   returns .true. if character is a letter or digit
!!       o isalpha   returns .true. if character is a letter and
!!                   .false. otherwise
!!       o iscntrl   returns .true. if character is a delete character or
!!                   ordinary control character
!!       o isdigit   returns .true. if character is a digit (0,1,...,9)
!!                   and .false. otherwise
!!       o isgraph   returns .true. if character is a printable character
!!                   except a space is considered non-printable
!!       o islower   returns .true. if character is a miniscule letter (a-z)
!!       o isprint   returns .true. if character is an ASCII printable
!!                   character
!!       o ispunct   returns .true. if character is a printable punctuation
!!                   character
!!       o isspace   returns .true. if character is a null, space, tab,
!!                   carriage return, new line, vertical tab, or formfeed
!!       o isupper   returns .true. if character is an uppercase letter (A-Z)
!!       o isascii   returns .true. if the character is in the range char(0)
!!                   to char(127)
!!       o isblank   returns .true. if character is a blank character
!!                   (space or horizontal tab.
!!       o isxdigit  returns .true. if character is a hexadecimal digit
!!                   (0-9, a-f, or A-F).
!!
!!       fortran_name   returns .true. if input string is a valid Fortran name
!!
!!   BASE CONVERSION
!!
!!       base       convert whole number string in base [2-36] to string
!!                  in alternate base [2-36]
!!       base2      convert INTEGER to a string representing a binary value
!!       codebase   convert whole number string in base [2-36] to base
!!                  10 number
!!       decodebase convert whole number in base 10 to string in base [2-36]
!!
!!   MISCELLANEOUS
!!
!!       bundle         return up to twenty strings of arbitrary length as
!!                      an array
!!       describe       returns a string describing the name of a single
!!                      character
!!       edit_distance  returns a naive edit distance using the Levenshtein
!!                      distance algorithm
!!       longest_common_substring  function that returns the longest common
!!                                 substring of two strings.
!!
!!   INTRINSICS
!!
!!    The M_strings(3fm) module supplements and works in combination with
!!    the Fortran built-in intrinsics. Stand-alone Fortran lets you access
!!    the characters in a string using ranges much like they are character
!!    arrays, assignment, comparisons with standard operators, supports
!!    dynamically allocatable strings and supports concatenation using the //
!!    operator, as well as a number of intrinsic string routines:
!!
!!        adjustl             Left adjust a string
!!        adjustr             Right adjust a string
!!        index               Position of a substring within a string
!!        repeat              Repeated string concatenation
!!        scan                Scan a string for the presence of a set
!!                            of characters
!!        trim                Remove trailing blank characters of a string
!!        verify              Scan a string for the absence of a set of
!!                            characters
!!        len                 It returns the length of a character string
!!        achar               converts an integer into a character
!!        iachar              converts a character into an integer
!!        len_trim            finds length of string with trailing spaces
!!                            ignored
!!        new_line            Newline character
!!        selected_char_kind  Choose character kind
!!        lge                 Lexical greater than or equal
!!        lgt                 Lexical greater than
!!        lle                 Lexical less than or equal
!!        llt                 Lexical less than
!!
!!   OOPS INTERFACE
!!
!!    The M_strings__oop(3fm) module (included with the M_strings(3fm)
!!    module) provides an OOP (Object-Oriented Programming) interface to
!!    the M_strings(3fm) module.
!!
!!##SEE ALSO
!!    There are additional routines in other GPF modules for working with
!!    expressions (M_calculator), time strings (M_time), random strings
!!    (M_random, M_uuid), lists (M_list), and interfacing with the C regular
!!    expression library (M_regex).
!!
!!##EXAMPLES
!!
!!    Each of the procedures includes an [example](example/) program in
!!    the corresponding man(1) page for the function.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
MODULE M_strings !
use, intrinsic :: iso_fortran_env, only : output_unit, stderr=>error_unit
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none

! ident_1="@(#) M_strings(3f) Fortran module containing routines that deal with character strings"

!-----------------------------------------------------------------------------------------------------------------------------------
private

!-------------------------# TOKENS
public split              !  subroutine parses a string on specified delimiter characters and store tokens into an allocatable array
public slice              !  subroutine parses a string on specified delimiter characters and stores positions into arrays
public sep                !  function interface to split
public chomp              !  function consumes input line as it returns next token in a string using specified delimiters
public delim              !  subroutine parses a string using specified delimiter characters and store tokens into an array
public strtok             !  gets next token. Used by change(3f)
public paragraph          !  convert a long string into a paragraph
!-------------------------# EDITING
public substitute         !  subroutine non-recursively globally replaces old substring with new substring in string
public replace            !  function non-recursively globally replaces old substring with new substring in string
public change             !  replaces old substring with new substring in string with a directive like a line editor
public modif              !  change string using a directive using rules similar to XEDIT line editor MODIFY command
public transliterate      !  when characters in set one are found replace them with characters from set two
public reverse            !  elemental function reverses character order in a string
public join               !  append an array of character variables with specified separator into a single CHARACTER variable
public squeeze            !  delete adjacent duplicate characters from a string
public rotate13           !  apply trivial encryption algorithm ROT13 to string
public percent_encode     !  percent-encode characters or a string
interface percent_encode;    module procedure percent_encode_string, percent_encode_characters;  end interface
!-------------------------# CHARACTER ARRAY VERSUS STRING
public switch             !  generic switch between a string and an array of single characters (a2s,s2a)
private a2s               !  function to copy char array to string
private s2a               !  function to copy string(1:Clen(string)) to char array
public s2c                !  convert character variable to array of character(len=1) with null terminator for C compatibility
public c2s                !  convert null-terminated array of character(len=1) to string for strings returned by C
!-------------------------# CASE
public upper              !  elemental function converts string to uppercase
interface upper;    module procedure upper_all, upper_range;  end interface
public lower              !  elemental function converts string to miniscule
public upper_quoted       !  elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules
!-------------------------# WHITE SPACE
public adjustc            !  elemental function centers string within the length of the input string
public compact            !  left justify string and replace duplicate whitespace with single characters or nothing
public nospace            !  function replaces whitespace with nothing
public indent             !  count number of leading spaces
public crop               !  function trims leading and trailing spaces and control characters
public clip               !  function trims leading and trailing spaces
!-------------------------# QUOTES
public matching_delimiter !  find position of matching delimiter
public unquote            !  remove quotes from string as if read with list-directed input
public quote              !  add quotes to string as if written with list-directed output
!-------------------------# STRING LENGTH
public lenset             !  return a string as specified length
public pad                !  return a string of at least specified length
public zpad               !  return a string of at least specified length padded on left with zeros
interface zpad;    module procedure zpad_scalar, zpad_vector;  end interface
public lpad               !  convert value to a string of at least specified length padded on left with zeros
interface lpad;    module procedure lpad_scalar, lpad_vector;  end interface
public cpad               !  convert value to a centered string of at least specified length
interface cpad;    module procedure cpad_scalar, cpad_vector;  end interface
public rpad               !  convert value to a string of at least specified length padded on right with zeros
interface rpad;    module procedure rpad_scalar, rpad_vector;  end interface
public stretch            !  return a string of at least specified length with suffix
public merge_str          !  make strings of equal length and then call MERGE(3f) intrinsic
public len_white          !  find location of last non-whitespace character
!-------------------------# NONALPHA
public noesc              !  elemental function converts non-printable ASCII8 characters to a space
public notabs             !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public dilate             !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public expand             !  expand escape sequences in a string
public visible            !  expand escape sequences in a string to control and meta-control representations
!-------------------------# NUMERIC STRINGS
public string_to_value    !  generic subroutine returns REAL|DOUBLEPRECISION|INTEGER value from string (a2d,a2r,a2i)
 private a2d              !  subroutine returns double value from string
 private a2r              !  subroutine returns real value from string
 private a2i              !  subroutine returns integer value from string
public string_to_values   !  subroutine returns values from a string
public getvals            !  subroutine returns values from a string
public s2v                !  function returns doubleprecision value from string
public s2vs               !  function returns a doubleprecision array of numbers from a string
                          !  NOT USING INTERNAL READ FOR CONVERSION
public atoi               !   function returns an INTEGER(kind=int32) value from a string
public atol               !   function returns an INTEGER(kind=int64) value from a string
public aton               !   function returns true or false as to whether string converts to numeric value, and numeric value
!------------------------------------------------------------------------------------------------------------
public msg                !  function returns a string representing up to nine scalar intrinsic values
public value_to_string    !  generic subroutine returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
public v2s                !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
 private d2s              !  function returns string from doubleprecision value
 private r2s              !  function returns string from real value
 private i2s              !  function returns string from integer value
 private l2s              !  function returns string from logical value
public isnumber           !  determine if string represents a number
 private trimzeros_       !  Delete trailing zeros from numeric decimal string
public listout            !  expand a list of numbers where  negative numbers denote range ends (1 -10 means 1 thru 10)
!-----------------------------------------------------------------------------------------------------------------------------------
!
! extend intrinsics to accept CHARACTER values
!
public int, real, dble, nint

interface int;     module procedure atoi;              end interface
interface real;    module procedure real_s2v;          end interface
interface dble;    module procedure dble_s2v;          end interface
interface nint;    module procedure nint_s2v;          end interface

interface aton
module procedure ator_real32
module procedure ator_real64
module procedure atoi_int8
module procedure atoi_int16
module procedure atoi_int32
module procedure atoi_int64
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!----------------------# BIT ROUTINES
public setbits8        !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits16       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits32       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits64       !  use a string representing a positive binary value to fill the bits of an INTEGER value
!----------------------# BASE CONVERSION
public base            !  convert whole number string in base [2-36] to string in alternate base [2-36]
public codebase        !  convert whole number string in base [2-36] to base 10 number
public decodebase      !  convert whole number in base 10 to string in base [2-36]
public base2           !  convert INTEGER to a string representing a binary value
!----------------------# LOGICAL TESTS
public glob            !  compares given string for match to pattern which may contain wildcard characters
public ends_with       !  test whether strings ends with one of the specified suffix
public isalnum         !  elemental function returns .true. if CHR is a letter or digit
public isalpha         !  elemental function returns .true. if CHR is a letter and .false. otherwise
public isascii         !  elemental function returns .true. if the low order byte of c is in the range char(0) to char(127)
public isblank         !  elemental function returns .true. if CHR is a blank character (space or horizontal tab.
public iscntrl         !  elemental function returns .true. if CHR is a delete character or ordinary control character
public isdigit         !  elemental function returns .true. if CHR is a digit (0,1,...,9) and .false. otherwise
public isgraph         !  elemental function true if CHR is an ASCII printable character except considers a space non-printable
public islower         !  elemental function returns .true. if CHR is a miniscule letter (a-z)
public isprint         !  elemental function determines if CHR is an ASCII printable character
public ispunct         !  elemental function returns .true. if CHR is a printable punctuation character
public isspace         !  elemental function true if CHR is a null, space, tab, carriage return, new line, vertical tab, or formfeed
public isupper         !  elemental function returns .true. if CHR is an uppercase letter (A-Z)
public isxdigit        !  elemental function returns .true. if CHR is a hexadecimal digit (0-9, a-f, or A-F).
!----------------------#
!-------------------------------#
public fortran_name             !  elemental function returns .true. if LINE is a valid Fortran name
public describe                 !  returns a string describing character
public edit_distance            !  returns a naive edit distance using the Levenshtein distance algorithm
public bundle                   !  return up to twenty strings of arbitrary length as an array
public longest_common_substring !  function that returns the longest common substring of two strings.
!-------------------------------#

!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_strings switch(3f) toggle between string and array of characters; generic{a2s s2a}"

interface switch
   module procedure a2s, s2a
end interface switch
! note how returned result is "created" by the function
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_3="@(#) M_strings string_to_value(3f) Generic subroutine converts numeric string to a number (a2d a2r a2i)"

interface string_to_value
   module procedure a2d, a2r, a2i
end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_4="@(#) M_strings v2s(3f) Generic function returns string given REAL|INTEGER|DOUBLEPRECISION value(d2s r2s i2s)"

interface v2s
   module procedure d2s, r2s, i2s, l2s
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!-!interface setbits ! boz
!-!        module procedure setbits8, setbits16, setbits32, setbits64
!-!end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_5="@(#) M_strings msg(3f) convert up to nine scalar values to a string. Alternatively can also handle one-dimensional arrays"

interface msg
   module procedure msg_scalar, msg_one
end interface msg
!-----------------------------------------------------------------------------------------------------------------------------------
! ASCII character constants
character, public, parameter :: ascii_nul = char(0)   ! null
character, public, parameter :: ascii_bel = char(7)   ! bell
character, public, parameter :: ascii_bs  = char(8)   ! backspace
character, public, parameter :: ascii_ht  = char(9)   ! horizontal tab
character, public, parameter :: ascii_lf  = char(10)  ! line feed or newline
character, public, parameter :: ascii_ff  = char(12)  ! form feed or newpage
character, public, parameter :: ascii_cr  = char(13)  ! carriage return
character, public, parameter :: ascii_esc = char(27)  ! escape
!-----------------------------------------------------------------------------------------------------------------------------------
interface ends_with
    procedure :: ends_with_str
    procedure :: ends_with_any
end interface ends_with
!-----------------------------------------------------------------------------------------------------------------------------------
public :: split2020, string_tokens
public :: find_field

interface split2020
   module procedure :: split_tokens, split_first_last, split_pos
end interface split2020
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
!This contains a conditionally built mini-version of M_journal which allows the M_strings.f90 module
!to be built using make as a stand-alone distribution but still have make.shell built a true version
!
!This is so when built with make.shell(1) or fpm(1) it will use the
!real M_journal.f90 file but that fpm(1) will not auto-discover the mini
!M_journal.f90 file and built it and cause duplicates.

interface journal
   module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
end interface journal

interface str
   module procedure str_scalar, str_one
end interface str

!$@(#) M_journal::journal(3fg): provides public message routine, no paging or graphic mode change

! global variables

integer,save,private       :: stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
! for compatibility allow old name for renamed procedures
interface matchw;  module procedure glob;    end interface
interface atleast; module procedure pad;     end interface
interface cc;      module procedure bundle;  end interface
public matchw          !  clone of glob -- for backward compatibiity
public atleast         !  clone of pad -- for backward compatibiity
public cc              !  clone of pad -- for backward compatibiity
!-----------------------------------------------------------------------------------------------------------------------------------
CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    glob(3f) - [M_strings:COMPARE] compare given string for match to
!!    a pattern which may contain globbing wildcard characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function glob(string, pattern )
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: pattern
!!
!!##DESCRIPTION
!!    glob(3f) compares given (entire) STRING for a match to PATTERN which may
!!    contain basic wildcard "globbing" characters.
!!
!!    In this version to get a match the entire string must be described
!!    by PATTERN. Trailing whitespace is significant, so trim the input
!!    string to have trailing whitespace ignored.
!!
!!    Patterns like "b*ba" fail on a string like "babababa" because the
!!    algorithm finds an early match. To skip over the early matches insert
!!    an extra character at the end of the string and pattern that does
!!    not occur in the pattern. Typically a NULL is used (char(0)).
!!
!!##OPTIONS
!!    string   the input string to test to see if it contains the pattern.
!!    pattern  the following simple globbing options are available
!!
!!             o "?" matching any one character
!!             o "*" matching zero or more characters.
!!               Do NOT use adjacent asterisks.
!!             o spaces are significant and must be matched or pretrimmed
!!             o There is no escape character, so matching strings with
!!               literal question mark and asterisk is problematic.
!!
!!##EXAMPLES
!!
!!   Example program
!!
!!    program demo_glob
!!    implicit none
!!    ! This main() routine passes a bunch of test strings
!!    ! into the above code.  In performance comparison mode,
!!    ! it does that over and over. Otherwise, it does it just
!!    ! once. Either way, it outputs a passed/failed result.
!!    !
!!    integer :: nReps
!!    logical :: allpassed
!!    integer :: i
!!    allpassed = .true.
!!
!!    nReps = 10000
!!    ! Can choose as many repetitions as you're expecting
!!    ! in the real world.
!!    nReps = 1
!!
!!    do i=1,nReps
!!       ! Cases with repeating character sequences.
!!       allpassed= test("a*abab",      "a*b",   .true.)  .and. allpassed
!!       allpassed= test("ab",          "*?",    .true.)  .and. allpassed
!!       allpassed= test("abc",         "*?",    .true.)  .and. allpassed
!!       allpassed= test("abcccd",      "*ccd",  .true.)  .and. allpassed
!!       allpassed= test("bLah",        "bLaH",  .false.) .and. allpassed
!!       allpassed= test("mississippi", "*sip*", .true.)  .and. allpassed
!!       allpassed= &
!!        & test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.) .and. allpassed
!!       allpassed= &
!!        & test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.) .and. allpassed
!!       allpassed= &
!!        & test("mississipissippi", "*issip*ss*", .true.) .and. allpassed
!!       allpassed= &
!!        & test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.) .and. allpassed
!!       allpassed= &
!!        & test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.) .and. allpassed
!!       allpassed= test("xyxyxyzyxyz", "xy*z*xyz", .true.)  .and. allpassed
!!       allpassed= test("xyxyxyxyz",   "xy*xyz",   .true.)  .and. allpassed
!!       allpassed= test("mississippi", "mi*sip*",  .true.)  .and. allpassed
!!       allpassed= test("ababac",      "*abac*",   .true.)  .and. allpassed
!!       allpassed= test("aaazz",       "a*zz*",    .true.)  .and. allpassed
!!       allpassed= test("a12b12",      "*12*23",   .false.) .and. allpassed
!!       allpassed= test("a12b12",      "a12b",     .false.) .and. allpassed
!!       allpassed= test("a12b12",      "*12*12*",  .true.)  .and. allpassed
!!
!!       ! Additional cases where the '*' char appears in the tame string.
!!       allpassed= test("*",     "*",      .true.)  .and. allpassed
!!       allpassed= test("a*r",   "a*",     .true.)  .and. allpassed
!!       allpassed= test("a*ar",  "a*aar",  .false.) .and. allpassed
!!
!!       ! More double wildcard scenarios.
!!       allpassed= test("XYXYXYZYXYz", "XY*Z*XYz",  .true.)  .and. allpassed
!!       allpassed= test("missisSIPpi", "*SIP*",     .true.)  .and. allpassed
!!       allpassed= test("mississipPI", "*issip*PI", .true.)  .and. allpassed
!!       allpassed= test("xyxyxyxyz",   "xy*xyz",    .true.)  .and. allpassed
!!       allpassed= test("miSsissippi", "mi*sip*",   .true.)  .and. allpassed
!!       allpassed= test("miSsissippi", "mi*Sip*",   .false.) .and. allpassed
!!       allpassed= test("abAbac",      "*Abac*",    .true.)  .and. allpassed
!!       allpassed= test("aAazz",       "a*zz*",     .true.)  .and. allpassed
!!       allpassed= test("A12b12",      "*12*23",    .false.) .and. allpassed
!!       allpassed= test("a12B12",      "*12*12*",   .true.)  .and. allpassed
!!       allpassed= test("oWn",         "*oWn*",     .true.)  .and. allpassed
!!
!!       ! Completely tame (no wildcards) cases.
!!       allpassed= test("bLah", "bLah", .true.) .and. allpassed
!!
!!       ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
!!       allpassed= test("a", "*?", .true.) .and. allpassed
!!
!!       ! More mixed wildcard tests including coverage for false positives.
!!       allpassed= test("a",      "??",         .false.) .and. allpassed
!!       allpassed= test("ab",     "?*?",        .true.)  .and. allpassed
!!       allpassed= test("ab",     "*?*?*",      .true.)  .and. allpassed
!!       allpassed= test("abc",    "?**?*?",     .true.)  .and. allpassed
!!       allpassed= test("abc",    "?**?*&?",    .false.) .and. allpassed
!!       allpassed= test("abcd",   "?b*??",      .true.)  .and. allpassed
!!       allpassed= test("abcd",   "?a*??",      .false.) .and. allpassed
!!       allpassed= test("abcd",   "?**?c?",     .true.)  .and. allpassed
!!       allpassed= test("abcd",   "?**?d?",     .false.) .and. allpassed
!!       allpassed= test("abcde",  "?*b*?*d*?",  .true.)  .and. allpassed
!!
!!       ! Single-character-match cases.
!!       allpassed= test("bLah",   "bL?h",  .true.)  .and. allpassed
!!       allpassed= test("bLaaa",  "bLa?",  .false.) .and. allpassed
!!       allpassed= test("bLah",   "bLa?",  .true.)  .and. allpassed
!!       allpassed= test("bLaH",   "?Lah",  .false.) .and. allpassed
!!       allpassed= test("bLaH",   "?LaH",  .true.)  .and. allpassed
!!
!!       allpassed= test('abcdefghijk' ,  '?b*',     .true.)  .and. allpassed
!!       allpassed= test('abcdefghijk' ,  '*c*',     .true.)  .and. allpassed
!!       allpassed= test('abcdefghijk' ,  '*c',      .false.) .and.  allpassed
!!       allpassed= test('abcdefghijk' ,  '*c*k',    .true.)  .and. allpassed
!!       allpassed= test('LS'          ,  '?OW',     .false.) .and.  allpassed
!!       allpassed= test('teztit'      ,  'tez*t*t', .true.)  .and. allpassed
!!         ! Two pattern match problems that might pose difficulties
!!       allpassed= test('e '           , '*e* ',      .true.) .and. allpassed
!!       allpassed= test('abcde       ' , '*e      *', .true.) .and. allpassed
!!       allpassed= test('bababa'       , 'b*ba',      .true.) .and. allpassed
!!       allpassed= test('baaaaax'      , 'b*ax',      .true.) .and. allpassed
!!       allpassed= test('baaaaa'       , 'b*ax',      .false.) .and. allpassed
!!       allpassed= test('baaaaax'      , 'b*a',       .false.) .and. allpassed
!!       allpassed= test(''             , 'b*',        .false.) .and. allpassed
!!       allpassed= test(''             , '*',         .true.) .and.  allpassed
!!       allpassed= test('b'            , '',          .false.) .and. allpassed
!!       allpassed= test('3'            , '??',        .false.) .and. allpassed
!!       ! known flaws
!!       allpassed= test(''             , '',          .true.) .and. allpassed
!!       allpassed= test('baaaaa'       , 'b*a',       .true.) .and. allpassed
!!       ! add unused character to work around
!!       allpassed= test(''//char(0),      ''//char(0),   .true.).and.allpassed
!!       allpassed= test('baaaaa'//char(0),'b*a'//char(0),.true.).and.allpassed
!!
!!       ! Many-wildcard scenarios.
!!       allpassed= test(&
!!       &"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!!       &aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",&
!!       &"a*a*a*a*a*a*aa*aaa*a*a*b",&
!!       &.true.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacac&
!!       &adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&
!!       &.true.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacaca&
!!       &cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacacad&
!!       &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacacad&
!!       &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&
!!       &.true.) .and. allpassed
!!       allpassed= test("aaabbaabbaab","*aabbaa*a*",.true.).and.allpassed
!!       allpassed= &
!!       test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*",&
!!       &"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!       allpassed= test("aaaaaaaaaaaaaaaaa",&
!!       &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!       allpassed= test("aaaaaaaaaaaaaaaa",&
!!       &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.) .and. allpassed
!!       allpassed= test(&
!!       &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!       &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!       & "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc&
!!       &*abc*abc*abc*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!       &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!       &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&
!!       &.true.) .and. allpassed
!!       allpassed= test("abc*abcd*abcd*abc*abcd",&
!!       &"abc*abc*abc*abc*abc", .false.) .and. allpassed
!!       allpassed= test( "abc*abcd*abcd*abc*abcd*abcd&
!!       &*abc*abcd*abc*abc*abcd", &
!!       &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&
!!       &.true.) .and. allpassed
!!       allpassed= test("abc",&
!!       &"********a********b********c********", .true.) .and. allpassed
!!       allpassed=&
!!       &test("********a********b********c********", "abc",.false.)&
!!       & .and.allpassed
!!       allpassed= &
!!       &test("abc", "********a********b********b********",.false.)&
!!       & .and.allpassed
!!       allpassed= test("*abc*", "***a*b*c***", .true.) .and. allpassed
!!
!!       ! A case-insensitive algorithm test.
!!       ! allpassed=test("mississippi", "*issip*PI", .true.) .and. allpassed
!!     enddo
!!
!!     if (allpassed)then
!!        write(*,'(*(g0,1x))')"Passed",nReps
!!     else
!!        write(*,'(a)')"Failed"
!!     endif
!!    contains
!!    ! This is a test program for wildcard matching routines.
!!    ! It can be used either to test a single routine for correctness,
!!    ! or to compare the timings of two (or more) different wildcard
!!    ! matching routines.
!!    !
!!    function test(tame, wild, bExpectedResult) result(bPassed)
!!    use M_strings, only : glob
!!       character(len=*) :: tame
!!       character(len=*) :: wild
!!       logical          :: bExpectedResult
!!       logical          :: bResult
!!       logical          :: bPassed
!!       bResult = .true.    ! We'll do "&=" cumulative checking.
!!       bPassed = .false.   ! Assume the worst.
!!       write(*,*)repeat('=',79)
!!       bResult = glob(tame, wild) ! Call a wildcard matching routine.
!!
!!       ! To assist correctness checking, output the two strings in any
!!       ! failing scenarios.
!!       if (bExpectedResult .eqv. bResult) then
!!          bPassed = .true.
!!          if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild
!!       else
!!          if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild
!!       endif
!!
!!    end function test
!!    end program demo_glob
!!
!!   Expected output
!!
!!##AUTHOR
!!   John S. Urban
!!
!!##REFERENCE
!!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm"
!!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
!!
!!##LICENSE
!!   Public Domain
function glob(tame,wild)

! ident_6="@(#) M_strings glob(3f) function compares text strings one of which can have wildcards ('*' or '?')."

logical                    :: glob
character(len=*)           :: tame       ! A string without wildcards
character(len=*)           :: wild       ! A (potentially) corresponding string with wildcards
character(len=len(tame)+1) :: tametext
character(len=len(wild)+1) :: wildtext
character(len=1),parameter :: NULL=char(0)
integer                    :: wlen
integer                    :: ti, wi
integer                    :: i
character(len=:),allocatable :: tbookmark, wbookmark
! These two values are set when we observe a wildcard character. They
! represent the locations, in the two strings, from which we start once we have observed it.
   tametext=tame//NULL
   wildtext=wild//NULL
   tbookmark = NULL
   wbookmark = NULL
   wlen=len(wild)
   wi=1
   ti=1
   do                                            ! Walk the text strings one character at a time.
      if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?
         do i=wi,wlen                            ! Easy: unique up on it!
            if(wildtext(wi:wi) == '*')then
               wi=wi+1
            else
               exit
            endif
         enddo
         if(wildtext(wi:wi) == NULL) then        ! "x" matches "*"
            glob=.true.
            return
         endif
         if(wildtext(wi:wi)  /=  '?') then
            ! Fast-forward to next possible match.
            do while (tametext(ti:ti)  /=  wildtext(wi:wi))
               ti=ti+1
               if (tametext(ti:ti) == NULL)then
                  glob=.false.
                  return                         ! "x" doesn't match "*y*"
               endif
            enddo
         endif
         wbookmark = wildtext(wi:)
         tbookmark = tametext(ti:)
      elseif(tametext(ti:ti)  /=  wildtext(wi:wi) .and. wildtext(wi:wi)  /=  '?') then
         ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.
         if(wbookmark /= NULL) then
            if(wildtext(wi:) /=  wbookmark) then
               wildtext = wbookmark
               wlen=len_trim(wbookmark)
               wi=1
               ! Don't go this far back again.
               if (tametext(ti:ti)  /=  wildtext(wi:wi)) then
                  tbookmark=tbookmark(2:)
                  tametext = tbookmark
                  ti=1
                  cycle                          ! "xy" matches "*y"
               else
                  wi=wi+1
               endif
            endif
            if (tametext(ti:ti) /= NULL) then
               ti=ti+1
               cycle                             ! "mississippi" matches "*sip*"
            endif
         endif
         glob=.false.
         return                                  ! "xy" doesn't match "x"
      endif
      ti=ti+1
      wi=wi+1
      if (ti > len(tametext)) then
         glob=.false.
         return
      elseif (tametext(ti:ti) == NULL) then          ! How do you match a tame text string?
         if(wildtext(wi:wi) /= NULL)then
            do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!
               wi=wi+1                           ! "x" matches "x*"
               if(wildtext(wi:wi) == NULL)exit
            enddo
         endif
         if (wildtext(wi:wi) == NULL)then
            glob=.true.
            return                               ! "x" matches "x"
         endif
         glob=.false.
         return                                  ! "x" doesn't match "xy"
      endif
   enddo
end function glob
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    ends_with(3f) - [M_strings:COMPARE] test if string ends with specified
!!                    suffix(es)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function ends_with(source_string,suffix)
!!
!!     or
!!
!!    function ends_with(source_string,[suffix])
!!
!!     character(len=*),intent(in)          :: source_string
!!     character(len=*),intent(in)          :: suffix(..)
!!     logical                              :: ends_with
!!
!!##DESCRIPTION
!!
!!##OPTIONS
!!     SOURCE_STRING  string to tokenize
!!     SUFFIX         list of separator strings. May be scalar or an array.
!!                    Trailing spaces are ignored.
!!
!!##RETURNS
!!     ENDS_WITH      returns .TRUE. if one of the suffix match the end
!!                    of SOURCE_STRING.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_ends_with
!!    use M_strings, only : ends_with
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!       write(stdout,*)ends_with('prog.a',['.o','.i','.s'])
!!       write(stdout,*)ends_with('prog.f90',['.F90','.f90','.f  ','.F  '])
!!       write(stdout,*)ends_with('prog.pdf','.pdf')
!!       write(stdout,*)ends_with('prog.doc','.txt')
!!    end program demo_ends_with
!!
!!   Results:
!!
!!     F
!!     T
!!     T
!!     F
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function ends_with_str(string, ending) result(matched)
character(*), intent(in) :: string, ending
integer                  :: n1, n2
logical                  :: matched
   n1 = len(string) - len(ending) + 1
   n2 = len(string)
   if (n1 < 1) then
       matched = .false.
   else
       matched = (string(n1:n2) == ending)
   endif
end function ends_with_str
!-----------------------------------------------------------------------------------------------------------------------------------
pure function ends_with_any(string, endings) result(matched)
character(*), intent(in) :: string
character(*), intent(in) :: endings(:)
logical                  :: matched
integer                  :: i
   matched = .true.
   FINDIT: block
   do i=1, size(endings)
       if(ends_with_str(string,trim(endings(i)))) exit FINDIT
   enddo
   matched = .false.
   endblock FINDIT
end function ends_with_any
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sep(3f) - [M_strings:TOKENS] function to parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function sep(input_line,delimiters,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: nulls
!!     character(len=:),allocatable             :: sep(:)
!!
!!##DESCRIPTION
!!     sep(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!    ORDER='ASCENDING'|'DESCENDING'  by default the tokens are returned from
!!                                    last to first; order='ASCENDING' returns
!!                                    them from first to last (left to right).
!!##RETURNS
!!    SEP       Output array of tokens
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_sep
!!    use M_strings, only: sep
!!    character(len=*),parameter :: fo='(/,a,*(/,"[",g0,"]":,","))'
!!    character(len=*),parameter :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!       write(*,'(a)') 'INPUT LINE:['//LINE//']'
!!       write(*,fo) 'typical call:',sep(line)
!!       write(*,fo) 'delimiters ":|":',sep(line,':|')
!!       write(*,fo) 'count null fields ":|":',sep(line,':|','return')
!!    end program demo_sep
!!
!!  Output
!!
!!    INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!
!!    typical call:
!!    [cc        ],
!!    [B         ],
!!    [a         ],
!!    [333|333   ],
!!    [1:|:2     ],
!!    [qrstuvwxyz],
!!    [ghijklmnop],
!!    [aBcdef    ]
!!
!!    delimiters ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!    count null fields ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [                                   ],
!!    [                                   ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function sep(input_line,delimiters,nulls,order)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_7="@(#) M_strings sep(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=*),optional,intent(in)     :: order       ! return strings composed of delimiters or not ignore|return|ignoreend

character(len=:),allocatable             :: sep(:)      ! output array of tokens
integer                                  :: isize
   call split(input_line,sep,delimiters,'right',nulls)
   if(present(order))then
   select case(order)
   case('ascending','ASCENDING')
    isize=size(sep)
    if(isize > 1)then
       sep=sep(isize:1:-1)
    endif
   end select
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function sep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!
!!##DESCRIPTION
!!     SPLIT(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!                (This can be accomplished with array syntax in modern
!!                Fortran, but was more useful pre-fortran90).
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_split
!!    use M_strings, only: split
!!    implicit none
!!    integer :: i
!!    character(len=*),parameter :: title='(80("="),t1,a)'
!!    character(len=*),parameter     :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!    character(len=:),allocatable :: array(:) ! output array of tokens
!!       write(*,*)'INPUT LINE:['//line//']'
!!       !
!!       write(*,title)'typical call: '
!!       call split(line,array)
!!       call printme()
!!       !
!!       write(*,title)'custom delimiters=":|" : '
!!       call split(line,array,delimiters=':|',&
!!       & order='sequential',nulls='ignore')
!!       call printme()
!!       !
!!       write(*,title)&
!!       'delimiters=":|",reverse array order and count null fields:'
!!       call split(line,array,delimiters=':|',&
!!       & order='reverse',nulls='return')
!!       call printme()
!!       !
!!       write(*,title)&
!!       'default delimiters, reverse array order and return null fields:'
!!       call split(line,array,delimiters='',&
!!       & order='reverse',nulls='return')
!!       call printme()
!!    contains
!!    subroutine printme()
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!    end subroutine printme
!!    end program demo_split
!!
!! Results:
!!
!!  > INPUT LINE:
!!  > [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!  > typical call: ========================================================
!!  > 1 ==> aBcdef
!!  > 2 ==> ghijklmnop
!!  > 3 ==> qrstuvwxyz
!!  > 4 ==> 1:|:2
!!  > 5 ==> 333|333
!!  > 6 ==> a
!!  > 7 ==> B
!!  > 8 ==> cc
!!  >  SIZE:           8
!!  > custom delimiters=":|" : =============================================
!!  > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!  > 2 ==> 2     333
!!  > 3 ==> 333 a B cc
!!  >  SIZE:           3
!!  > delimiters=":|",reverse array order and count null fields:============
!!  > 1 ==> 333 a B cc
!!  > 2 ==> 2     333
!!  > 3 ==>
!!  > 4 ==>
!!  > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!  >  SIZE:           5
!!  > default delimiters, reverse array order and return null fields:=======
!!  > 1 ==>
!!  > 2 ==>
!!  > 3 ==>
!!  > 4 ==> cc
!!  > 5 ==> B
!!  > 6 ==> a
!!  > 7 ==> 333|333
!!  > 8 ==>
!!  > 9 ==>
!!  > 10 ==>
!!  > 11 ==>
!!  > 12 ==> 1:|:2
!!  > 13 ==>
!!  > 14 ==> qrstuvwxyz
!!  > 15 ==> ghijklmnop
!!  > 16 ==>
!!  > 17 ==>
!!  > 18 ==> aBcdef
!!  > 19 ==>
!!  > 20 ==>
!!  >  SIZE:          20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_8="@(#) M_strings split(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iend(:)                ! positions in input string where tokens end
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: i20                    ! loop counters
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   call  slice(input_line,ibegin,iend,delimiters,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(nulls))then; nlls=trim(lower(adjustl(nulls))); else; nlls='ignore'    ; endif ! optional parameter
   if(present(order))then; ordr=trim(lower(adjustl(order))); else; ordr='sequential'; endif ! decide on value for ORDER parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ordr)                                             ! decide which order to store tokens
   case ('reverse','right') ; ii=size(ibegin) ; iiii=-1           ! last to first
   case default             ; ii=1            ; iiii=1            ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   imax=maxval(iend-ibegin+1)
   allocate(character(len=imax) :: array(size(ibegin)))           ! allocate the array to return
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,size(ibegin)                                          ! fill the array with the tokens that were found
      if(iend(i20) < ibegin(i20))then
         select case (nlls)
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iend(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    slice(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine slice(input_line,ibegin,iend,delimiters,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     integer,allocatable,intent(out)          :: ibegin(:),iend(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: nulls
!!
!!##DESCRIPTION
!!     slice(3f) parses a string using specified delimiter characters and
!!     store token beginning and ending positions into allocatable arrays
!!
!!##OPTIONS
!!    INPUT_LINE   Input string to tokenize
!!
!!    IBEGIN,IEND  arrays containing start and end positions of tokens.
!!                 IEND(I)<IBEGIN(I) designates a null token.
!!
!!    DELIMITERS   List of delimiter characters.
!!                 The default delimiters are the "whitespace" characters
!!                 (space, tab,new line, vertical tab, formfeed, carriage
!!                 return, and null). You may specify an alternate set of
!!                 delimiter characters.
!!
!!                 Multi-character delimiters are not supported (Each
!!                 character in the DELIMITERS list is considered to be
!!                 a delimiter).
!!
!!                 Quoting of delimiter characters is not supported.
!!
!!    NULLS="IGNORE"|"RETURN"|"IGNOREEND"  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_slice
!!     use M_strings, only: slice
!!     implicit none
!!     integer :: i
!!     character(len=*),parameter     :: &
!!     & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!     integer,allocatable :: ibegin(:), iend(:) ! output arrays of positions
!!     character(len=*),parameter :: title='(80("="),t1,a)'
!!        write(*,*)'INPUT LINE:['//line//']'
!!        !
!!        write(*,title)'typical call: '
!!        call slice(line,ibegin,iend)
!!        call printme()
!!        !
!!        write(*,title)'custom list of delimiters=":|" : '
!!        call slice(line,ibegin,iend,delimiters=':|',nulls='ignore')
!!        call printme()
!!        !
!!        write(*,title)'delimiters=":|", and count null fields: '
!!        call slice(line,ibegin,iend,delimiters=':|',nulls='return')
!!        call printme()
!!        !
!!        write(*,title)'default delimiters and return null fields: '
!!        call slice(line,ibegin,iend,delimiters='',nulls='return')
!!        call printme()
!!     contains
!!     subroutine printme()
!!        write(*,'((*(:/,3x,"[",g0,"]")))')&
!!                & (line(ibegin(i):iend(i)),i=1,size(ibegin))
!!        write(*,'(*(g0,1x))')'SIZE:',size(ibegin)
!!     end subroutine printme
!!     end program demo_slice
!!
!! Results:
!!
!!  > INPUT LINE:
!!  > [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!  > typical call: ========================================================
!!  >
!!  >    [aBcdef]
!!  >    [ghijklmnop]
!!  >    [qrstuvwxyz]
!!  >    [1:|:2]
!!  >    [333|333]
!!  >    [a]
!!  >    [B]
!!  >    [cc]
!!  > SIZE: 8
!!  > custom list of delimiters=":|" : =====================================
!!  >
!!  >    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!  >    [2     333]
!!  >    [333 a B cc    ]
!!  > SIZE: 3
!!  > delimiters=":|", and count null fields: ==============================
!!  >
!!  >    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!  >    []
!!  >    []
!!  >    [2     333]
!!  >    [333 a B cc    ]
!!  > SIZE: 5
!!  > default delimiters and return null fields: ===========================
!!  >
!!  >    []
!!  >    []
!!  >    [aBcdef]
!!  >    []
!!  >    []
!!  >    [ghijklmnop]
!!  >    [qrstuvwxyz]
!!  >    []
!!  >    [1:|:2]
!!  >    []
!!  >    []
!!  >    []
!!  >    []
!!  >    [333|333]
!!  >    [a]
!!  >    [B]
!!  >    [cc]
!!  >    []
!!  >    []
!!  >    []
!!  > SIZE: 20
!! ======================================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine slice(input_line,ibegin,iend,delimiters,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_9="@(#) M_strings slice(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
integer,allocatable,intent(out)          :: ibegin(:)   ! positions in input string where tokens start
integer,allocatable,intent(out)          :: iend(:)     ! positions in input string where tokens end
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
!-----------------------------------------------------------------------------------------------------------------------------------
integer                         :: n                      ! max number of strings INPUT_LINE could slice into if all delimiter
character(len=:),allocatable    :: dlim                   ! string containing delimiter characters
character(len=:),allocatable    :: nlls                   ! string containing nulls keyword
integer                         :: icount                 ! number of tokens found
integer                         :: ii                     ! loop parameters used to control print order
integer                         :: lgth                   ! length of input string with trailing spaces trimmed
integer                         :: i10,i20,i30            ! loop counters
integer                         :: icol                   ! pointer into input string as it is being parsed
integer                         :: idlim                  ! number of delimiter characters
integer                         :: ifound                 ! where next delimiter character is found in remaining input string data
integer                         :: inotnull               ! count strings not composed of delimiters
integer                         :: ireturn                ! number of tokens returned
integer                         :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could slice into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ?
   if(allocated(iend))deallocate(iend)      !x! intel compiler says allocated already ?
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iend(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iend(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   lgth=len(input_line)                                           ! lgth is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lgth > 0)then                                              ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,lgth,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iend(i30)=lgth                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):lgth),dlim(i10:i10))
               IF(ifound > 0)then
                  iend(i30)=min(iend(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iend(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iend(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iend(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > lgth)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   ii=0
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iend(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            ii=ii+1
            ibegin(ii)=ibegin(i20)
            iend(ii)=iend(i20)
         end select
      else
         ii=ii+1
         ibegin(ii)=ibegin(i20)
         iend(ii)=iend(i20)
      endif
   enddo
   ibegin=ibegin(:ii)
   iend=iend(:ii)
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine slice
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    chomp(3f) - [M_strings:TOKENS] Tokenize a string, consuming it one
!!    token per call
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function chomp(source_string,token[,delimiters])
!!
!!     character(len=*)                     :: source_string
!!     character(len=:),intent(out)         :: token
!!     character(len=:),intent(in),optional :: delimiters
!!     integer                              :: chomp
!!
!!##DESCRIPTION
!!    The CHOMP(3f) function is used to isolate sequential tokens in a
!!    string, SOURCE_STRING. These tokens are delimited in the string by at
!!    least one of the characters in DELIMITERS. This routine consumes the
!!    source_string one token per call. It returns -1 when complete. The
!!    default delimiter list is "space,tab,carriage return,newline".
!!
!!##OPTIONS
!!     SOURCE_STRING  string to tokenize
!!     DELIMITERS     list of separator characters
!!
!!##RETURNS
!!     TOKEN          returned token
!!     CHOMP          status flag. 0 = success, -1 = no tokens remain
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_chomp
!!
!!    use M_strings, only : chomp
!!    implicit none
!!    character(len=100)            :: inline
!!    character(len=:),allocatable  :: token
!!    character(len=*),parameter    :: delimiters=' ;,'
!!    integer                       :: ios
!!    integer                       :: icount
!!    integer                       :: itoken
!!       icount=0
!!       do        ! read lines from stdin until end-of-file or error
!!          read (unit=*,fmt="(a)",iostat=ios) inline
!!          if(ios /= 0)stop
!!          icount=icount+1
!!          itoken=0
!!          write(*,*)'INLINE ',trim(inline)
!!          do while ( chomp(inline,token,delimiters) >=  0)
!!             itoken=itoken+1
!!             print *, itoken,'TOKEN=['//trim(token)//']'
!!          enddo
!!       enddo
!!
!!    end program demo_chomp
!!
!!   sample input file
!!
!!     this is a test of chomp; A:B :;,C;;
!!
!!   sample output file
!!
!!     > INLINE     this is a test of chomp; A:B :;,C;;
!!     >           1 TOKEN=[this]
!!     >           2 TOKEN=[is]
!!     >           3 TOKEN=[a]
!!     >           4 TOKEN=[test]
!!     >           5 TOKEN=[of]
!!     >           6 TOKEN=[chomp]
!!     >           7 TOKEN=[A:B]
!!     >           8 TOKEN=[:]
!!     >           9 TOKEN=[C]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION chomp(source_string,token,delimiters)

! ident_10="@(#) M_strings chomp(3f) Tokenize a string JSU- 20151030"

character(len=*)                         :: source_string    ! string to tokenize
character(len=:),allocatable,intent(out) :: token            ! returned token
character(len=*),intent(in),optional     :: delimiters       ! list of separator characters
integer                                  :: chomp            ! returns copy of shifted source_string
character(len=:),allocatable             :: delimiters_local
integer                                  :: token_start      ! beginning of token found if function result is .true.
integer                                  :: token_end        ! end of token found if function result is .true.
integer                                  :: isource_len
!-----------------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(present(delimiters))then
      delimiters_local=delimiters
   else                                          ! increment start to previous end + 1
      delimiters_local=char(32)//char(09)//char(10)//char(13) ! space,horizontal tab, newline, carriage return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   token_start=1
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)                         ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
   !write(*,*)'TOKEN_START ',token_start
   !write(*,*)'TOKEN_END   ',token_end
   chomp=isource_len-token_end
   if(chomp >= 0)then
      token=source_string(token_start:token_end)
      source_string=source_string(token_end+1:)
   else
      token=''
      source_string=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function chomp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      delim(3f) - [M_strings:TOKENS] parse a string and store tokens into
!!      an array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)
!!
!!     character(len=*),intent(in)  :: line
!!     integer,integer(in)          :: n
!!     integer,intent(out)          :: icount
!!     character(len=*)             :: array(n)
!!     integer,intent(out)          :: ibegin(n)
!!     integer,intent(out)          :: iterm(n)
!!     integer,intent(out)          :: lgth
!!     character(len=*)             :: dlim
!!
!!##DESCRIPTION
!!      Given a LINE of structure " par1 par2 par3 ... parn "
!!      store each par(n) into a separate variable in ARRAY (UNLESS
!!      ARRAY(1) == '#N#')
!!
!!      Also set ICOUNT to number of elements of array initialized, and
!!      return beginning and ending positions for each element in IBEGIN(N)
!!      and ITERM(N).
!!
!!      Return position of last non-blank character (even if more
!!      than N elements were found) in lgth
!!
!!      No quoting or escaping of delimiter is allowed, so the delimiter
!!      character can not be placed in a token.
!!
!!      No checking for more than N parameters; If any more they are ignored.
!!
!!      This routine originates pre-Fortran90. A version using optional parameters
!!      and allocatable arrays is on the TODO list.
!!
!!##OPTIONS
!!    LINE       input string to parse into tokens
!!    ARRAY(N)   array that receives tokens
!!    N          size of arrays ARRAY, IBEGIN, ITERM
!!    ICOUNT     number of tokens found
!!    IBEGIN(N)  starting columns of tokens found
!!    ITERM(N)   ending columns of tokens found
!!    LGTH       position of last non-blank character in input string LINE
!!    DLIM       delimiter characters
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_delim
!!
!!     use M_strings, only: delim
!!     implicit none
!!     character(len=80) :: line
!!     character(len=80) :: dlm
!!     integer,parameter :: n=80
!!     character(len=20) :: array(n)=' '
!!     integer           :: ibegin(n),iterm(n)
!!     integer           :: i20, icount, lgth, i10,i30
!!     line=' first  second 10.3 words_of_stuff  '
!!     do i20=1,4
!!        ! change delimiter list and what is calculated or parsed
!!        if(i20 == 1)dlm=' '
!!        if(i20 == 2)dlm='o'
!!        if(i20 == 3)dlm=' aeiou'    ! NOTE SPACE IS FIRST
!!        if(i20 == 3)ARRAY(1)='#N#'  ! QUIT RETURNING STRING ARRAY
!!        if(i20 == 4)line='AAAaBBBBBBbIIIIIi  J K L'
!!
!!        ! write out a break line composed of =========== ..
!!        write(*,'(57("="))')
!!        ! show line being parsed
!!        write(*,'(a)')'PARSING=['//trim(line)//'] on '//trim(dlm)
!!        ! call parsing procedure
!!        call delim(line,array,n,icount,ibegin,iterm,lgth,dlm)
!!        write(*,*)'number of tokens found=',icount
!!        write(*,*)'last character in column ',lgth
!!        if(icount > 0)then
!!           if(lgth /= iterm(icount))then
!!              write(*,*)'ignored from column ',iterm(icount)+1,' to ',lgth
!!           endif
!!           do i10=1,icount
!!              ! check flag to see if ARRAY() was set
!!              if(array(1) /= '#N#')then
!!                 ! from returned array
!!                 write(*,'(a,a,a)',advance='no')&
!!                 &'[',array(i10)(:iterm(i10)-ibegin(i10)+1),']'
!!              endif
!!           enddo
!!           ! using start and end positions in IBEGIN() and ITERM()
!!           write(*,*)
!!           do i10=1,icount
!!              ! from positions in original line
!!              write(*,'(a,a,a)',advance='no')&
!!              &'[',line(ibegin(i10):iterm(i10)),']'
!!           enddo
!!           write(*,*)
!!        endif
!!     enddo
!!        line='four    score and   seven  years ago'
!!        call delim(line,["#N#"],n,icount,ibegin,iterm,lgth,' ')
!!        do i30=1,icount
!!           write(*,*)ibegin(i30),iterm(i30),&
!!           & '['//line(ibegin(i30):iterm(i30))//']'
!!        enddo
!!
!!     end program demo_delim
!!
!! Results:
!!
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on
!!  >  number of tokens found=           4
!!  >  last character in column           34
!!  > [first][second][10.3][words_of_stuff]
!!  > [first][second][10.3][words_of_stuff]
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on o
!!  >  number of tokens found=           4
!!  >  last character in column           34
!!  > [ first  sec][nd 10.3 w][rds_][f_stuff]
!!  > [ first  sec][nd 10.3 w][rds_][f_stuff]
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on  aeiou
!!  >  number of tokens found=          10
!!  >  last character in column           34
!!  >
!!  > [f][rst][s][c][nd][10.3][w][rds_][f_st][ff]
!!  > =========================================================
!!  > PARSING=[AAAaBBBBBBbIIIIIi  J K L] on  aeiou
!!  >  number of tokens found=           5
!!  >  last character in column           24
!!  >
!!  > [AAA][BBBBBBbIIIII][J][K][L]
!!  >            1           4 [four]
!!  >            9          13 [score]
!!  >           15          17 [and]
!!  >           21          25 [seven]
!!  >           28          32 [years]
!!  >           34          36 [ago]
!! ================================================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)

! ident_11="@(#) M_strings delim(3f) parse a string and store tokens into an array"

!
!     given a line of structure " par1 par2 par3 ... parn "
!     store each par(n) into a separate variable in array.
!
!     IF ARRAY(1) == '#N#' do not store into string array  (KLUDGE))
!
!     also count number of elements of array initialized, and
!     return beginning and ending positions for each element.
!     also return position of last non-blank character (even if more
!     than n elements were found).
!
!     no quoting of delimiter is allowed
!     no checking for more than n parameters, if any more they are ignored
!
character(len=*),intent(in)    :: line
integer,intent(in)             :: n
character(len=*)               :: array(n)
integer,intent(out)            :: icount
integer,intent(out)            :: ibegin(n)
integer,intent(out)            :: iterm(n)
integer,intent(out)            :: lgth
character(len=*),intent(in)    :: dlim
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(line)):: line_local
logical             :: lstore
integer             :: i10
integer             :: iarray
integer             :: icol
integer             :: idlim
integer             :: iend
integer             :: ifound
integer             :: istart
!-----------------------------------------------------------------------------------------------------------------------------------
      icount=0
      lgth=len_trim(line)
      line_local=line

      idlim=len(dlim)
      if(idlim > 5)then
         idlim=len_trim(dlim)      ! dlim a lot of blanks on some machines if dlim is a big string
         if(idlim == 0)then
            idlim=1     ! blank string
         endif
      endif

      if(lgth == 0)then                                        ! command was totally blank
         return
      endif
!
!     there is at least one non-blank character in the command
!     lgth is the column position of the last non-blank character
!     find next non-delimiter
      icol=1

      if(array(1) == '#N#')then                                ! special flag to not store into character array
         lstore=.false.
      else
         lstore=.true.
      endif

      do iarray=1,n,1                                          ! store into each array element until done or too many words
         NOINCREMENT: do
            if(index(dlim(1:idlim),line_local(icol:icol)) == 0)then  ! if current character is not a delimiter
               istart=icol                                     ! start new token on the non-delimiter character
               ibegin(iarray)=icol
               iend=lgth-istart+1+1                            ! assume no delimiters so put past end of line
               do i10=1,idlim
                  ifound=index(line_local(istart:lgth),dlim(i10:i10))
                  if(ifound > 0)then
                     iend=min(iend,ifound)
                  endif
               enddo
               if(iend <= 0)then                               ! no remaining delimiters
                 iterm(iarray)=lgth
                 if(lstore)then
                    array(iarray)=line_local(istart:lgth)
                 endif
                 icount=iarray
                 return
               else
                 iend=iend+istart-2
                 iterm(iarray)=iend
                 if(lstore)then
                    array(iarray)=line_local(istart:iend)
                 endif
               endif
               icol=iend+2
               exit NOINCREMENT
            endif
            icol=icol+1
         enddo NOINCREMENT
!        last character in line was a delimiter, so no text left
!        (should not happen where blank=delimiter)
         if(icol > lgth)then
           icount=iarray
           if( (iterm(icount)-ibegin(icount)) < 0)then         ! last token was all delimiters
              icount=icount-1
           endif
           return
         endif
      enddo
      icount=n  ! more than n elements
end subroutine delim
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_strings:EDITING] function replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!! syntax:
!!
!!      function replace(targetline,old,new,cmd,&
!!       & occurrence, &
!!       & repeat, &
!!       & ignorecase, &
!!       & ierr) result (newline)
!!      character(len=*)                       :: targetline
!!      character(len=*),intent(in),optional   :: old
!!      character(len=*),intent(in),optional   :: new
!!      character(len=*),intent(in),optional   :: cmd
!!      integer,intent(in),optional            :: occurrence
!!      integer,intent(in),optional            :: repeat
!!      logical,intent(in),optional            :: ignorecase
!!      integer,intent(out),optional           :: ierr
!!      character(len=:),allocatable           :: newline
!!
!!##DESCRIPTION
!!    Replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     cmd         alternate way to specify old and new string, in
!!                 the form c/old/new/; where "/" can be any character
!!                 not in "old" or "new".
!!     occurrence  if present, start changing at the Nth occurrence of the
!!                 OLD string. If negative start replacing from the left
!!                 end of the string.
!!     repeat      number of replacements to perform. Defaults to a global
!!                 replacement.
!!     ignorecase  whether to ignore ASCII case or not. Defaults
!!                 to .false. .
!!##RETURNS
!!     newline     allocatable string returned
!!     ierr        error code. iF ier = -1 bad directive, >= 0 then
!!                 count of changes made.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_replace
!!    use M_strings, only : replace
!!    implicit none
!!    character(len=:),allocatable :: line
!!
!!    write(*,*)replace('Xis is Xe string','X','th')
!!    write(*,*)replace('Xis is xe string','x','th',ignorecase=.true.)
!!    write(*,*)replace('Xis is xe string','X','th',ignorecase=.false.)
!!
!!    ! a null old substring means "at beginning of line"
!!    write(*,*) replace('my line of text','','BEFORE:')
!!
!!    ! a null new string deletes occurrences of the old substring
!!    write(*,*) replace('I wonder i ii iii','i','')
!!
!!    ! Examples of the use of RANGE
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=1,repeat=1)
!!    write(*,*)'replace first a with A ['//line//']'
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=3,repeat=3)
!!    write(*,*)'replace a with A for 3rd to 5th occurrence ['//line//']'
!!
!!    line=replace('ababababa','a','',occurrence=3,repeat=3)
!!    write(*,*)'replace a with null instances 3 to 5 ['//line//']'
!!
!!    line=replace( &
!!     & 'a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!     & 'aa','CCCC',occurrence=-1,repeat=1)
!!    write(*,*)'replace lastaa with CCCC ['//line//']'
!!
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-1,repeat=1)
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-2,repeat=2)
!!
!!    end program demo_replace
!!
!!   Results:
!!
!!     this is the string
!!     this is the string
!!     this is xe string
!!     BEFORE:my line of text
!!     I wonder
!!     replace first a with A [Aaaaaaaaa]
!!     replace a with A for 3rd to 5th occurrence [aaAAAaaaa]
!!     replace a with null instances 3 to 5 [ababbb]
!!     replace lastaa with CCCC [a b ab baaa aaaa aa aa a a a aa aaaaCCCC]
!!     myf90stuff.f90.for
!!     myforstuff.for.f90
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine crack_cmd(cmd,old,new,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)              :: cmd
character(len=:),allocatable,intent(out) :: old,new                ! scratch string buffers
integer                                  :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=1)                         :: delimiters
integer                                  :: itoken
integer,parameter                        :: id=2                   ! expected location of delimiter
logical                                  :: ifok
integer                                  :: lmax                   ! length of target string
integer                                  :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   old=''
   new=''
   lmax=len_trim(cmd)                       ! significant length of change directive

   if(lmax >= 4)then                      ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)               ! find delimiter in expected location
      itoken=0                            ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*crack_cmd* incorrect change directive -too short')
   endif

end subroutine crack_cmd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function replace(targetline,old,new,cmd,occurrence,repeat,ignorecase,ierr) result (newline)

! ident_12="@(#) M_strings replace(3f) replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in),optional   :: old          ! old substring to replace
character(len=*),intent(in),optional   :: new          ! new substring
character(len=*),intent(in),optional   :: cmd          ! contains the instructions changing the string
integer,intent(in),optional            :: occurrence   ! Nth occurrence of OLD string to start replacement at
integer,intent(in),optional            :: repeat       ! how many replacements
logical,intent(in),optional            :: ignorecase
integer,intent(out),optional           :: ierr         ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
character(len=:),allocatable  :: new_local, old_local, old_local_for_comparison
integer                       :: icount,ichange,ier2
integer                       :: original_input_length
integer                       :: len_old, len_new
integer                       :: ladd
integer                       :: left_margin, right_margin
integer                       :: ind
integer                       :: ic
integer                       :: ichr
integer                       :: range_local(2)
character(len=:),allocatable  :: targetline_for_comparison   ! input line to be changed
logical                       :: ignorecase_local
logical                       :: flip
character(len=:),allocatable  :: targetline_local   ! input line to be changed
!-----------------------------------------------------------------------------------------------------------------------------------
   flip=.false.
   ignorecase_local=.false.
   original_input_length=len_trim(targetline)          ! get non-blank length of input line

!  get old_local and new_local from cmd or old and new
   if(present(cmd))then
      call crack_cmd(cmd,old_local,new_local,ier2)
      if(ier2 /= 0)then
         newline=targetline  ! if no changes are made return original string on error
         if(present(ierr))ierr=ier2
         return
      endif
   elseif(present(old).and.present(new))then
      old_local=old
      new_local=new
   else
      newline=targetline  ! if no changes are made return original string on error
      call journal('sc','*replace* must specify OLD and NEW or CMD')
      return
   endif
   if(present(ignorecase))then
      ignorecase_local=ignorecase
   else
      ignorecase_local=.false.
   endif
   if(present(occurrence))then
      range_local(1)=abs(occurrence)
   else
      range_local(1)=1
   endif
   if(present(repeat))then
      range_local(2)=range_local(1)+repeat-1
   else
      range_local(2)=original_input_length
   endif
   if(ignorecase_local)then
      targetline_for_comparison=lower(targetline)
      old_local_for_comparison=lower(old_local)
   else
      targetline_for_comparison=targetline
      old_local_for_comparison=old_local
   endif
   if(present(occurrence))then
      if(occurrence < 0)then
         flip=.true.
         targetline_for_comparison=reverse(targetline_for_comparison)
         targetline_local=reverse(targetline)
         old_local_for_comparison=reverse(old_local_for_comparison)
         old_local=reverse(old_local)
         new_local=reverse(new_local)
      else
         targetline_local=targetline
      endif
   else
      targetline_local=targetline
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   len_old=len(old_local)                              ! length of old substring to be replaced
   len_new=len(new_local)                              ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(len_new > 0)then
         newline=new_local(:len_new)//targetline_local(left_margin:original_input_length)
      else
         newline=targetline_local(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      if(flip) newline=reverse(newline)
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=left_margin                                    ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
                                                       ! try finding start of OLD in remaining part of input in change window
      ind=index(targetline_for_comparison(ic:),old_local_for_comparison(:len_old))+ic-1
      if(ind == ic-1.or.ind > right_margin)then       ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:ichr-1)//targetline_local(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(icount >= range_local(1).and.icount <= range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new /= 0)then                                          ! put in new string
            newline=newline(:ichr-1)//new_local(:len_new)
            ichr=ichr+len_new
         endif
      else
         if(len_old /= 0)then                                          ! put in copy of old string
            newline=newline(:ichr-1)//old_local(:len_old)
            ichr=ichr+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline_local                         ! if no changes made output should be input
   case default
      if(ic <= len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:ichr-1)//targetline_local(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
   if(flip) newline=reverse(newline)
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes
!!    one substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine substitute(targetline,old,new,ierr,start,end)
!!
!!     character(len=*)              :: targetline
!!     character(len=*),intent(in)   :: old
!!     character(len=*),intent(in)   :: new
!!     integer,intent(out),optional  :: ierr
!!     integer,intent(in),optional   :: start
!!     integer,intent(in),optional   :: end
!!
!!##DESCRIPTION
!!    Globally substitute one substring for another in string.
!!
!!##OPTIONS
!!     TARGETLINE  input line to be changed. Must be long enough to
!!                 hold altered output.
!!     OLD         substring to find and replace
!!     NEW         replacement for OLD substring
!!     IERR        error code. If IER = -1 bad directive, >= 0 then
!!                 count of changes made.
!!     START       sets the left margin to be scanned for OLD in
!!                 TARGETLINE.
!!     END         sets the right margin to be scanned for OLD in
!!                 TARGETLINE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_substitute
!!    use M_strings, only : substitute
!!    implicit none
!!    ! must be long enough to hold changed line
!!    character(len=80) :: targetline
!!
!!    targetline='this is the input string'
!!    write(*,*)'ORIGINAL    : '//trim(targetline)
!!
!!    ! changes the input to 'THis is THe input string'
!!    call substitute(targetline,'th','TH')
!!    write(*,*)'th => TH    : '//trim(targetline)
!!
!!    ! a null old substring means "at beginning of line"
!!    ! changes the input to 'BEFORE:this is the input string'
!!    call substitute(targetline,'','BEFORE:')
!!    write(*,*)'"" => BEFORE: '//trim(targetline)
!!
!!    ! a null new string deletes occurrences of the old substring
!!    ! changes the input to 'ths s the nput strng'
!!    call substitute(targetline,'i','')
!!    write(*,*)'i => ""     : '//trim(targetline)
!!
!!    end program demo_substitute
!!
!!   Expected output
!!
!!     ORIGINAL    : this is the input string
!!     th => TH    : THis is THe input string
!!     "" => BEFORE: BEFORE:THis is THe input string
!!     i => ""     : BEFORE:THs s THe nput strng
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine substitute(targetline,old,new,ierr,start,end)

! ident_13="@(#) M_strings substitute(3f) Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichr
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option ! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id <= 0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(ichr > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind == ic-1.or.ind > ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichr-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichr:)=targetline(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(ichr-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichr:)=new(:len_new)
         ichr=ichr+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichr+ladd > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichr:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    change(3f) - [M_strings:EDITING] change old string to new string with
!!    a directive like a line editor
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine change(target_string,cmd,ierr)
!!
!!     character(len=*),intent(inout) :: target_string
!!     character(len=*),intent(in)    :: cmd
!!     integer                        :: ierr
!!
!!##DESCRIPTION
!!    change an old substring into a new substring in a character variable
!!    like a line editor. Primarily used to create interactive utilities
!!    such as input history editors for interactive line-mode programs. The
!!    output string is assumed long enough to accommodate the change.
!!    a directive resembles a line editor directive of the form
!!
!!       C/old_string/new_string/
!!
!!    where / may be any character which is not included in old_string
!!    or new_string.
!!
!!    a null old_string implies "beginning of string".
!!
!!##OPTIONS
!!    target_string  line to be changed
!!    cmd            contains instructions to change the string
!!    ierr           error code.
!!
!!       o =-1 bad directive
!!       o =0 no changes made
!!       o >0 count of changes made
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_change
!!
!!     use M_strings, only : change
!!     implicit none
!!     character(len=132) :: line='This is a test string to change'
!!     integer            :: ierr
!!        write(*,*)trim(line)
!!        ! change miniscule a to uppercase A
!!        call change(line,'c/a/A/',ierr)
!!        write(*,*)trim(line)
!!        ! put string at beginning of line
!!        call change(line,'c//prefix: /',ierr)
!!        write(*,*)trim(line)
!!        ! remove blanks
!!        call change(line,'c/ //',ierr)
!!        write(*,*)trim(line)
!!    end program demo_change
!!
!!   Expected output
!!
!!     This is a test string to change
!!     This is A test string to chAnge
!!     prefix: This is A test string to chAnge
!!     prefix:ThisisAteststringtochAnge
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine change(target_string,cmd,ierr)
! Change a string assumed long enough to accommodate the change, with a directive that resembles a line editor directive of the form
!    C/old_string/new_string/
! where / may be any character which is not included in old_string or new_string.
! a null old_string implies "beginning of string"
!===================================================================================================================================

! ident_14="@(#) M_strings change(3f) change a character string like a line editor"

character(len=*),intent(inout)   :: target_string          ! line to be changed
character(len=*),intent(in)      :: cmd                    ! contains the instructions changing the string
character(len=1)                 :: delimiters
integer                          :: ierr                   ! error code. ier=-1 bad directive;=0 no changes made;>0 ier changes made
integer                          :: itoken
integer,parameter                :: id=2                   ! expected location of delimiter
character(len=:),allocatable     :: old,new                ! scratch string buffers
logical                          :: ifok
integer                          :: lmax                   ! length of target string
integer                          :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   lmax=len_trim(cmd)                                                          ! significant length of change directive
   if(lmax >= 4)then                         ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)                                                    ! find delimiter in expected location
      itoken=0                                                                 ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif

      call substitute(target_string,old,new,ierr,1,len_trim(target_string))    ! change old substrings to new substrings
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*change* incorrect change directive -too short')
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine change
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     strtok(3f) - [M_strings:TOKENS] Tokenize a string
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!  function strtok(source_string,itoken,token_start,token_end,delimiters)
!!  result(strtok_status)
!!
!!   ! returned value
!!   logical                      :: strtok_status
!!   ! string to tokenize
!!   character(len=*),intent(in)  :: source_string
!!   ! token count since started
!!   integer,intent(inout)        :: itoken
!!   ! beginning of token
!!   integer,intent(out)          :: token_start
!!   ! end of token
!!   integer,intent(inout)        :: token_end
!!   ! list of separator characters
!!   character(len=*),intent(in)  :: delimiters
!!
!!##DESCRIPTION
!!     The STRTOK(3f) function is used to isolate sequential tokens in a
!!     string, SOURCE_STRING. These tokens are delimited in the string by
!!     at least one of the characters in DELIMITERS. The first time that
!!     STRTOK(3f) is called, ITOKEN should be specified as zero. Subsequent
!!     calls, wishing to obtain further tokens from the same string,
!!     should pass back in TOKEN_END  and ITOKEN until the function result
!!     returns .false.
!!
!!     This routine assumes no other calls are made to it using any other
!!     input string while it is processing an input line.
!!
!!##OPTIONS
!!     source_string  input string to parse
!!     itoken         token count should be set to zero for a new string
!!     delimiters     characters used to determine the end of tokens
!!
!!##RETURN
!!     token_start    beginning position in SOURCE_STRING where token was found
!!     token_end      ending position in SOURCE_STRING where token was found
!!     strtok_status
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_strtok
!!     use M_strings, only : strtok
!!     implicit none
!!     character(len=264)          :: inline
!!     character(len=*),parameter  :: delimiters=' ;,'
!!     integer                     :: ios, itoken, ibegin, iend
!!        do ! read lines from stdin until end-of-file or error
!!           read (unit=*,fmt="(a)",iostat=ios) inline
!!           if(ios /= 0)stop
!!           ! must set ITOKEN=0 before looping on strtok(3f)
!!           ! on a new string.
!!           itoken=0
!!           do while &
!!           &( strtok(inline,itoken,ibegin,iend,delimiters) )
!!              print *, itoken,&
!!              & 'TOKEN=['//(inline(ibegin:iend))//']',ibegin,iend
!!           enddo
!!        enddo
!!     end program demo_strtok
!!
!!     sample input file
!!
!!      this is a test of strtok; A:B :;,C;;
!!
!!     sample output file
!!
!!     1  TOKEN=[this]    2   5
!!     2  TOKEN=[is]      7   8
!!     3  TOKEN=[a]       10  10
!!     4  TOKEN=[test]    12  15
!!     5  TOKEN=[of]      17  18
!!     6  TOKEN=[strtok]  20  25
!!     7  TOKEN=[A:B]     28  30
!!     8  TOKEN=[:]       32  32
!!     9  TOKEN=[C]       35  35
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)
! JSU- 20151030

! ident_15="@(#) M_strings strtok(3f) Tokenize a string"

character(len=*),intent(in)  :: source_string    ! Source string to tokenize.
character(len=*),intent(in)  :: delimiters       ! list of separator characters. May change between calls
integer,intent(inout)        :: itoken           ! token count since started
logical                      :: strtok_status    ! returned value
integer,intent(out)          :: token_start      ! beginning of token found if function result is .true.
integer,intent(inout)        :: token_end        ! end of token found if function result is .true.
integer,save                 :: isource_len
!----------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(itoken <= 0)then                           ! this is assumed to be the first call
      token_start=1
   else                                          ! increment start to previous end + 1
      token_start=token_end+1
   endif
!----------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!----------------------------------------------------------------------------------------------------------------------------
   if(token_start > isource_len)then            ! user input error or at end of string
      token_end=isource_len                      ! assume end of token is end of string until proven otherwise so it is set
      strtok_status=.false.
      return
   endif
!----------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   if (token_start  >  isource_len) then        ! determine if finished
      strtok_status=.false.                      ! flag that input string has been completely processed
   else
      itoken=itoken+1                            ! increment count of tokens found
      strtok_status=.true.                       ! flag more tokens may remain
   endif
!----------------------------------------------------------------------------------------------------------------------------
end function strtok
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    modif(3f) - [M_strings:EDITING] emulate the MODIFY command from the
!!    line editor XEDIT
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine modif(cline,cmod)
!!
!!     character(len=*) :: cline ! input string to change
!!     ! directive provides directions on changing string
!!     character(len=*) :: cmod
!!
!!##DESCRIPTION
!!   MODIF(3f) Modifies the line currently pointed at using a directive
!!   that acts much like a line editor directive.
!!   Primarily used to create interactive utilities such as input history
!!   editors for interactive line-mode programs.
!!
!!   the modify directives are as follows-
!!
!!    DIRECTIVE EXPLANATION
!!
!!    ^STRING#   Causes the string of characters between the ^ and the
!!               next # to be inserted before the characters pointed to
!!               by the ^. an ^ or & within the string is treated as a
!!               regular character. If the closing # is not specified,
!!               MODIF(3f) inserts the remainder of the line as if a # was
!!               specified after the last nonblank character.
!!
!!               There are two exceptions. the combination ^# causes a #
!!               to be inserted before the character pointed to by the
!!               ^, and an ^ as the last character of the directives
!!               causes a blank to be inserted.
!!
!!    #          (When not the first # after an ^) causes the character
!!               above it to be deleted.
!!
!!    &          Replaces the character above it with a space.
!!
!!    (SPACE)    A space below a character leaves it unchanged.
!!
!!    Any other character replaces the character above it.
!!
!!##EXAMPLES
!!
!!   Example input/output:
!!
!!    THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
!!    THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
!!    ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!!
!!   Sample program:
!!
!!    program demo_modif
!!    use M_strings, only : modif
!!    implicit none
!!    character(len=256)           :: line
!!    integer                      :: ios
!!    integer                      :: count
!!    integer                      :: COMMAND_LINE_LENGTH
!!    character(len=:),allocatable :: COMMAND_LINE
!!       ! get command name length
!!       call get_command_argument(0,length=count)
!!       ! get command line length
!!       call get_command(length=COMMAND_LINE_LENGTH)
!!       ! allocate string big enough to hold command line
!!       allocate(character(len=COMMAND_LINE_LENGTH+200) :: COMMAND_LINE)
!!       ! get command line as a string
!!       call get_command(command=COMMAND_LINE)
!!       ! trim leading spaces just in case
!!       COMMAND_LINE=adjustl(COMMAND_LINE)
!!       ! remove command name
!!       COMMAND_LINE=adjustl(COMMAND_LINE(COUNT+2:))
!!       INFINITE: do
!!          read(*,'(a)',iostat=ios)line
!!          if(ios /= 0)exit
!!          call modif(line,COMMAND_LINE)
!!          write(*,'(a)')trim(line)
!!       enddo INFINITE
!!    end program demo_modif
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine modif(cline,mod)

!$@(#) M_strings::modif(3f): Emulate the MODIFY command from the line editor XEDIT

!
! MODIF
! =====
! ACTION- MODIFIES THE LINE CURRENTLY POINTED AT. THE INPUT STRING CLINE IS ASSUMED TO BE LONG ENOUGH TO ACCOMMODATE THE CHANGES
!         THE MODIFY DIRECTIVES ARE AS FOLLOWS-
!
!   DIRECTIVE                       EXPLANATION
!   ---------                       ------------
!   ^STRING#   CAUSES THE STRING OF CHARACTERS BETWEEN THE ^ AND THE
!              NEXT  # TO BE INSERTED BEFORE THE CHARACTERS POINTED TO
!              BY THE ^. AN ^ OR & WITHIN THE STRING IS TREATED AS A
!              REGULAR CHARACTER. IF THE CLOSING # IS NOT SPECIFIED,
!              MODIF(3f) INSERTS THE REMAINDER OFTHELINE AS IF A # WAS
!              SPECIFIED AFTER THE LAST NONBLANK CHARACTER.
!
!              THERE ARE TWO EXCEPTIONS. THE COMBINATION ^# CAUSES A #
!              TO BE INSERTED BEFORE THE CHARACTER POINTED TO BY THE
!              ^,  AND AN ^ AS THE LAST CHARACTER OF THE DIRECTIVES
!              CAUSES A BLANK TO BE INSERTED.
!
!   #          (WHEN NOT THE FIRST # AFTER AN ^) CAUSES THE CHARACTER
!              ABOVE IT TO BE DELETED.
!
!   &          REPLACES THE CHARACTER ABOVE IT WITH A SPACE.
!
!   (SPACE)    A SPACE BELOW A CHARACTER LEAVES IT UNCHANGED.
!
!   ANY OTHER CHARACTER REPLACES THE CHARACTER ABOVE IT.
!
! EXAMPLE-
! THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
! THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
! ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
character(len=*)            :: cline        !STRING TO BE MODIFIED
character(len=*),intent(in) :: mod          !STRING TO DIRECT MODIFICATION
character(len=len(cline))   :: cmod
character(len=3),parameter  :: c='#&^'      !ASSIGN DEFAULT EDIT CHARACTERS
integer                     :: maxscra      !LENGTH OF SCRATCH BUFFER
character(len=len(cline))   :: dum2         !SCRATCH CHARACTER BUFFER
logical                     :: linsrt       !FLAG FOR INSERTING DATA ON LINE
integer :: i, j, ic, ichr, iend, lmax, lmx1
maxscra=len(cline)
   cmod=trim(mod)
   lmax=min0(len(cline),maxscra)         !DETERMINE MAXIMUM LINE LENGTH
   lmx1=lmax-1                           !MAX LINE LENGTH -1
   dum2=' '                              !INITIALIZE NEW LINE
   linsrt=.false.                        !INITIALIZE INSERT MODE
   iend=len_trim(cmod)                   !DETERMINE END OF MODS
   i=0                                   !CHAR COUNTER FOR MOD LINE CMOD
   ic=0                                  !CHAR COUNTER FOR CURRENT LINE CLINE
   ichr=0                                !CHAR COUNTER NEW LINE DUM2
11 continue
   i=i+1                                 !NEXT CHAR IN MOD LINE
   if(ichr > lmx1)goto 999              !IF TOO MANY CHARS IN NEW LINE
   if(linsrt) then                       !IF INSERTING NEW CHARS
      if(i > iend) cmod(i:i)=c(1:1)     !FORCE END OF INSERT MODE
      if(cmod(i:i) == c(1:1))then        !IF END OF INSERT MODE
         linsrt=.false.                  !RESET INSERT MODE FLAG
         if(ic+1 == i)then               !NULL INSERT STRING
            ichr=ichr+1                  !INCREMENT COUNTER FOR NEW LINE
            dum2(ichr:ichr)=c(1:1)       !INSERT INSERT MODE TERMINATOR
         endif
         do j=ic,i                       !LOOP OF NUMBER OF CHARS INSERTED
            ichr=ichr+1                  !INCREMENT COUNTER FOR NEW LINE
            if(ichr > lmax)goto 999     !IF AT BUFFER LIMIT, QUIT
            dum2(ichr:ichr)=cline(j:j)   !APPEND CHARS FROM ORIG LINE
         enddo                           !...WHICH ALIGN WITH INSERTED CHARS
         ic=i                            !RESET CHAR COUNT TO END OF INSERT
         goto 1                          !CHECK NEW LINE LENGTH AND CYCLE
      endif                              !END OF TERMINATED INSERT LOGIC
      ichr=ichr+1                        !INCREMENT NEW LINE COUNT
      dum2(ichr:ichr)=cmod(i:i)          !SET NEWLINE CHAR TO INSERTED CHAR
   else                                  !IF NOT INSERTING CHARACTERS
      ic=ic+1                            !INCREMENT ORIGINAL LINE COUNTER
      if(cmod(i:i) == c(1:1))goto 1      !IF DELETE CHAR. NO COPY AND CYCLE
      if(cmod(i:i) == c(3:3))then        !IF BEGIN INSERT MODE
         linsrt=.true.                   !SET INSERT FLAG TRUE
         goto 1                          !CHECK LINE LENGTH AND CONTINUE
      endif                              !IF NOT BEGINNING INSERT MODE
      ichr=ichr+1                        !INCREMENT NEW LINE COUNTER
      if(cmod(i:i) == c(2:2))then        !IF REPLACE WITH BLANK
         dum2(ichr:ichr)=' '             !SET NEWLINE CHAR TO BLANK
         goto 1                          !CHECK LINE LENGTH AND CYCLE
      endif                              !IF NOT REPLACE WITH BLANK
      if(cmod(i:i) == ' ')then           !IF BLANK, KEEP ORIGINAL CHARACTER
         dum2(ichr:ichr)=cline(ic:ic)    !SET NEW CHAR TO ORIGINAL CHAR
      else                               !IF NOT KEEPING OLD CHAR
         dum2(ichr:ichr)=cmod(i:i)       !REPLACE ORIGINAL CHAR WITH NEW
      endif                              !END CHAR KEEP OR REPLACE
   endif                                 !END INSERT OR NO-INSERT
1  continue
   if(i < lmax)goto 11                  !CHECK FOR END OF LINE REACHED
                                         !AND CYCLE IF OK
999   continue
   cline=dum2                            !SET ORIGINAL CHARS TO NEW CHARS
end subroutine modif                     !RETURN
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      len_white(3f) - [M_strings:LENGTH] get length of string trimmed
!!      of whitespace.
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    integer function len_white(string)
!!
!!     character(len=*) :: string
!!
!!##DESCRIPTION
!!      len_white(3f) returns the position of the last character in
!!      string that is not a whitespace character. The Fortran90 intrinsic
!!      LEN_TRIM() should be used when trailing whitespace can be assumed
!!      to always be spaces.
!!
!!      This procedure was heavily used in the past because ANSI FORTRAN
!!      77 character objects are fixed length and blank padded and the
!!      LEN_TRIM() intrinsic did not exist. It should now be used only when
!!      whitespace characters other than blanks are likely.
!!
!!##OPTIONS
!!      string     input string whose trimmed length is being calculated
!!                 ignoring all trailing whitespace characters.
!!##RETURNS
!!      len_white  the number of characters in the trimmed string
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_len_white
!!
!!      use M_strings, only : len_white
!!      implicit none
!!      character(len=80) ::  s
!!      integer           :: lgth, lastnb
!!      intrinsic len
!!
!!      s=' ABCDEFG abcdefg '
!!      lgth = len(s)
!!      lastnb = len_white(s)
!!
!!      write(*,*) 'total length of variable is ',lgth
!!      write(*,*) 'trimmed length of variable is ',lastnb
!!      write(*,*) 'trimmed string=[',s(:lastnb),']'
!!
!!     end program demo_len_white
!!
!!   Results:
!!
!!     total length of variable is           80
!!     trimmed length of variable is           16
!!     trimmed string=[ ABCDEFG abcdefg]
!!
!!##NOTES
!!
!! o len_white
!!
!!      is a resource-intensive routine. Once the end of
!!      the string is found, it is probably best to keep track of it in
!!      order to avoid repeated calls to len_white. Because they
!!      might be more efficient, consider looking for vendor-supplied or
!!      system-optimized equivalents. For example:
!!
!!         o lnblnk - Solaris f77
!!         o len_trim - FORTRAN 90
!!
!! o Some compilers seem to have trouble passing a string of variable
!!   length properly. To be safe, use something like this:
!!
!!       subroutine message(s)
!!        character(len=*) :: s ! s is of variable length
!!           lgth=len(s)        ! get total length of variable
!!           ! explicitly specify a substring instead of just variable name
!!           lastnb = len_white(s(:lgth))
!!           write(*,*)'error:[',s(:lastnb),']'
!!       end subroutine messages
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental integer function len_white(string)
!  DEPRECATED. Use len_trim(3f),trim(3f) unless you might have trailing nulls (common when interacting with C procedures)"
!  John S. Urban, 1984, 1997-12-31
!  Note that if the string is blank, a length of 0 is returned; which is not a legal string length in Fortran77.
!  this routine used to return one instead of zero.
!   - mod 1:     1994
!                added null (char(0)) because HP and some Suns not padding
!                strings with blank, but with null characters; 1994 JSU
!   - mod 2:     1999
!                update syntax with INTENT(), ENDDO, no RETURN
!                still need instead of LEN_TRIM() because some systems stil pad CHARACTER with NULL
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_16="@(#) M_strings len_white(3f) return position of last non-blank/non-null character in string"

character(len=*),intent(in):: string ! input string to determine length of
integer                    :: i10
intrinsic len
   len_white=0
   do i10=len(string),1,-1
      select case(string(i10:i10))
      case(' ')                 ! space(32)
      case(char(0))             ! null(0)
      case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13)
      case default
         len_white=i10
         exit
      end select
   enddo
end function len_white
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    crop(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks
!!               and control characters from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function crop(strin) result (strout)
!!
!!     character(len=*),intent(in)  :: strin
!!     character(len=:),allocatable :: strout
!!
!!##DESCRIPTION
!!    All control characters throughout the string are replaced with spaces
!!    and leading and trailing spaces are trimmed from the resulting string.
!!    Tabs are expanded assuming a stop every eight characters.
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing space and control
!!            characters from
!!
!!##RETURNS
!!    strout  cropped version of input string
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_crop
!!    use M_strings, only: crop
!!    implicit none
!!    character(len=20) ::  untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'cropped string=[',crop(untrimmed),']'
!!    end program demo_crop
!!
!!   Expected output
!!
!!      untrimmed string=[   ABCDEFG abcdefg                      ]
!!      cropped string=[ABCDEFG abcdefg]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function crop(strin) result (strout)

! ident_17="@(#) M_strings crop(3f) replace control characters with whitespace and trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(noesc(dilate(strin))))
end function crop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    clip(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function clip(strin) result (strout)
!!
!!     character(len=*),intent(in)  :: strin
!!     character(len=:),allocatable :: strout
!!
!!##DESCRIPTION
!!    leading and trailing spaces are trimmed from the resulting string.
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing space characters from
!!
!!##RETURNS
!!    strout  clipped version of input string
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_clip
!!    use M_strings, only: clip
!!    implicit none
!!    character(len=20) ::  untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'clipped string=[',clip(untrimmed),']'
!!    end program demo_clip
!!
!!   Expected output
!!
!!      untrimmed string=[   ABCDEFG abcdefg                      ]
!!      clipped string=[ABCDEFG abcdefg]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function clip(string) result(lopped)

! ident_18="@(#) M_strings clip(3f) trim leading and trailings spaces from resulting string"

logical,parameter            :: T=.true.,F=.false.
character(len=*),intent(in)  :: string
character(len=:),allocatable :: lopped
integer                      :: ends(2)
   ends=verify( string, " ", [F,T] )
   if(ends(1) == 0)then
      lopped=""
   else
      lopped=string(ends(1):ends(2))
   endif
end function clip
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    transliterate(3f) - [M_strings:EDITING] replace characters from old
!!                        set with new set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function transliterate(instr,old_set,new_set) result(outstr)
!!
!!     character(len=*),intent(in)  :: instr
!!     character(len=*),intent(in)  :: old_set
!!     character(len=*),intent(in)  :: new_set
!!     character(len=len(instr))    :: outstr
!!
!!##DESCRIPTION
!!    Translate, squeeze, and/or delete characters from the input string.
!!
!!##OPTIONS
!!    instr    input string to change
!!    old_set  list of letters to change in INSTR if found
!!
!!             Each character in the input string that matches a character
!!             in the old set is replaced.
!!
!!    new_set  list of letters to replace letters in OLD_SET with.
!!
!!             If the new_set is the empty set the matched characters
!!             are deleted.
!!
!!             If the new_set is shorter than the old set the last character
!!             in the new set is used to replace the remaining characters
!!             in the new set.
!!
!!##RETURNS
!!    outstr   instr with substitutions applied
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_transliterate
!!
!!     use M_strings, only : transliterate
!!     implicit none
!!     character(len=80)   :: STRING
!!
!!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'
!!     write(*,'(a)') STRING
!!
!!     ! convert a string to uppercase:
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
!!
!!     ! change all miniscule letters to a colon (":"):
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz',':')
!!
!!     ! delete all miniscule letters
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','')
!!
!!    end program demo_transliterate
!!
!!    Expected output
!!
!!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
!!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
!!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
!!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
PURE FUNCTION transliterate(instr,old_set,new_set) RESULT(outstr)

! ident_19="@(#) M_strings transliterate(3f) replace characters from old set with new set"

!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=*),INTENT(IN)  :: instr                             ! input string to change
CHARACTER(LEN=*),intent(in)  :: old_set
CHARACTER(LEN=*),intent(in)  :: new_set
!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=LEN(instr))    :: outstr                            ! output string to generate
!-----------------------------------------------------------------------------------------------------------------------------------
INTEGER                      :: i10                               ! loop counter for stepping thru string
INTEGER                      :: ii,jj
!-----------------------------------------------------------------------------------------------------------------------------------
   jj=LEN(new_set)
   IF(jj /= 0)THEN
      outstr=instr                                                ! initially assume output string equals input string
      stepthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))                         ! see if current character is in old_set
         IF (ii /= 0)THEN
            if(ii <= jj)then                                      ! use corresponding character in new_set
               outstr(i10:i10) = new_set(ii:ii)
            else
               outstr(i10:i10) = new_set(jj:jj)                   ! new_set not as long as old_set; use last character in new_set
            endif
         ENDIF
      ENDDO stepthru
   else                                                           ! new_set is null string so delete characters in old_set
      outstr=' '
      hopthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))                         ! see if current character is in old_set
         IF (ii == 0)THEN                                         ! only keep characters not in old_set
            jj=jj+1
            outstr(jj:jj) = instr(i10:i10)
         ENDIF
      ENDDO hopthru
   endif
END FUNCTION transliterate
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    rotate13(3f) - [M_strings:ENCODE] apply trivial ROT13 encryption to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    rotate13(input) result(output)
!!
!!     character(len=*),intent(in) :: input
!!     character(len=len(input))   :: output
!!
!!##DESCRIPTION
!!    ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple
!!    letter substitution cipher that replaces a letter with the 13th letter
!!    after it in the alphabet; wrapping around if necessary.
!!
!!    The transformation can be done using a lookup table, such as the
!!    following:
!!
!!       Input  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
!!       Output NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm
!!
!!    ROT13 is used in online forums as a means of hiding spoilers,
!!    punchlines, puzzle solutions, and offensive materials from the casual
!!    glance. ROT13 has inspired a variety of letter and word games on-line,
!!    and is frequently mentioned in newsgroup conversations.
!!
!!    The algorithm provides virtually no cryptographic security, and is
!!    often cited as a canonical example of weak encryption.
!!
!!    ROT13 is a special case of the Caesar cipher which was developed in
!!    ancient Rome.
!!
!!    ALGORITHM
!!
!!    Applying ROT13 to a piece of text merely requires examining its
!!    alphabetic characters and replacing each one by the letter 13 places
!!    further along in the alphabet, wrapping back to the beginning if
!!    necessary. A becomes N, B becomes O, and so on up to M, which becomes
!!    Z, then the sequence continues at the beginning of the alphabet: N
!!    becomes A, O becomes B, and so on to Z, which becomes M. Only those
!!    letters which occur in the English alphabet are affected; numbers,
!!    symbols, whitespace, and all other characters are left unchanged.
!!
!!    SAME ALGORITHM FOR ENCODING AND DECODING
!!
!!    Because there are 26 letters in the English alphabet and 26 = 2 x 13,
!!    the ROT13 function is its own inverse: so the same action can be used
!!    for encoding and decoding. In other words, two successive applications
!!    of ROT13 restore the original text (in mathematics, this is sometimes
!!    called an involution; in cryptography, a reciprocal cipher).
!!
!!    TRIVIAL SECURITY
!!
!!    The use of a constant shift means that the encryption effectively
!!    has no key, and decryption requires no more knowledge than the fact
!!    that ROT13 is in use. Even without this knowledge, the algorithm is
!!    easily broken through frequency analysis.
!!
!!    In encrypted normal English-language text of any significant size,
!!    ROT13 is recognizable from some letter/word patterns. The words "n",
!!    "V" (capitalized only), and "gur" (ROT13 for "a", "I", and "the"),
!!    and words ending in "yl" ("ly") are examples.
!!
!!##REFERENCES
!!    Wikipedia, the free encyclopedia
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_rotate13
!!    use M_strings, only : rotate13
!!    implicit none
!!    character(len=256) :: line
!!    integer            :: ios
!!    do
!!       read(*,'(a)',iostat=ios)line
!!       if(ios /= 0)exit
!!       write(*,'(a)')rotate13(line)
!!    enddo
!!    end program demo_rotate13
!!
!!  Sample usage:
!!
!!    demo_rotate13
!!    United we stand, divided we fall.
!!    Havgrq jr fgnaq, qvivqrq jr snyy.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rotate13 (input)

! ident_20="@(#) M_strings rotate13(3f) converts a character to its ROT13 equivalent which is a trivial encryption."

character(len=*),intent(in) :: input
character(len=len(input))   :: rotate13
integer                     :: itemp
integer                     :: i
   rotate13=' '
   do i=1,len_trim(input)
      itemp = iachar(input(i:i))
      select case(itemp)
       case(65:77,97:109)
         itemp = itemp + 13
       case(78:90,110:122)
         itemp = itemp - 13
      end select
      rotate13(i:i) = char ( itemp )
   enddo

end function rotate13
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    percent_encode(3f) - [M_strings:ENCODE] percent-encode strings and
!!    character arrays
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     function percent_encode(text)
!!
!!      character(len=1),intent(in)  :: text(:)
!!      character(len=;),allocatable :: percent_encode
!!
!!     or
!!
!!     function percent_encode(text)
!!
!!      character(len=*),intent(in)  :: text
!!      character(len=;),allocatable :: percent_encode
!!
!!##DESCRIPTION
!!
!!    This function percent-encodes ASCII strings or ASCII character arrays.
!!    "Reserved" characters are encoded.
!!
!!    URI containing spaces or most other non-alphanumeric characters must
!!    be encoded using percent encoding (aka. URL encoding).
!!
!!    The characters allowed in a URI are either reserved or unreserved
!!    (or a percent character as part of a percent-encoding). Reserved
!!    characters are those characters that sometimes have special meaning,
!!    while unreserved characters have no such meaning. Using percent-encoding,
!!    characters which otherwise would not be allowed are represented using
!!    allowed characters. The sets of reserved and unreserved characters and
!!    the circumstances under which certain reserved characters have special
!!    meaning have changed slightly with each revision of specifications that
!!    govern URIs and URI schemes.
!!
!!    According to RFC 3986, the characters in a URL have to be taken from
!!    a defined set of unreserved and reserved ASCII characters. Any other
!!    characters are not allowed in a URL.
!!
!!    The unreserved characters can be encoded, but should not be. The
!!    unreserved characters are:
!!
!!       > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!       > abcdefghijklmnopqrstuvwxyz
!!       > 0123456789-_.~
!!
!!    The reserved characters have to be encoded only under certain
!!    circumstances. The reserved characters are:
!!
!!       >  * ' ( ) ; : @ & = + $ , / ? % # [ ]
!!
!!##OPTIONS
!!     SOURCE_STRING   string or character array to encode
!!
!!##RETURNS
!!     percent_encode  a string holding a percent-encoded copy of the input
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_percent_encode
!!    use M_strings, only : percent_encode
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!       write(*,*)percent_encode('[this is a string]')
!!    end program demo_percent_encode
!!
!! Results:
!!
!!  >  %5Bthis%20is%20a%20string%5D
!!
!!##AUTHOR
!!    John S. Urban

function percent_encode_string(text)
character(len=*),intent(in)  :: text
character(len=:),allocatable :: percent_encode_string
   percent_encode_string=percent_encode_characters(switch(text))
end function percent_encode_string

function percent_encode_characters(text)
character(len=1),intent(in) :: text(:)
character(len=:),allocatable :: percent_encode_characters
integer :: i,pos
allocate(character(len=3*size(text)) :: percent_encode_characters )
percent_encode_characters(:)=repeat(' ',len(percent_encode_characters))
   pos=1
   do i=1,size(text)
      select case(text(i))
      case('a':'z','A':'Z','0':'9','-','_','.','~')
         percent_encode_characters(pos:pos)=text(i)
         pos=pos+1
      case default
         write(percent_encode_characters(pos:pos+2),'(a1,z2.2)')'%',text(i)
         pos=pos+3
      end select
   enddo
   percent_encode_characters=trim(percent_encode_characters)
end function percent_encode_characters
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    join(3f) - [M_strings:EDITING] append CHARACTER variable array into
!!    a single CHARACTER variable with specified separator
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function join(str,sep,trm,left,right,start,end) result (string)
!!
!!     character(len=*),intent(in)          :: str(:)
!!     character(len=*),intent(in),optional :: sep
!!     logical,intent(in),optional          :: trm
!!     character(len=*),intent(in),optional :: right
!!     character(len=*),intent(in),optional :: left
!!     character(len=*),intent(in),optional :: start
!!     character(len=*),intent(in),optional :: end
!!     character(len=:),allocatable         :: string
!!
!!##DESCRIPTION
!!   JOIN(3f) appends the elements of a CHARACTER array into a single
!!   CHARACTER variable, with elements 1 to N joined from left to right.
!!   By default each element is trimmed of trailing spaces and the
!!   default separator is a null string.
!!
!!##OPTIONS
!!      STR(:)  array of CHARACTER variables to be joined
!!      SEP     separator string to place between each variable. defaults
!!              to a null string.
!!      LEFT    string to place at left of each element
!!      RIGHT   string to place at right of each element
!!      START   prefix string
!!      END     suffix string
!!      TRM     option to trim each element of STR of trailing
!!              spaces. Defaults to .TRUE.
!!
!!##RESULT
!!      STRING  CHARACTER variable composed of all of the elements of STR()
!!              appended together with the optional separator SEP placed
!!              between the elements.
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!   program demo_join
!!   use M_strings, only: join
!!   implicit none
!!   character(len=:),allocatable  :: s(:)
!!   character(len=:),allocatable  :: out
!!   integer                       :: i
!!     s=[character(len=10) :: 'United',' we',' stand,', &
!!     & ' divided',' we fall.']
!!     out=join(s)
!!     write(*,'(a)') out
!!     write(*,'(a)') join(s,trm=.false.)
!!     write(*,'(a)') (join(s,trm=.false.,sep='|'),i=1,3)
!!     write(*,'(a)') join(s,sep='<>')
!!     write(*,'(a)') join(s,sep=';',left='[',right=']')
!!     write(*,'(a)') join(s,left='[',right=']')
!!     write(*,'(a)') join(s,left='>>')
!!   end program demo_join
!!
!!  Expected output:
!!
!!   United we stand, divided we fall.
!!   United     we        stand,    divided   we fall.
!!   United    | we       | stand,   | divided  | we fall.
!!   United    | we       | stand,   | divided  | we fall.
!!   United    | we       | stand,   | divided  | we fall.
!!   United<> we<> stand,<> divided<> we fall.
!!   [United];[ we];[ stand,];[ divided];[ we fall.]
!!   [United][ we][ stand,][ divided][ we fall.]
!!   >>United>> we>> stand,>> divided>> we fall.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function join(str,sep,trm,left,right,start,end) result (string)

! ident_21="@(#) M_strings join(3f) merge string array into a single CHARACTER value adding specified separators caps prefix and suffix"

character(len=*),intent(in)          :: str(:)
character(len=*),intent(in),optional :: sep, right, left, start, end
logical,intent(in),optional          :: trm
character(len=:),allocatable         :: sep_local, left_local, right_local
character(len=:),allocatable         :: string
logical                              :: trm_local
integer                              :: i
   if(present(sep))then   ; sep_local=sep     ; else ; sep_local=''     ; endif
   if(present(trm))then   ; trm_local=trm     ; else ; trm_local=.true. ; endif
   if(present(left))then  ; left_local=left   ; else ; left_local=''    ; endif
   if(present(right))then ; right_local=right ; else ; right_local=''   ; endif
   string=''
   if(size(str) == 0)then
      string=string//left_local//right_local
   else
      do i = 1,size(str)-1
         if(trm_local)then
            string=string//left_local//trim(str(i))//right_local//sep_local
         else
            string=string//left_local//str(i)//right_local//sep_local
         endif
      enddo
      if(trm_local)then
         string=string//left_local//trim(str(i))//right_local
      else
         string=string//left_local//str(i)//right_local
      endif
   endif
   if(present(start))string=start//string
   if(present(end))string=string//end
end function join
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      reverse(3f) - [M_strings:EDITING] Return a string reversed
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function reverse(str) result (string)
!!
!!     character(*), intent(in) :: str
!!     character(len(str))      :: string
!!
!!##DESCRIPTION
!!      reverse(string) returns a copy of the input string with
!!      all characters reversed from right to left.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!       program demo_reverse
!!       use M_strings, only: reverse
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          write(*,*)'REVERSE STRINGS:',reverse('Madam, I''m Adam')
!!          s='abcdefghijklmnopqrstuvwxyz'
!!          write(*,*) 'original input string is ....',s
!!          write(*,*) 'reversed output string is ...',reverse(s)
!!       end program demo_reverse
!!
!!  Results:
!!
!!      >  REVERSE STRINGS:madA m'I ,madaM
!!      >  original input string is ....abcdefghijklmnopqrstuvwxyz
!!      >  reversed output string is ...zyxwvutsrqponmlkjihgfedcba
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function reverse(string) result (rev)

! ident_22="@(#) M_strings reverse(3f) Return a string reversed"

character(len=*),intent(in)    :: string   ! string to reverse
character(len=len(string))     :: rev      ! return value (reversed string)
integer                        :: length
integer                        :: i
   length = len(string)

   do i = 1,length
      rev(i:i)=string(length-i+1:length-i+1)
   enddo
end function reverse
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper_quoted(3f) - [M_strings:CASE] elemental function converts string to
!!                uppercase skipping strings quoted per Fortran syntax rules
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper_quoted(str) result (string)
!!
!!     character(*), intent(in)    :: str
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!    upper_quoted(string) returns a copy of the input string with all not-quoted
!!    characters converted to uppercase, assuming ASCII character sets
!!    are being used. The quoting rules are the same as for Fortran source.
!!    Either a single or double quote starts a quoted string, and a quote
!!    character of the same type is doubled when it appears internally in
!!    the quoted string. If a double quote quotes the string single quotes
!!    may appear in the quoted string as single characters, and vice-versa
!!    for single quotes.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!
!!##RESULTS
!!    upper  copy of the input string with all unquoted characters converted
!!           to uppercase
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_upper_quoted
!!     use M_strings, only: upper_quoted
!!     implicit none
!!     character(len=:),allocatable  :: s
!!     s=' ABCDEFG abcdefg "Double-Quoted" ''Single-Quoted'' "with ""&
!!        & Quote" everything else'
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper_quoted(s)
!!        write(*,'(1x,a,*(a:,"+"))') 'upper_quoted(3f) is elemental ==>', &
!!        & upper_quoted(["abc","def","ghi"])
!!     end program demo_upper_quoted
!!
!!    Expected output:
!!
!!     mixed-case input string is .... ABCDEFG abcdefg "Double-Quoted"
!!     'Single-Quoted' "with "" Quote" everything else
!!     upper-case output string is ... ABCDEFG ABCDEFG "Double-Quoted"
!!     'Single-Quoted' "with "" Quote" EVERYTHING ELSE
!!     upper_quoted(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function upper_quoted(str) result (string)

! ident_23="@(#) M_strings upper_quoted(3f) elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules"

character(len=*), intent(in)   :: str     ! The input string
character(len=len(str))        :: string  ! The output string
logical                        :: toggle
character(len=1)               :: togglechar
integer                        :: irnk
integer                        :: i
character(len=26), parameter   :: large="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
character(len=26), parameter   :: small="abcdefghijklmnopqrstuvwxyz"

   string=str
   toggle = .TRUE.
   do i = 1, len_trim(string)
      if(toggle) then
         if(string(i:i) == '"' .or. string(i:i) == "'") then
            toggle = .not. toggle
            togglechar = string(i:i)
         endif
         irnk = index(small, string(i:i))
         if(irnk > 0) then
            string(i:i) = large(irnk:irnk)
         endif
      else
         if(string(i:i) == togglechar) toggle = .not. toggle
      endif
   enddo
end function upper_quoted
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper(3f) - [M_strings:CASE] changes a string to uppercase
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper(str,begin,end) result (string)
!!
!!     character(*), intent(in)    :: str
!!     integer,optional,intent(in) :: begin,end
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!      upper(string) returns a copy of the input string with all characters
!!      converted in the optionally specified range to uppercase, assuming
!!      ASCII character sets are being used. If no range is specified the
!!      entire string is converted to uppercase.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!    begin  optional starting position in "str" to begin converting to
!!           uppercase
!!    end    optional ending position in "str" to stop converting to
!!           uppercase
!!
!!##RESULTS
!!    upper  copy of the input string with all characters converted to
!!           uppercase over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_upper
!!     use M_strings, only: upper
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s=' ABCDEFG abcdefg '
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper(s)
!!        write(*,*) 'make first character uppercase  ... ',&
!!        & upper('this is a sentence.',1,1)
!!        write(*,'(1x,a,*(a:,"+"))') 'UPPER(3f) is elemental ==>',&
!!        & upper(["abc","def","ghi"])
!!     end program demo_upper
!!
!!    Expected output
!!
!!     mixed-case input string is .... ABCDEFG abcdefg
!!     upper-case output string is ... ABCDEFG ABCDEFG
!!     make first character uppercase  ... This is a sentence.
!!     UPPER(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
! Timing
!
!    Several different methods have been proposed for changing case.
!    A simple program that copies a large file and converts it to
!    uppercase was timed and compared to a simple copy. This was used
!    to select the default function.
!
! NULL:    83.41user  9.25system 1:37.94elapsed 94%CPU
! upper:  101.44user 10.89system 1:58.36elapsed 94%CPU
! upper2: 105.04user 10.69system 2:04.17elapsed 93%CPU
! upper3: 267.21user 11.69system 4:49.21elapsed 96%CPU
elemental pure function upper_all(str) result (string)

! ident_24="@(#) M_strings upper_all(3f) returns an uppercase string"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
! note using kind=int8 is faster than int32 in gfortran
integer(kind=int8), parameter :: ade_a = iachar('a'), ade_z = iachar('z')
integer(kind=int8), parameter :: diff = iachar('A',kind=int8) - iachar('a',kind=int8)
integer(kind=int8)            :: ade_char

   do concurrent(i=1:len(str))                       ! step thru each letter in the string in specified range
      ade_char = iachar(str(i:i), int8)              ! ASCII Decimal Equivalent
      if (ade_char >= ade_a .and. ade_char <= ade_z) ade_char = ade_char + diff
      string(i:i) = achar(ade_char)
   enddo

   if(len(str).eq.0)string = str

end function upper_all
elemental pure function upper_range(str,begin,end) result (string)

! ident_25="@(#) M_strings upper_range(3f) returns a string with the specified range converted to uppercase"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
integer, intent(in)           :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
! note using kind=int8 is faster than int32 in gfortran
integer(kind=int8), parameter :: diff = iachar('A',kind=int8) - iachar('a',kind=int8)

   iend=len(str)
   if(iend.ne.0.and.(end.le.iend.and.end.ge.1).and.(begin.ge.1.and.begin.le.iend))then
      ibegin=begin
      iend=end
      string = str                                      ! initialize output string to input string
      ! note doing everything in a loop instead of just assigning string=str and then doing just changed values in loop is faster!
      do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
          select case (str(i:i))
          case ('a':'z')                                ! located miniscule letter
             string(i:i) = achar(iachar(str(i:i),kind=int8) + diff)    ! change miniscule letter to majascule
          case default
             string(i:i) = str(i:i)
          end select
      enddo
   else
      string=str
   endif
end function upper_range
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lower(3f) - [M_strings:CASE] changes a string to lowercase over
!!    specified range
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function lower(str,begin,end) result (string)
!!
!!     character(*), intent(in) :: str
!!     integer,optional         :: begin, end
!!     character(len(str))      :: string  ! output string
!!
!!##DESCRIPTION
!!      lower(string) returns a copy of the input string with all characters
!!      converted to miniscule over the specified range, assuming ASCII
!!      character sets are being used. If no range is specified the entire
!!      string is converted to miniscule.
!!
!!##OPTIONS
!!    str    string to convert to miniscule
!!    begin  optional starting position in "str" to begin converting to
!!           miniscule
!!    end    optional ending position in "str" to stop converting to
!!           miniscule
!!
!!##RESULTS
!!    lower  copy of the input string with all characters converted to
!!           miniscule over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!       program demo_lower
!!       use M_strings, only: lower
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          s=' ABCDEFG abcdefg '
!!          write(*,*) 'mixed-case input string is ....',s
!!          write(*,*) 'lower-case output string is ...',lower(s)
!!       end program demo_lower
!!
!!    Expected output
!!
!!       mixed-case input string is .... ABCDEFG abcdefg
!!       lower-case output string is ... abcdefg abcdefg
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function lower(str,begin,end) result (string)

! ident_26="@(#) M_strings lower(3f) Changes a string to lowercase over specified range"

character(*), intent(in)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = achar(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select
   enddo

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    switch(3f) - [M_strings:ARRAY] converts between CHARACTER scalar and
!!    array of single characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function switch(array) result (string)
!!
!!     character(len=1),intent(in) :: array(:)
!!     character(len=SIZE(array))  :: string
!!
!!      or
!!
!!    pure function switch(string) result (array)
!!
!!     character(len=*),intent(in) :: string
!!     character(len=1)            :: array(len(string))
!!
!!##DESCRIPTION
!!    SWITCH(3f): generic function that switches CHARACTER string to an array
!!    of single characters or an array of single characters to a CHARACTER
!!    string. Useful in passing strings to C. New Fortran features may
!!    supersede these routines.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_switch
!!    use M_strings, only : switch, isalpha, islower, nospace
!!    character(len=*),parameter :: &
!!    & dashes='-----------------------------------'
!!    character(len=*),parameter :: string='This is a string'
!!    character(len=1024)        :: line
!!
!!    ! First, examples of standard Fortran features
!!    ! returns array [F,T,T,T,T,T]
!!    write(*,*)['A','=','=','=','=','='] == '='
!!    ! this would return T
!!    write(*,*)all(['=','=','=','=','=','='] == '=')
!!    ! this would return F
!!    write(*,*)all(['A','=','=','=','=','='] == '=')
!!
!!    ! so to test if the string DASHES is all dashes
!!    ! using SWITCH(3f) is
!!    if(all(switch(dashes) == '-'))then
!!       write(*,*)'DASHES is all dashes'
!!    endif
!!
!!    ! so to test is a string is all letters
!!    ! isalpha(3f) returns .true. only if character is a letter
!!    ! false because dashes are not a letter
!!    write(*,*) all(isalpha(switch(dashes)))
!!    ! false because of spaces
!!    write(*,*) all(isalpha(switch(string)))
!!    ! true because removed whitespace
!!    write(*,*) all(isalpha(switch(nospace(string))))
!!
!!    ! to see if a string is all uppercase
!!    ! show the string
!!    write(*,*) string
!!    ! converted to character array
!!    write(*,'(1x,*("[",a,"]":))') switch(string)
!!    write(*,'(*(l3))') islower(switch(string))
!!
!!    ! we need a string that is all letters
!!    line=nospace(string)
!!    write(*,*)'LINE=',trim(line)
!!    ! all true except first character
!!    write(*,*) islower(switch(nospace(string)))
!!    ! should be false
!!    write(*,*) all(islower(switch(nospace(string))))
!!    ! should be true
!!    write(*,*) all(islower(switch(nospace(string(2:)))))
!!
!!    end program demo_switch
!!
!!  Expected output
!!
!!     F T T T T T
!!     T
!!     F
!!     DASHES is all dashes
!!     F
!!     F
!!     T
!!     This is a string
!!     [T][h][i][s][ ][i][s][ ][a][ ][s][t][r][i][n][g]
!!      F  T  T  T  F  T  T  F  T  F  T  T  T  T  T  T
!!     LINE=Thisisastring
!!     F T T T T T T T T T T T T
!!     F
!!     T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function a2s(array)  result (string)

! ident_27="@(#) M_strings a2s(3fp) function to copy char array to string"

character(len=1),intent(in) :: array(:)
character(len=SIZE(array))  :: string
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall( i = 1:size(array)) string(i:i) = array(i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  string=transfer(array,string)
end function a2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

! ident_28="@(#) M_strings s2a(3fp) function to copy string(1 Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  array=transfer(string,array)
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2c(3f) - [M_strings:ARRAY] convert character variable to array of
!!      characters with last element set to null
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2c(string)
!!
!!     character(len=*),intent=(in)  :: string
!!     character(len=1),allocatable  :: s2c(:)
!!
!!##DESCRIPTION
!!    Given a character variable convert it to an array of single-character
!!    character variables with the last element set to a null character.
!!    This is generally used to pass character variables to C procedures.
!!
!!##EXAMPLES
!!
!!
!! character(len=3),allocatable :: array(:)
!! integer                      :: i
!!    ! put one character into each 3-character element of array
!!    array = [(string(i:i),i=1,len(string))]
!!    ! write array with ASCII Decimal Equivalent below it except show
!!    ! unprintable characters like NULL as "XXX"
!!    write(*,g) merge('XXX',array,iachar(array(:)(1:1)) < 32)
!!    write(*,g) iachar(array(:)(1:1))
!!
!!    Sample Program:
!!
!!     program demo_s2c
!!     use M_strings, only : s2c
!!     implicit none
!!     character(len=*),parameter   :: string="single string"
!!     character(len=*),parameter   :: g= '(1x,*("[",g3.3,"]":))'
!!     character(len=3),allocatable :: array(:)
!!        write(*,*)'INPUT STRING ',trim(string)
!!        ! put one character into each 3-character element of array
!!        array=s2c(string)
!!        ! write array with ASCII Decimal Equivalent below it except show
!!        ! unprintable characters like NULL as "XXX"
!!        write(*,g) merge('XXX',array,iachar(array(:)(1:1)) < 32)
!!        write(*,g) iachar(array(:)(1:1))
!!     end program demo_s2c
!!
!!   Expected output:
!!
!!    INPUT STRING single string
!!    [s  ][i  ][n  ][g  ][l  ][e  ][   ][s  ][t  ][r  ][i  ][n  ][g  ][XXX]
!!    [115][105][110][103][108][101][ 32][115][116][114][105][110][103][  0]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function s2c(string)  RESULT (array)
use,intrinsic :: ISO_C_BINDING, only : C_CHAR

! ident_29="@(#) M_strings s2c(3f) copy string(1 Clen(string)) to char array with null terminator"

character(len=*),intent(in)     :: string

! This is changing, but currently the most portable way to pass a CHARACTER variable to C is to convert it to an array of
! character variables with length one and add a null character to the end of the array. The s2c(3f) function helps do this.
character(kind=C_CHAR,len=1)    :: array(len_trim(string)+1)
integer                         :: i
   do i = 1,size(array)-1
      array(i) = string(i:i)
   enddo
   array(size(array):)=achar(0)
end function s2c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      c2s(3f) - [M_strings:ARRAY] convert C string pointer to Fortran
!!      character string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function c2s(c_string_pointer) result(f_string)
!!
!!     type(c_ptr), intent(in)       :: c_string_pointer
!!     character(len=:), allocatable :: f_string
!!
!!##DESCRIPTION
!!    Given a C pointer to a character string return a Fortran character
!!    string.
!!
!!##OPTIONS
!!    c_string_pointer  C pointer to convert
!!
!!##RETURNS
!!    f_string          Fortran character variable to return
!!
!!##EXAMPLE
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function c2s(c_string_pointer) result(f_string)
! gets a C string (pointer), and returns the corresponding Fortran string;
! If the C string is null, it returns "NULL", similar to C's "(null)" printed in similar cases:
use, intrinsic :: iso_c_binding, only: c_ptr,c_f_pointer,c_char,c_null_char

! ident_30="@(#) M_strings c2s(3f) copy pointer to C char array till a null is encountered to a Fortran string up to 4096 characters"

integer,parameter                             :: max_length=4096
type(c_ptr), intent(in)                       :: c_string_pointer
character(len=:), allocatable                 :: f_string
character(kind=c_char), dimension(:), pointer :: char_array_pointer => null()
character(len=max_length)                            :: aux_string
integer                                       :: i,length=0

   call c_f_pointer(c_string_pointer,char_array_pointer,[max_length])
   if (.not.associated(char_array_pointer)) then
     allocate(character(len=4)::f_string)
     f_string="NULL"
     return
   endif
   aux_string=" "
   do i=1,max_length
     if (char_array_pointer(i)==c_null_char) then
       length=i-1
       exit
     endif
     aux_string(i:i)=char_array_pointer(i)
   enddo
   allocate(character(len=length)::f_string)
   f_string=aux_string(1:length)

end function c2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      indent(3f) - [M_strings:WHITESPACE] count number of leading spaces
!!      in a string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function indent(line)
!!
!!     integer                        :: indent
!!     character(len=*),intent(in)    :: line
!!
!!##DESCRIPTION
!!    Count number of leading spaces in a CHARACTER variable.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!    program demo_indent
!!    !  test filter to count leading spaces in a character variable
!!    !  might want to call notabs(3f) to expand tab characters
!!    use M_strings, only : indent
!!    implicit none
!!    character(len=1024) :: in
!!    integer             :: ios
!!       READFILE: do
!!          read(*,'(A)',iostat=ios)in
!!          if(ios /= 0) exit READFILE
!!          write(*,'(i3,"",a)')indent(in),trim(in)
!!       enddo READFILE
!!    end program demo_indent
!!
!! Results:
!!
!!      3   a b c
!!      0a b c
!!      6      a b c
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function indent(line)

! ident_31="@(#) M_strings indent(3f) find number of leading spaces in a string"

integer                        :: indent
character(len=*),intent(in)    :: line
integer                        :: i
   indent=0
   NOTSPACE: block
      SCAN: do i=1,len(line)
         if(line(i:i) /= ' ')then
            indent=i-1
            exit NOTSPACE
         endif
      enddo SCAN
      indent=len(line)
   endblock NOTSPACE
end function indent
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    visible(3f) - [M_strings:NONALPHA] expand a string to control and
!!    meta-control representations
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function visible(input) result(output)
!!
!!     character(len=*),intent(in)           :: input
!!     character(len=:),allocatable          :: output
!!
!!##DESCRIPTION
!!     visible(3f) expands characters to commonly used sequences used
!!     to represent the characters as control sequences or meta-control
!!     sequences.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_visible
!!     use M_strings, only : visible
!!     integer :: i
!!        do i=0,255
!!           write(*,'(i0,1x,a)')i,visible(char(i))
!!        enddo
!!     end program demo_visible
!!##BUGS
!!     The expansion is not reversible, as input sequences such as "M-" or
!!     "^a" will look like expanded sequences.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function visible(input) result(output)
character(len=*),intent(in)  :: input
character(len=:),allocatable :: output

! ident_32="@(#) M_strings visible(3f) expand escape sequences in a string to control and meta-control representations"

integer                      :: i
character(len=1)             :: c

character(len=*),parameter :: chars(0:255)= [ &
'^@  ', '^A  ', '^B  ', '^C  ', '^D  ', '^E  ', '^F  ', '^G  ', '^H  ', '^I  ', &
'^J  ', '^K  ', '^L  ', '^M  ', '^N  ', '^O  ', '^P  ', '^Q  ', '^R  ', '^S  ', &
'^T  ', '^U  ', '^V  ', '^W  ', '^X  ', '^Y  ', '^Z  ', '^[  ', '^\  ', '^]  ', &
'^^  ', '^_  ', '    ', '!   ', '"   ', '#   ', '$   ', '%   ', '&   ', '''   ', &
'(   ', ')   ', '*   ', '+   ', ',   ', '-   ', '.   ', '/   ', '0   ', '1   ', &
'2   ', '3   ', '4   ', '5   ', '6   ', '7   ', '8   ', '9   ', ':   ', ';   ', &
'<   ', '=   ', '>   ', '?   ', '@   ', 'A   ', 'B   ', 'C   ', 'D   ', 'E   ', &
'F   ', 'G   ', 'H   ', 'I   ', 'J   ', 'K   ', 'L   ', 'M   ', 'N   ', 'O   ', &
'P   ', 'Q   ', 'R   ', 'S   ', 'T   ', 'U   ', 'V   ', 'W   ', 'X   ', 'Y   ', &
'Z   ', '[   ', '\   ', ']   ', '^   ', '_   ', '`   ', 'a   ', 'b   ', 'c   ', &
'd   ', 'e   ', 'f   ', 'g   ', 'h   ', 'i   ', 'j   ', 'k   ', 'l   ', 'm   ', &
'n   ', 'o   ', 'p   ', 'q   ', 'r   ', 's   ', 't   ', 'u   ', 'v   ', 'w   ', &
'x   ', 'y   ', 'z   ', '{   ', '|   ', '}   ', '~   ', '^?  ', 'M-^@', 'M-^A', &
'M-^B', 'M-^C', 'M-^D', 'M-^E', 'M-^F', 'M-^G', 'M-^H', 'M-^I', 'M-^J', 'M-^K', &
'M-^L', 'M-^M', 'M-^N', 'M-^O', 'M-^P', 'M-^Q', 'M-^R', 'M-^S', 'M-^T', 'M-^U', &
'M-^V', 'M-^W', 'M-^X', 'M-^Y', 'M-^Z', 'M-^[', 'M-^\', 'M-^]', 'M-^^', 'M-^_', &
'M-  ', 'M-! ', 'M-" ', 'M-# ', 'M-$ ', 'M-% ', 'M-& ', 'M-'' ', 'M-( ', 'M-) ', &
'M-* ', 'M-+ ', 'M-, ', 'M-- ', 'M-. ', 'M-/ ', 'M-0 ', 'M-1 ', 'M-2 ', 'M-3 ', &
'M-4 ', 'M-5 ', 'M-6 ', 'M-7 ', 'M-8 ', 'M-9 ', 'M-: ', 'M-; ', 'M-< ', 'M-= ', &
'M-> ', 'M-? ', 'M-@ ', 'M-A ', 'M-B ', 'M-C ', 'M-D ', 'M-E ', 'M-F ', 'M-G ', &
'M-H ', 'M-I ', 'M-J ', 'M-K ', 'M-L ', 'M-M ', 'M-N ', 'M-O ', 'M-P ', 'M-Q ', &
'M-R ', 'M-S ', 'M-T ', 'M-U ', 'M-V ', 'M-W ', 'M-X ', 'M-Y ', 'M-Z ', 'M-[ ', &
'M-\ ', 'M-] ', 'M-^ ', 'M-_ ', 'M-` ', 'M-a ', 'M-b ', 'M-c ', 'M-d ', 'M-e ', &
'M-f ', 'M-g ', 'M-h ', 'M-i ', 'M-j ', 'M-k ', 'M-l ', 'M-m ', 'M-n ', 'M-o ', &
'M-p ', 'M-q ', 'M-r ', 'M-s ', 'M-t ', 'M-u ', 'M-v ', 'M-w ', 'M-x ', 'M-y ', &
'M-z ', 'M-{ ', 'M-| ', 'M-} ', 'M-~ ', 'M-^?']
output=''
do i=1,len(input)
   c=input(i:i)
   if(c == ' ')then
      output=output//' '
   else
      output=output//trim(chars(iachar(c)))
   endif
enddo
end function visible
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    expand(3f) - [M_strings:NONALPHA] expand C-like escape sequences
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function expand(line,escape) result(lineout)
!!
!!    character(len=*)                      :: line
!!    character(len=1),intent(in),optional  :: escape
!!    character(len=:),allocatable          :: lineout
!!
!!##DESCRIPTION
!!     EXPAND() expands sequences used to represent commonly used escape
!!     sequences or control characters. By default ...
!!
!!     Escape sequences
!!       \      backslash
!!       a      alert (BEL) -- g is an alias for a
!!       b      backspace
!!       c      suppress further output
!!       e      escape
!!       f      form feed
!!       n      new line
!!       r      carriage return
!!       t      horizontal tab
!!       v      vertical tab
!!       oNNN   byte with octal value NNN (3 digits)
!!       dNNN   byte with decimal value NNN (3 digits)
!!       xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
!!
!!     The default escape character is the backslash, but this may be
!!     changed using the optional parameter ESCAPE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_expand
!!       use M_strings, only : expand
!!       integer,parameter     :: iwidth=1024
!!       integer               :: i
!!       character(len=iwidth),parameter :: input(*)=[ character(len=iwidth) :: &
!!          '\e[H\e[2J',&
!!          '\tABC\tabc',&
!!          '\tA\a',&
!!          '\nONE\nTWO\nTHREE',&
!!          '\\']
!!          write(*,'(a)')(trim(expand(input(i))),i=1,size(input))
!!    end program demo_expand
!!
!! Results (with nonprintable characters shown visible):
!!  > ^[[H^[[2J
!!  > ^IABC^Iabc
!!  > ^IA^G
!!  >
!!  > ONE
!!  > TWO
!!  > THREE
!!  > \
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function expand(line,escape) result(lineout)
!x!USE ISO_C_BINDING ,ONLY: c_horizontal_tab

! ident_33="@(#) M_strings expand(3f) return string with escape sequences expanded"

character(len=*),parameter            :: c_horizontal_tab=char(9)
character(len=*),intent(in)           :: line
character(len=1),intent(in),optional  :: escape ! escape character. Default is backslash
! expand escape sequences found in input string
! Escape sequences
!    %%      escape character           %a     alert (BEL) -- gi is an alias for a
!    %b      backspace                  %c     suppress further output
!    %e      escape                     %E     escape
!    %f      form feed                  %n     new line
!    %r      carriage return            %t     horizontal tab
!    %v      vertical tab
!    %oNNN   byte with octal value NNN (3 digits)
!    %dNNN   byte with decimal value NNN (3 digits)
!    %xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
character(len=1)                      :: esc    ! escape character. Default is %
character(len=:),allocatable          :: lineout
integer                               :: i
integer                               :: lgth
character(len=3)                      :: thr
integer                               :: xxx
integer                               :: ios
   i=0 ! pointer into input

   lgth=len_trim(line)
   lineout=''

   if(lgth == 0)return

   if (present(escape))then
      esc=escape
   else
      esc=char(92)
   endif

   EXP: do
      i=i+1
      if(i > lgth)exit
      if(line(i:i) == esc)then
         i=i+1
         if(i > lgth)exit
         if(line(i:i) /= esc)then
            BACKSLASH: select case(line(i:i))
            case('a','A','g','G');lineout=lineout//char(  7) ! %a     alert (BEL)
            case('b','B');lineout=lineout//char(  8)         ! %b     backspace
            case('c','C');exit EXP                           ! %c     suppress further output
            case('d','D')                                    ! %d     Dnnn decimal value
                      thr=line(i+1:)
                   read(thr,'(i3)',iostat=ios)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('e','E');lineout=lineout//char( 27)         ! %e     escape
            case('f','F');lineout=lineout//char( 12)         ! %f     form feed
            case('n','N');lineout=lineout//char( 10)         ! %n     new line
           !case('n','N');lineout=lineout//new_line('A')     ! %n     new line
            case('o','O')
                      thr=line(i+1:)
                   read(thr,'(o3)',iostat=ios)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('r','R');lineout=lineout//char( 13)         ! %r     carriage return
            case('t','T');lineout=lineout//c_horizontal_tab  ! %t     horizontal tab
            case('v','V');lineout=lineout//char( 11)         ! %v     vertical tab
            case('x','X','h','H')                            ! %x     xHH  byte with hexadecimal value HH (1 to 2 digits)
                      thr=line(i+1:)
                   read(thr,'(z2)',iostat=ios)xxx
                      lineout=lineout//char(xxx)
                   i=i+2
            end select BACKSLASH
         else
            lineout=lineout//esc                             ! escape character, defaults to backslash
         endif
      else
         lineout=lineout//line(i:i)
      endif
      if(i >= lgth)exit EXP
   enddo EXP

end function expand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notabs(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine notabs(INSTR,OUTSTR,lgth)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=*),intent=(out) :: OUTSTR
!!     integer,intent=(out)          :: lgth
!!
!!##DESCRIPTION
!!     NOTABS() converts tabs in INSTR to spaces in OUTSTR while maintaining
!!     columns. It assumes a tab is set every 8 characters. Trailing spaces
!!     are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!     What are some reasons for removing tab characters from an input line?
!!     Some Fortran compilers have problems with tabs, as tabs are not
!!     part of the Fortran character set. Some editors and printers will
!!     have problems with tabs. It is often useful to expand tabs in input
!!     files to simplify further processing such as tokenizing an input line.
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RESULTS
!!     outstr    Output string with tabs expanded. Assumed to be of sufficient
!!               length
!!     lgth      Significant length of returned string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_notabs
!!
!!    !  test filter to remove tabs and trailing white space from input
!!    !  on files up to 1024 characters wide
!!    use M_strings, only : notabs
!!    character(len=1024) :: in,out
!!    integer             :: ios,iout
!!       do
!!          read(*,'(A)',iostat=ios)in
!!          if(ios /= 0) exit
!!          call notabs(in,out,iout)
!!          write(*,'(a)')out(:iout)
!!       enddo
!!    end program demo_notabs
!!
!!##SEE ALSO
!!     GNU/Unix commands expand(1) and unexpand(1)
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental impure subroutine notabs(instr,outstr,lgth)

! ident_34="@(#) M_strings notabs(3f) convert tabs to spaces while maintaining columns remove CRLF chars"

character(len=*),intent(in)   :: instr        ! input line to scan for tab characters
character(len=*),intent(out)  :: outstr       ! tab-expanded version of INSTR produced
integer,intent(out)           :: lgth         ! column position of last character put into output string
                                              ! that is, lgth holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
integer,parameter             :: tabsize=8    ! assume a tab stop is set every 8th column
integer                       :: ipos         ! position in OUTSTR to put next character of INSTR
integer                       :: lenin        ! length of input string trimmed of trailing spaces
integer                       :: lenout       ! number of characters output string can hold
integer                       :: istep        ! counter that advances thru input string INSTR one character at a time
character(len=1)              :: c            ! character in input line being processed
integer                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
   ipos=1                                     ! where to put next character in output string OUTSTR
   lenin=len_trim(instr( 1:len(instr) ))      ! length of INSTR trimmed of trailing spaces
   lenout=len(outstr)                         ! number of characters output string OUTSTR can hold
   outstr=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: do istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=iachar(c)                       ! get ADE of the character
         EXPAND_TABS : select case (iade)     ! take different actions depending on which character was found
         case(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
         case(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         case default                         ! c is anything else other than a tab,newline,or return  insert it in output string
            if(ipos > lenout)then
               call journal("*notabs* output string overflow")
               exit
            else
               outstr(ipos:ipos)=c
               ipos=ipos+1
            endif
         end select EXPAND_TABS
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=min(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      lgth=len_trim(outstr(:ipos))            ! trim trailing spaces
!===================================================================================================================================
end subroutine notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dilate(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dilate(INSTR) result(OUTSTR)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=:),allocatable  :: OUTSTR
!!
!!##DESCRIPTION
!!     dilate() converts tabs in INSTR to spaces in OUTSTR.  It assumes a
!!     tab is set every 8 characters. Trailing spaces are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RESULTS
!!     outstr    Output string with tabs expanded.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dilate
!!
!!    use M_strings, only : dilate, visible
!!    implicit none
!!    character(len=:),allocatable :: in
!!    integer                      :: i
!!       in='  this is my string  '
!!       ! change spaces to tabs to make a sample input
!!       do i=1,len(in)
!!          if(in(i:i) == ' ')in(i:i)=char(9)
!!       enddo
!!       write(*,'("[",a,"]")')visible(in)
!!       write(*,'("[",a,"]")')visible(dilate(in))
!!    end program demo_dilate
!!
!!   Results:
!!
!!    > [^I^Ithis^Iis^Imy^Istring^I^I]
!!    > [                this    is      my      string]
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
function dilate(INSTR) result(OUTSTR)

! ident_35="@(#) M_strings dilate(3f) convert tabs to spaces and trims line removing CRLF chars"

CHARACTER(LEN=*),INTENT(IN)   :: instr        ! input line to scan for tab characters
CHARACTER(LEN=:),allocatable  :: outstr       ! tab-expanded version of INSTR produced
integer                       :: i
integer                       :: icount
integer                       :: lgth
   icount=0
   do i=1,len(instr)
      if(instr(i:i) == char(9))icount=icount+1
   enddo
   allocate(character(len=(len(instr)+8*icount)) :: outstr)
   call notabs(instr,outstr,lgth)
   outstr=outstr(:lgth)

END function dilate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    adjustc(3f) - [M_strings:WHITESPACE] center text
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   pure function adjustc(string[,length])
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in),optional  :: length
!!    character(len=:),allocatable :: adjustc
!!
!!##DESCRIPTION
!!     Centers input text in a string of the length specified. Returns a
!!     string of length LENGTH if LENGTH is present. Otherwise returns a
!!     string of the length of the input string.
!!
!!##OPTIONS
!!     string  input string to trim and center
!!     length  line length to center text in, optional.
!!
!!##RETURNS
!!     adjustc  centered output string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_adjustc
!!    use M_strings, only : adjustc
!!    !  using length of the input string
!!       write(*,'(a)')       '================================'
!!       write(*,'(a)')adjustc('centered string                 ')
!!       write(*,'(a)')adjustc('                 centered string')
!!       write(*,'(a)')adjustc('  centered string               ')
!!    !  using explicit output string length
!!       write(*,'(a)')repeat('=',50)
!!       write(*,'(a)')adjustc('this is a centered string',50)
!!       write(*,'(a)')repeat('=',50)
!!    end program demo_adjustc
!!
!!   Expected output
!!
!!    ================================
!!            centered string
!!            centered string
!!            centered string
!!    ==================================================
!!                this is a centered string
!!    ==================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function adjustc(string,length)

! ident_36="@(#) M_strings adjustc(3f) center text"

!>
!! PROCEDURE:   adjustc(3f)
!! DESCRIPTION: center text using implicit or explicit length
!!##VERSION:     2.0, 20160711
!! AUTHOR:      John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: string         ! input string to trim and center
integer,intent(in),optional  :: length         ! line length to center text in
character(len=:),allocatable :: adjustc        ! output string
integer                      :: inlen
integer                      :: ileft          ! left edge of string if it is centered
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(length))then                     ! optional length
      inlen=length                             ! length will be requested length
      if(inlen <= 0)then                       ! bad input length
         inlen=len(string)                     ! could not use input value, fall back to length of input string
      endif
   else                                        ! output length was not explicitly specified, use input string length
      inlen=len(string)
   endif
   allocate(character(len=inlen):: adjustc)    ! create output at requested length
   adjustc(1:inlen)=' '                        ! initialize output string to all blanks
!-----------------------------------------------------------------------------------------------------------------------------------
   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it
   if(ileft > 0)then                          ! if string will fit centered in output
      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string
   else                                        ! input string will not fit centered in output string
      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can
   endif
end function adjustc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!!    input string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function nospace(str) - remove all whitespace from input string
!!
!!     character(len=*),intent(in)          :: str
!!     character(len=:),allocatable         :: nospace
!!
!!##DESCRIPTION
!!    nospace(3f) removes space, tab, carriage return, new line, vertical
!!    tab, formfeed and null characters (called "whitespace"). The output
!!    is returned trimmed.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_nospace
!!     use M_strings, only: nospace
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s='  This     is      a     test  '
!!        write(*,*) 'original input string is ....',s
!!        write(*,*) 'processed output string is ...',nospace(s)
!!        if(nospace(s) == 'Thisisatest')then
!!           write(*,*)'nospace test passed'
!!        else
!!           write(*,*)'nospace test error'
!!        endif
!!     end program demo_nospace
!!
!!   Expected output
!!
!!     original input string is ....  This     is      a     test
!!     processed output string is ...Thisisatest
!!     nospace test passed
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function nospace(line)

! ident_37="@(#) M_strings nospace(3f) remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stretch(3f) - [M_strings:LENGTH] return string padded to at least
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function stretch(str,length,pattern,suffix) result(strout)
!!
!!     character(len=*),intent(in)         :: str
!!     integer,intent(in)                  :: length
!!     character(len=*)intent(in),optional :: pattern
!!     character(len=*)intent(in),optional :: suffix
!!     character(len=:),allocatable        :: strout
!!
!!##DESCRIPTION
!!    stretch(3f) pads a string with spaces to at least the specified
!!    length. If the trimmed input string is longer than the requested
!!    length the original string is returned trimmed of trailing spaces.
!!
!!##OPTIONS
!!    str      the input string to return trimmed, but then padded to
!!             the specified length if shorter than length
!!    length   The minimum string length to return
!!    pattern  optional string to use as padding. Defaults to a space.
!!    suffix   optional string to append to output string
!!
!!##RETURNS
!!    strout  The input string padded to the requested length or
!!            the trimmed input string if the input string is
!!            longer than the requested length.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!   program demo_stretch
!!    use M_strings, only : stretch
!!    implicit none
!!    character(len=10)            :: string='abcdefghij'
!!    character(len=:),allocatable :: answer
!!    integer                      :: i
!!       answer=stretch(string,5)
!!       write(*,'("[",a,"]")') answer
!!       answer=stretch(string,20)
!!       write(*,'("[",a,"]")') answer
!!       i=30
!!       write(*,*)
!!       write(*,'(1x,a,i0)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,'(1x,a,i7)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,*) &
!!        & stretch('CHAPTER 1 : The beginning ',i,suffix=': '), 1
!!       write(*,*) &
!!        & stretch('CHAPTER 2 : The end ',i,suffix=': '),1234
!!       write(*,*) &
!!        & stretch('APPENDIX ',i,suffix=': '),           1235
!!   end program demo_stretch
!!
!!   Results:
!!
!!    [abcdefghij]
!!    [abcdefghij          ]
!!
!!     CHAPTER 1 : The beginning ....1
!!     CHAPTER 2 : The end ..........1234
!!     APPENDIX .....................1235
!!
!!     CHAPTER 1 : The beginning ....      1
!!     CHAPTER 2 : The end ..........   1234
!!     APPENDIX .....................   1235
!!
!!     CHAPTER 1 : The beginning     :            1
!!     CHAPTER 2 : The end           :         1234
!!     APPENDIX                      :         1235
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function stretch(line,length,pattern,suffix) result(strout)

! ident_38="@(#) M_strings stretch(3f) return string padded to at least specified length"

character(len=*),intent(in)                  :: line
integer,intent(in)                           :: length
character(len=*),intent(in),optional         :: pattern
character(len=*),intent(in),optional         :: suffix
!-!character(len=max(length,len(trim(line)))) :: strout
character(len=:),allocatable                 :: strout
   if(present(pattern))then
      strout=pad(line,length,pattern)
   else
      strout=pad(line,length)
   endif
   if(present(suffix))then
      strout=strout//suffix
   endif
end function stretch
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    rpad(3f) - [M_strings:LENGTH] convert to a string and pad on the right
!!    to requested length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function rpad(valuein,length) result(strout)
!!
!!     class*,intent(in)       :: valuein(..)
!!     integer,intent(in)      :: length
!!
!!##DESCRIPTION
!!    rpad(3f) converts a scalar intrinsic value to a string and then pads
!!    it on the right with spaces to at least the specified length. If the
!!    trimmed input string is longer than the requested length the string
!!    is returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded on the left to
!!             the specified length if shorter than length. The input may be
!!             any intrinsic scalar which is converted to a cropped string
!!             much as if written with list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string padded to the requested length
!!            on the right with spaces.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!      program demo_rpad
!!       use M_strings, only : rpad
!!       implicit none
!!          write(*,'("[",a,"]")') rpad( 'my string', 20)
!!          write(*,'("[",a,"]")') rpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') rpad( '   my string', 20)
!!          write(*,'("[",a,"]")') rpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') rpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') rpad( valuein=1.0/9.0 , length=20)
!!      end program demo_rpad
!!
!!  Results:
!!
!!      > [my string           ]
!!      > [my string           ]
!!      > [my string           ]
!!      > [my string           ]
!!      > [42     ]
!!      > [0.111111112         ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rpad_scalar(valuein,length) result(strout)

! ident_39="@(#) M_strings rpad_scalar(3f) return value padded to at least specified length"

class(*),intent(in)              :: valuein
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout

character(len=96)                :: line
integer                          :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write(line,'(i0)') valuein
      type is (integer(kind=int16));   write(line,'(i0)') valuein
      type is (integer(kind=int32));   write(line,'(i0)') valuein
      type is (integer(kind=int64));   write(line,'(i0)') valuein
      type is (real(kind=real32));     write(line,'(1pg0)') valuein
      type is (real(kind=real64));     write(line,'(1pg0)') valuein
      type is (logical);               write(line,'(l1)') valuein
      type is (complex);               write(line,'("(",1pg0,",",1pg0,")")') valuein
      type is (character(len=*))
         if(present(length))then
            local_length = length
         else
            local_length = len(valuein)
         endif
         strout = pad(valuein,local_length,' ',clip=.true.)
         return
      class default
         stop '<ERROR>*rpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = pad( line, length, ' ', clip=.true. )
   else
      strout = crop( line )
   endif

end function rpad_scalar
!===================================================================================================================================
function rpad_vector(valuein,length) result(strout)

! ident_40="@(#) M_strings rpad_vector(3f) return strings or arguments converted to string right-padded to at least specified length"

class(*),intent(in)              :: valuein(:)
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout(:)
integer                          :: i
integer                          :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=rpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(rpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=rpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function rpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    cpad(3f) - [M_strings:LENGTH] convert to a cropped string and then
!!    centers the string to specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function cpad(valuein,length) result(strout)
!!
!!     class*,intent(in)       :: valuein(..)
!!     integer,intent(in)      :: length
!!
!!##DESCRIPTION
!!    cpad(3f) converts a scalar value to a cropped string and then pads
!!    it with spaces to center it to at least the specified length. If
!!    the trimmed input is longer than the requested length the string is
!!    returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded with spaces to
!!             center it at the the specified length if shorter than
!!             length. The input may be any intrinsic scalar which is
!!             converted to a cropped string much as if written with
!!             list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string center-padded to the requested length
!!            with spaces.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!      program demo_cpad
!!       use M_strings, only : cpad
!!       implicit none
!!          write(*,'("[",a,"]")') cpad( 'my string', 20)
!!          write(*,'("[",a,"]")') cpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') cpad( '   my string', 20)
!!          write(*,'("[",a,"]")') cpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') cpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') cpad( valuein=1.0/9.0 , length=20)
!!      end program demo_cpad
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function cpad_scalar(valuein,length) result(strout)

! ident_41="@(#) M_strings cpad_scalar(3f) convert value to string center-padded to at least specified length"

class(*),intent(in)              :: valuein
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout

character(len=96)                :: line
integer                          :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write( line, '(i0)' ) valuein
      type is (integer(kind=int16));   write( line, '(i0)' ) valuein
      type is (integer(kind=int32));   write( line, '(i0)' ) valuein
      type is (integer(kind=int64));   write( line, '(i0)' ) valuein
      type is (real(kind=real32));     write( line, '(1pg0)' ) valuein
      type is (real(kind=real64));     write( line, '(1pg0)' ) valuein
      type is (logical);               write( line, '(l1)' ) valuein
      type is (complex);               write( line, '("(",1pg0,",",1pg0,")")' ) valuein
      type is (character(len = *))
         if(present( length ) )then
            local_length = length
         else
            local_length = len(valuein)
         endif
         strout = adjustc( crop(valuein), local_length )
         return
      class default
         stop '<ERROR>*cpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = adjustc( crop(line), length )
   else
      strout = crop( line )
   endif

end function cpad_scalar
!===================================================================================================================================
function cpad_vector(valuein,length) result(strout)

! ident_42="@(#) M_strings cpad_vector(3f) return strings or arguments converted to string center-padded to at least specified length"

class(*),intent(in)              :: valuein(:)
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout(:)
integer                          :: i
integer                          :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=cpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(cpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=cpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function cpad_vector
!===================================================================================================================================
!>
!!
!!##NAME
!!    lpad(3f) - [M_strings:LENGTH] convert to a cropped string and then
!!    blank-pad on the left to requested length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lpad(valuein,length) result(strout)
!!
!!     class*,intent(in)       :: valuein(..)
!!     integer,intent(in)      :: length
!!
!!##DESCRIPTION
!!    lpad(3f) converts a scalar value to a cropped string and then pads
!!    it on the left with spaces to at least the specified length. If
!!    the trimmed input is longer than the requested length the string is
!!    returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded on the left to
!!             the specified length if shorter than length. The input may be
!!             any intrinsic scalar which is converted to a cropped string
!!             much as if written with list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string padded to the requested length
!!            on the left with spaces.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!      program demo_lpad
!!       use M_strings, only : lpad
!!       implicit none
!!          write(*,'("[",a,"]")') lpad( 'my string', 20)
!!          write(*,'("[",a,"]")') lpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') lpad( '   my string', 20)
!!          write(*,'("[",a,"]")') lpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') lpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') lpad( valuein=1.0/9.0 , length=20)
!!      end program demo_lpad
!!
!! Results:
!!
!!     > [           my string]
!!     > [           my string]
!!     > [           my string]
!!     > [           my string]
!!     > [     42]
!!     > [         0.111111112]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lpad_scalar(valuein,length) result(strout)

! ident_43="@(#) M_strings lpad_scalar(3f) convert value to string padded on left to at least specified length"

class(*),intent(in)              :: valuein
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout

character(len=96)                :: line
integer                          :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write(line,'(i0)') valuein
      type is (integer(kind=int16));   write(line,'(i0)') valuein
      type is (integer(kind=int32));   write(line,'(i0)') valuein
      type is (integer(kind=int64));   write(line,'(i0)') valuein
      type is (real(kind=real32));     write(line,'(1pg0)') valuein
      type is (real(kind=real64));     write(line,'(1pg0)') valuein
      type is (logical);               write(line,'(l1)') valuein
      type is (complex);               write(line,'("(",1pg0,",",1pg0,")")') valuein
      type is (character(len=*))
         if(present( length ))then
            local_length=length
         else
            local_length=len( valuein )
         endif
         strout = pad( valuein, local_length, ' ', right=.false., clip=.true. )
         return
      class default
         stop '<ERROR>*lpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = pad( line, length, ' ', clip=.true., right=.false. )
   else
      strout = crop( line )
   endif

end function lpad_scalar
!===================================================================================================================================
function lpad_vector(valuein,length) result(strout)

! ident_44="@(#) M_strings lpad_vector(3f) return vector of strings or arguments converted to string left-padded to at least specified length"

class(*),intent(in)              :: valuein(:)
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout(:)
integer                          :: i
integer                          :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=lpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(lpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=lpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function lpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    zpad(3f) - [M_strings:LENGTH] pad a string on the left with zeros to
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function zpad(valuein,length) result(strout)
!!
!!     class*,intent(in)           :: valuein(..)
!!     integer,intent(in),optional :: length
!!
!!##DESCRIPTION
!!    zpad(3f) crops the input string (or integer, which will be converted
!!    to a string) and then pads it on the left with zeros to the specified
!!    length.
!!
!!    Note that if the trimmed input string is already as long or longer
!!    than the requested length the trimmed original string is returned.
!!
!!    For strings representing unsigned numbers this is basically an
!!    alias for
!!
!!        strout=pad(str,length,'0',clip=.true.,right=.false.)
!!
!!    For integers the same is often done with internal WRITE(3f) statements
!!    such as
!!
!!        write(strout,'(i5.5)')ivalue
!!
!!    but unlike internal I/O the function call can be used in expressions
!!    or passed as a procedure argument.
!!
!!##OPTIONS
!!    valuein  The input value to left-pad. May be a scalar or vector
!!             string or integer. If the leftmost non-blank character is
!!             a sign character it is moved to the left-most position of
!!             the output.
!!    length   The minimum string length to return. If not present, the
!!             length of the input parameter VALUEIN is used. If the input
!!             value VALUEIN is an integer no zero padding occurs if LENGTH
!!             is not supplied.
!!
!!##RETURNS
!!    strout  A trimmed string padded on the left with zeros to
!!            the requested length
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!      program demo_zpad
!!       use M_strings, only : zpad
!!       implicit none
!!       character(len=*),parameter :: boxed='("[",a,"]",*(g0,1x))'
!!       integer :: lun, i
!!          print boxed, zpad( '111', 5),'basic use'
!!          print boxed, zpad( valuein=42 , length=7),'by argument name'
!!          print boxed, zpad( '  34567  ', 7),'cropped before padding'
!!          print boxed, zpad( '123456789', 5),'input longer than length'
!!          print boxed, zpad( '  +34567  ', 7),'starts with plus sign'
!!          print boxed, zpad( '  -34567  ', 7),'starts with minus sign'
!!          print boxed, zpad(1234),'some integers instead of strings'
!!          print boxed, zpad(-1234)
!!          print boxed, zpad(1234,8)
!!          print boxed, zpad(-1234,8)
!!          print boxed, zpad(''),'a null gets you nothing'
!!          print boxed, zpad('0'),'but blanks are used for default length'
!!          print boxed, zpad('0    ')
!!          print boxed, zpad('     ')
!!          print *, 'input value may be an array:'
!!          print '("[",a,"]")', zpad([1,10,100,1000,10000,100000],8)
!!
!!          ! example usage:
!!          ! open output_00085.dat
!!          i=85
!!          open(newunit=lun,file='output_'//zpad(i,5)//'.dat')
!!          close(unit=lun,status='delete')
!!
!!      end program demo_zpad
!!
!! Results:
!!
!!     > [00111]basic use
!!     > [0000042]by argument name
!!     > [0034567]cropped before padding
!!     > [123456789]input longer than length
!!     > [+0034567]starts with plus sign
!!     > [-0034567]starts with minus sign
!!     > [1234]some integers instead of strings
!!     > [-1234]
!!     > [00001234]
!!     > [-00001234]
!!     > []a null gets you nothing
!!     > [0]but blanks are used for default length
!!     > [00000]
!!     > [00000]
!!     >  input value may be an array:
!!     > [00000001]
!!     > [00000010]
!!     > [00000100]
!!     > [00001000]
!!     > [00010000]
!!     > [00100000]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function zpad_scalar(valuein,length) result(strout)

! ident_45="@(#) M_strings zpad_vector(3f) return string or argument converted to string zero-padded to at least specified length"

class(*),intent(in)              :: valuein
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout
character(len=4096)              :: line
integer                          :: local_length
   if(present(length))then
      local_length=length
   else
      local_length=-1
   endif
   select type(valuein)
      type is (integer(kind=int8));     write(line,'(i0)') valuein
      type is (integer(kind=int16));    write(line,'(i0)') valuein
      type is (integer(kind=int32));    write(line,'(i0)') valuein
      type is (integer(kind=int64));    write(line,'(i0)') valuein
      type is (real(kind=real32));      write(line,'(1pg0)') valuein
      type is (real(kind=real64));      write(line,'(1pg0)') valuein
      type is (logical);                write(line,'(l1)') valuein
      type is (character(len=*));       line=valuein
         if(local_length==-1)local_length=len(valuein)
      type is (complex);                write(line,'("(",1pg0,",",1pg0,")")') valuein
   end select
   if(local_length == -1)then
     strout=clip(line)
   else
      line=clip(line)//'  '
      if(scan(line(1:1),'+-') == 1)then
         strout= line(1:1)//pad(line(2:),local_length,'0',clip=.true.,right=.false.)
      else
         strout= pad(line,local_length,'0',clip=.true.,right=.false.)
      endif
   endif
end function zpad_scalar
!===================================================================================================================================
function zpad_vector(valuein,length) result(strout)

! ident_46="@(#) M_strings zpad_vector(3f) return vector of strings or arguments converted to string zero-padded to at least specified length"

class(*),intent(in)              :: valuein(:)
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout(:)
integer                          :: i
integer                          :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=zpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(zpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=zpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function zpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   pad(3f) - [M_strings:LENGTH] return string padded to at least
!!   specified length
!!   (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   function pad(str,length,pattern,right,clip) result(strout)
!!
!!    character(len=*)                           :: str
!!    integer,intent(in)                         :: length
!!    character(len=max(length,len(trim(line)))) :: strout
!!    character(len=*),intent(in),optional       :: pattern
!!    logical,intent(in),optional                :: right
!!    logical,intent(in),optional                :: clip
!!
!!##DESCRIPTION
!!   pad(3f) pads a string with a pattern to at least the specified
!!   length. If the trimmed input string is longer than the requested
!!   length the trimmed string is returned.
!!
!!##OPTIONS
!!   str      the input string to return trimmed, but then padded to
!!            the specified length if shorter than length
!!   length   The minimum string length to return
!!   pattern  optional string to use as padding. Defaults to a space.
!!   right    if true pads string on the right, else on the left
!!   clip     trim spaces from input string but otherwise retain length.
!!            Except for simple cases you typically would trim the input
!!            yourself.
!!
!!##RETURNS
!!   strout  The input string padded to the requested length or
!!           the trimmed input string if the input string is
!!           longer than the requested length.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!    program demo_pad
!!     use M_strings, only : pad
!!     implicit none
!!     character(len=10)            :: string='abcdefghij'
!!     character(len=:),allocatable :: answer
!!     integer                      :: i
!!     character(len=*),parameter   :: g='(*(g0))'
!!        answer=pad(string,5)
!!        write(*,'("[",a,"]")') answer
!!        answer=pad(string,20)
!!        write(*,'("[",a,"]")') answer
!!        i=30
!!        write(*,g)
!!        write(*,'(1x,a,1x,i0)') &
!!         & pad('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & pad('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & pad('APPENDIX ',i,'.'),                  1235
!!        write(*,*)
!!        write(*,'(1x,a,i7)') &
!!         & pad('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & pad('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & pad('APPENDIX ',i,'.'),                  1235
!!
!!         write(*,g)pad('12',5,'0',right=.false.)
!!
!!         write(*,g)pad('12345 ',30,'_',right=.false.)
!!         write(*,g)pad('12345 ',30,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',7,'_',right=.false.)
!!         write(*,g)pad('12345 ',7,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',6,'_',right=.false.)
!!         write(*,g)pad('12345 ',6,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',5,'_',right=.false.)
!!         write(*,g)pad('12345 ',5,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',4,'_',right=.false.)
!!         write(*,g)pad('12345 ',4,'_',right=.false.,clip=.true.)
!!    end program demo_pad
!!
!!  Results:
!!
!!  > [abcdefghij]
!!  > [abcdefghij          ]
!!  >
!!  >  CHAPTER 1 : The beginning .... 1
!!  >  CHAPTER 2 : The end .......... 1234
!!  >  APPENDIX ..................... 1235
!!  >
!!  >  CHAPTER 1 : The beginning ....      1
!!  >  CHAPTER 2 : The end ..........   1234
!!  >  APPENDIX .....................   1235
!!  > 00012
!!  > ________________________12345
!!  > _________________________12345
!!  > _12345
!!  > __12345
!!  > 12345
!!  > _12345
!!  > 12345
!!  > 12345
!!  > 12345
!!  > 12345
!!
!!##SEE ALSO
!!     adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f)
!!
!!     adjustc(3f), stretch(3f), lpad(3f), rpad(3f), cpad(3f), zpad(3f), lenset(3f)
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function pad(line,length,pattern,right,clip) result(strout)

!$@(#) M_strings::pad(3f): return string padded to at least specified length

character(len=*),intent(in)          :: line
integer,intent(in)                   :: length
character(len=*),intent(in),optional :: pattern
logical,optional,intent(in)          :: right
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: strout
logical                              :: local_right
logical                              :: local_clip
character(len=:),allocatable         :: local_pattern
character(len=:),allocatable         :: local_line

if(  present(right)    )then;  local_right=right;      else;  local_right=.true.;  endif
if(  present(clip)     )then;  local_clip=clip;        else;  local_clip=.false.;  endif
if(  present(pattern)  )then;  local_pattern=pattern;  else;  local_pattern=' ';   endif

if(len(local_pattern) == 0)then
   strout=line
else

   if(local_clip)then
      local_line=trim(adjustl(line))
      allocate(character(len=max(length,len(local_line))) :: strout)
   else
      local_line=line
      allocate(character(len=max(length,len(line))) :: strout)
   endif

   if(local_right)then
      strout(:)=local_line//repeat(local_pattern,len(strout)/len(local_pattern)+1)
   else
      strout(:)=repeat(local_pattern, ceiling(real(len(strout))/len(local_pattern)))
      strout(max(0,len(strout)-len(local_line))+1:)=local_line
   endif

endif
end function pad
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lenset(3f) - [M_strings:LENGTH] return string trimmed or padded to
!!                 specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lenset(str,length) result(strout)
!!
!!     character(len=*)                     :: str
!!     character(len=length)                :: strout
!!     integer,intent(in)                   :: length
!!
!!##DESCRIPTION
!!    lenset(3f) truncates a string or pads it with spaces to the specified
!!    length.
!!
!!##OPTIONS
!!    str     input string
!!    length  output string length
!!
!!##RESULTS
!!    strout  output string
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!     program demo_lenset
!!      use M_strings, only : lenset
!!      implicit none
!!      character(len=10)            :: string='abcdefghij'
!!      character(len=:),allocatable :: answer
!!         answer=lenset(string,5)
!!         write(*,'("[",a,"]")') answer
!!         answer=lenset(string,20)
!!         write(*,'("[",a,"]")') answer
!!     end program demo_lenset
!!
!!    Expected output:
!!
!!     [abcde]
!!     [abcdefghij          ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lenset(line,length) result(strout)

! ident_47="@(#) M_strings lenset(3f) return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    merge_str(3f) - [M_strings:LENGTH] pads strings to same length and
!!    then calls MERGE(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function merge_str(str1,str2,expr) result(strout)
!!
!!     character(len=*),intent(in),optional :: str1
!!     character(len=*),intent(in),optional :: str2
!!     logical,intent(in)              :: expr
!!     character(len=:),allocatable    :: strout
!!
!!##DESCRIPTION
!!    merge_str(3f) pads the shorter of str1 and str2 to the longest length
!!    of str1 and str2 and then calls MERGE(padded_str1,padded_str2,expr).
!!    It trims trailing spaces off the result and returns the trimmed
!!    string. This makes it easier to call MERGE(3f) with strings, as
!!    MERGE(3f) requires the strings to be the same length.
!!
!!    NOTE: STR1 and STR2 are always required even though declared optional.
!!          this is so the call "STR_MERGE(A,B,present(A))" is a valid call.
!!          The parameters STR1 and STR2 when they are optional parameters
!!          can be passed to a procedure if the options are optional on the
!!          called procedure.
!!
!!##OPTIONS
!!    STR1    string to return if the logical expression EXPR is true
!!    STR2    string to return if the logical expression EXPR is false
!!    EXPR    logical expression to evaluate to determine whether to return
!!            STR1 when true, and STR2 when false.
!!##RESULT
!!     MERGE_STR  a trimmed string is returned that is otherwise the value
!!                of STR1 or STR2, depending on the logical expression EXPR.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_merge_str
!!     use M_strings, only : merge_str
!!     implicit none
!!     character(len=:), allocatable :: answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10 == 10)
!!        write(*,'("[",a,"]")') answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10 /= 10)
!!        write(*,'("[",a,"]")') answer
!!     end program demo_merge_str
!!
!!   Expected output
!!
!!     [first string]
!!     [second string is longer]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

! ident_48="@(#) M_strings merge_str(3f) pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in),optional :: str1
character(len=*),intent(in),optional :: str2
character(len=:),allocatable         :: str1_local
character(len=:),allocatable         :: str2_local
logical,intent(in)                   :: expr
character(len=:),allocatable         :: strout
integer                              :: big
   if(present(str2))then
      str2_local=str2
   else
      str2_local=''
   endif
   if(present(str1))then
      str1_local=str1
   else
      str1_local=''
   endif
   big=max(len(str1_local),len(str2_local))
   ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning ''
   strout=trim(merge(lenset(str1_local,big),lenset(str2_local,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    squeeze(3f) - [M_strings:EDITING] delete adjacent duplicate occurrences
!!    of a character from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function squeeze(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    squeeze(3f) reduces adjacent duplicates of the specified character
!!    to a single character
!!
!!##OPTIONS
!!    STR     input string in which to reduce adjacent duplicate characters
!!            to a single character
!!    CHAR    The character to remove adjacent duplicates of
!!
!!##RETURNS
!!    OUTSTR  string with all contiguous adjacent occurrences of CHAR removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_squeeze
!!    use M_strings, only : squeeze
!!    implicit none
!!    character(len=:),allocatable :: strings(:)
!!
!!    strings=[ character(len=72) :: &
!!    &'', &
!!    &'"If I were two-faced,&
!!    &would I be wearing this one?" --- Abraham Lincoln',  &
!!    &'..1111111111111111111&
!!    &111111111111111111111111111111111111111111117777888', &
!!    &'I never give ''em hell,&
!!    &I just tell the truth, and they think it''s hell.',&
!!    &'                                                  &
!!    & --- Harry S Truman'    &
!!    &]
!!       call printme( trim(strings(1)), ' ' )
!!       call printme( strings(2:4),     ['-','7','.'] )
!!       call printme( strings(5),       [' ','-','r'] )
!!    contains
!!    impure elemental subroutine printme(str,chr)
!!    character(len=*),intent(in) :: str
!!    character(len=1),intent(in) :: chr
!!    character(len=:),allocatable :: answer
!!       write(*,'(a)')repeat('=',11)
!!       write(*,'("IN:   <<<",g0,">>>")')str
!!       answer=squeeze(str,chr)
!!       write(*,'("OUT:  <<<",g0,">>>")')answer
!!       write(*,'("LENS: ",*(g0,1x))')"from",len(str),"to",len(answer), &
!!               & "for a change of",len(str)-len(answer)
!!       write(*,'("CHAR: ",g0)')chr
!!    end subroutine printme
!!    end program demo_squeeze
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function squeeze(str,charp) result (outstr)

character(len=*),intent(in)  :: str
character(len=1),intent(in)  :: charp
character(len=:),allocatable :: outstr
character(len=1)             :: ch, last_one
integer                      :: i, pio ! position in output

   outstr=repeat(' ',len(str))      ! start with a string big enough to hold any output
   if(len(outstr)==0)return         ! handle edge condition
   last_one=str(1:1)                ! since at least this long start output with first character
   outstr(1:1)=last_one
   pio=1

   do i=2,len(str)
      ch=str(i:i)
      pio=pio+merge(0,1, ch == last_one.and.ch == charp) ! decide whether to advance before saving
      outstr(pio:pio)=ch  ! store new one or overlay the duplcation
      last_one=ch
   enddo

   outstr=outstr(:pio)              ! trim the output string to just what was set
end function squeeze
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace
!!    to a single character (or nothing)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function compact(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    COMPACT(3f) converts multiple spaces, tabs and control characters
!!    (called "whitespace") to a single character or nothing. Leading
!!    whitespace is removed.
!!
!!##OPTIONS
!!    STR     input string to reduce or remove whitespace from
!!    CHAR    By default the character that replaces adjacent
!!            whitespace is a space. If the optional CHAR parameter is supplied
!!            it will be used to replace the whitespace. If a null character is
!!            supplied for CHAR whitespace is removed.
!!
!!##RETURNS
!!    OUTSTR  string of same length as input string but with all contiguous
!!            whitespace reduced to a single space and leading whitespace
!!            removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_compact
!!     use M_strings, only : compact
!!     implicit none
!!     ! produces 'This is a test               '
!!     write(*,*)compact('  This     is      a     test  ')
!!     ! produces 'Thisisatest                  '
!!     write(*,*)compact('  This     is      a     test  ',char='')
!!     ! produces 'This:is:a:test               '
!!     write(*,*)compact('  This     is      a     test  ',char=':')
!!     ! note CHAR is used to replace the whitespace, but if CHAR is
!!     ! in the original string it is just copied
!!     write(*,*)compact('A  AA    A   AAAAA',char='A')
!!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA'
!!     ! not 'A'
!!    end program demo_compact
!!
!!    Expected output
!!
!!     >This is a test
!!     >Thisisatest
!!     >This:is:a:test
!!     >AAAAAAAAAAAA
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!elemental pure function compact(str,char) result (outstr)
function compact(str,char) result (outstr)

! ident_49="@(#) M_strings compact(3f) Converts white-space to single spaces; removes leading spaces"

character(len=*),intent(in)          :: str
character(len=*),intent(in),optional :: char
character(len=len(str))              :: outstr
character(len=1)                     :: ch
integer                              :: i
integer                              :: position_in_output
logical                              :: last_was_space
character(len=1)                     :: char_p
logical                              :: nospace
if(present(char))then
   char_p=char
   if(len(char) == 0)then
      nospace=.true.
   else
      nospace=.false.
   endif
else
   char_p=' '
   nospace=.false.
endif
   outstr=' '
   last_was_space=.false.
   position_in_output=0

   IFSPACE: do i=1,len_trim(str)
     ch=str(i:i)
     select case(iachar(ch))
       case(0:32,127)                                         ! space or tab character or control character
         if(position_in_output == 0)then                      ! still at beginning so ignore leading whitespace
            cycle IFSPACE
         elseif(.not.last_was_space) then                     ! if have not already put out a space output one
           if(.not.nospace)then
              position_in_output=position_in_output+1
              outstr(position_in_output:position_in_output)=char_p
           endif
         endif
         last_was_space=.true.
       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it
         position_in_output=position_in_output+1
         outstr(position_in_output:position_in_output)=ch
         last_was_space=.false.
     end select
   enddo IFSPACE

end function compact
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     noesc(3f) - [M_strings:NONALPHA] convert non-printable characters
!!     to a space
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental function noesc(INSTR)
!!
!!     character(len=*),intent(in) :: INSTR
!!     character(len=len(instr))   :: noesc
!!
!!##DESCRIPTION
!!      Convert non-printable characters to a space.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_noesc
!!
!!     use M_strings, only : noesc
!!     implicit none
!!     character(len=128) :: ascii
!!     character(len=128) :: cleared
!!     integer            :: i
!!     ! fill variable with base ASCII character set
!!     do i=1,128
!!        ascii(i:i)=char(i-1)
!!     enddo
!!     cleared=noesc(ascii)
!!     write(*,*)'characters and their ADE (ASCII Decimal Equivalent)'
!!     call ade(ascii)
!!     write(*,*)'Cleared of non-printable characters'
!!     call ade(cleared)
!!     write(*,*)'Cleared string:'
!!     write(*,*)cleared
!!     contains
!!       subroutine ade(string)
!!       implicit none
!!       ! the string to print
!!       character(len=*),intent(in) :: string
!!       ! number of characters in string to print
!!       integer :: lgth
!!       ! counter used to step thru string
!!       integer :: i
!!          ! get trimmed length of input string
!!          lgth=len_trim(string(:len(string)))
!!
!!          ! replace lower unprintable characters with spaces
!!          write(*,101)(merge(string(i:i),' ',&
!!          & iachar(string(i:i)) >= 32        &
!!          & .and.                            &
!!          & iachar(string(i:i)) <= 126)      &
!!          & ,i=1,lgth)
!!
!!          ! print ADE value of character underneath it
!!          write(*,202)     (iachar(string(i:i))/100,    i=1,lgth)
!!          write(*,202)(mod( iachar(string(i:i)),100)/10,i=1,lgth)
!!          write(*,202)(mod((iachar(string(i:i))),10),   i=1,lgth)
!!       ! format for printing string characters
!!       101   format(*(a1:))
!!       ! format for printing ADE values
!!       202   format(*(i1:))
!!       end subroutine ade
!!     end program demo_noesc
!!
!!    Expected output
!!
!!    The string is printed with the ADE value vertically beneath.
!!    The original string has all the ADEs from 000 to 127. After
!!    NOESC(3f) is called on the string all the "non-printable"
!!    characters are replaced with a space (ADE of 032).
!!
!!   characters and their ADE (ASCII Decimal Equivalent)
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    0000000000000000000000000000000000000000001111111111111111111111111111
!!    >00000000001111111111222222222233333333334444444444555555555566666666
!!    667777777777888888888899999999990000000000111111111122222222
!!    >012345678901234567890123456789012345678901234567890123456789012345678
!!    90123456789012345678901234567890123456789012345678901234567
!!
!!   Cleared of non-printable characters
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    000000000000000000000000000000000000000000111111111111111111111111111
!!    >3333333333333333333333333333333333333333444444444455555555
!!    556666666666777777777788888888889999999999000000000011111111112222222
!!    >2222222222222222222222222222222223456789012345678901234567
!!    890123456789012345678901234567890123456789012345678901234567890123456
!!
!!   Cleared string:
!!
!!    >                                  !"#$%&'()*+,-./0123456789:;<=>?@
!!    ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function noesc(INSTR)

! ident_50="@(#) M_strings noesc(3f) convert non-printable characters to a space"

character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
!-----------------------------------------------------------------------------------------------------------------------------------
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic <= 31.or.ic == 127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_value(3f) - [M_strings:TYPE] subroutine returns numeric
!!      value from string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine string_to_value(chars,valu,ierr)
!!
!!     character(len=*),intent(in)              :: chars   ! input string
!!     integer|real|doubleprecision,intent(out) :: valu
!!     integer,intent(out)                      :: ierr
!!
!!##DESCRIPTION
!!    Returns a numeric value from a numeric character string.
!!
!!    Works with any g-format input, including integer, real, and
!!    exponential. If the input string begins with "B", "Z", or "O"
!!    and otherwise represents a positive whole number it is assumed to
!!    be a binary, hexadecimal, or octal value. If the string contains
!!    commas they are removed. If the string is of the form NN:MMM... or
!!    NN#MMM then NN is assumed to be the base of the whole number.
!!
!!    If an error occurs in the READ, IOSTAT is returned in IERR and
!!    value is set to zero. if no error occurs, IERR=0.
!!
!!##OPTIONS
!!       CHARS  input string to read numeric value from
!!
!!##RETURNS
!!    VALU   numeric value returned. May be INTEGER, REAL, or
!!              DOUBLEPRECISION.
!!    IERR   error flag (0 == no error)
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_string_to_value
!!     use M_strings, only: string_to_value
!!     implicit none
!!     real :: value
!!     integer :: ierr
!!     character(len=80) :: string
!!        string=' -40.5e-2 '
!!        call string_to_value(string,value,ierr)
!!        write(*,*) 'value of string ['//trim(string)//'] is ',value
!!    end program demo_string_to_value
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine a2r(chars,valu,ierr)

! ident_51="@(#) M_strings a2r(3fp) subroutine returns real value from string"

character(len=*),intent(in) :: chars                      ! input string
real,intent(out)            :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(ierr == 0)then
      if(valu8 <= huge(valu))then
         valu=real(valu8)
      else
         call journal('sc','*a2r*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2r
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2i(chars,valu,ierr)

! ident_52="@(#) M_strings a2i(3fp) subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_53="@(#) M_strings a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o works with any g-format input, including integer, real, and exponential.
!  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!    IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg /= '')then
            call journal('sc','*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    s2v(3f) - [M_strings:TYPE] function returns doubleprecision
!!    numeric value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2v(string[,ierr][,onerr])
!!
!!     character(len=*)             :: string
!!     doubleprecision              :: s2v
!!     integer,intent(out),optional :: ierr
!!     class(*),intent(in),optional :: onerr
!!
!!##DESCRIPTION
!!    This function converts a string to a DOUBLEPRECISION numeric value.
!!
!!    The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended
!!    to take CHARACTER variables. The KIND= keyword is not supported
!!    on the extensions.
!!
!!##OPTIONS
!!
!!     string   holds string assumed to represent a numeric value
!!     ierr     If an error occurs the program is stopped if the optional
!!              parameter IERR is not present. If IERR returns a non-zero
!!              value an error occurred.
!!     onerr    The value to return on error. A value of NaN is
!!              returned on error by default.
!!
!!##RETURNS
!!     s2v      numeric value read from string
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_s2v
!!
!!     use M_strings, only: s2v, int, real, dble
!!     implicit none
!!     character(len=8)              :: s=' 10.345 '
!!     integer                       :: i
!!     character(len=14),allocatable :: strings(:)
!!     doubleprecision               :: dv
!!     integer                       :: errnum
!!
!!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!     strings=[&
!!     &' 10.345       ',&
!!     &'+10           ',&
!!     &'    -3        ',&
!!     &'    -4.94e-2  ',&
!!     &'0.1           ',&
!!     &'12345.678910d0',&
!!     &'              ',& ! Note: will return zero without an error message
!!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!     &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!     ! a numeric value is returned,
!!     ! so it can be used in numeric expression
!!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0
!!     write(*,*)
!!     write(*,*)' STRING            VALUE                    ERROR_NUMBER'
!!     do i=1,size(strings)
!!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
!!        ! as it does I/O when errors occur, so called on a separate line
!!        dv=s2v(strings(i),errnum)
!!        write(*,*) strings(i)//'=',dv,errnum
!!     enddo
!!     write(*,*)"Extended intrinsics"
!!     write(*,*)'given inputs:',s,strings(:8)
!!     write(*,*)'INT(3f):',int(s),int(strings(:8))
!!     write(*,*)'REAL(3f):',real(s),real(strings(:8))
!!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8))
!!     write(*,*)"That's all folks!"
!!
!!     end program demo_s2v
!!
!!    Expected output
!!
!!     >1/2 value of string is    5.1725000000000003
!!     >
!!     > STRING            VALUE                    ERROR_NUMBER
!!     > 10.345       =   10.345000000000001                0
!!     >+10           =   10.000000000000000                0
!!     >    -3        =  -3.0000000000000000                0
!!     >    -4.94e-2  =  -4.9399999999999999E-002           0
!!     >0.1           =  0.10000000000000001                0
!!     >12345.678910d0=   12345.678910000001                0
!!     >              =   0.0000000000000000                0
!!     >1 2 1 2 1 . 0 =   12121.000000000000                0
!!     >*a2d* - cannot produce number from string [WHAT?]
!!     >*a2d* - [Bad value during floating point read]
!!     >WHAT?         =   0.0000000000000000             5010
!!     >Extended intrinsics
!!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1
!!     12345.678910d0 1 2 1 2 1 . 0
!!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121
!!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000
!!     -4.94000018E-02
!!     >          0.100000001 12345.6787 0.00000000 12121.0000
!!     >DBLE(3f): 10.345000000000001 10.345000000000001
!!     10.000000000000000
!!     >          -3.0000000000000000 -4.9399999999999999E-002
!!     0.10000000000000001
!!     >          12345.678910000001 0.0000000000000000
!!     12121.000000000000
!!     >That's all folks!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!!##PROCEDURE:
!! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs
!!##VERSION:     2.0, 20160704
!! AUTHOR:      John S. Urban
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

! ident_54="@(#) M_strings s2v(3f) returns doubleprecision number from string;zero if error occurs"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(stderr,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      dble(3f) - [M_strings:TYPE] overloads DBLE(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function dble(string)
!!
!!     character(len=*) :: string
!!     integer          :: dble
!!
!!##DESCRIPTION
!!    dble(3f) returns a DOUBLE value when given a numeric representation of a
!!    numeric value. This overloads the DBLE(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to a dble value
!!
!!##RETURNS
!!    DBLE  double precision value represented by input string
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_dble
!!      use M_strings, only: dble
!!      implicit none
!!      write(*,*)dble('100'),dble('20.4')
!!      write(*,*)'dble still works',dble(20),dble(20.4)
!!      write(*,*)'elemental',&
!!      & dble([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_dble
!!
!! Results:
!!
!!      >    100.00000000000000        20.399999999999999
!!      >  dble still works   20.000000000000000 20.399999618530273
!!      >  elemental   10.00000000000000  20.30000000000000
!!      >  20.50000000000000 20.60000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      real(3f) - [M_strings:TYPE] overloads REAL(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function real(string)
!!
!!     character(len=*) :: string
!!     integer          :: real
!!
!!##DESCRIPTION
!!    real(3f) returns a REAL value when given a numeric representation of a
!!    numeric value. This overloads the REAL(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to a real value
!!
!!##RETURNS
!!       REAL  real value represented by input string
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_real
!!      use M_strings, only: real
!!      implicit none
!!      write(*,*)real('100'),real('20.4')
!!      write(*,*)'real still works',real(20)
!!      write(*,*)'elemental',&
!!      & real([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_real
!!
!! Results:
!!
!!      >    100.000000       20.3999996
!!      >  real still works   20.0000000
!!      >  elemental   10.0000000  20.2999992  20.5000000  20.6000004
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
impure elemental real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      int(3f) - [M_strings:TYPE] overloads INT(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function int(string)
!!
!!     character(len=*) :: string
!!     integer(kind=int32) :: int
!!
!!##DESCRIPTION
!!    int(3f) returns an integer when given a numeric representation of a
!!    numeric value. This overloads the INT(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to an INT32 integer
!!
!!##RETURNS
!!       INT  integer represented by input string
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_int
!!      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!      use M_strings, only: int
!!      implicit none
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)int('100'),int('20.4')
!!         write(*,g)'intrinsic int(3f) still works',int(20,int32)
!!         write(*,g)'elemental',&
!!         & int([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_int
!!
!! Results:
!!
!!     > 100 20
!!     > intrinsic int(3f) still works 20
!!     > elemental 10 20 20 20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      nint(3f) - [M_strings:TYPE] overloads NINT(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function nint(string)
!!
!!     character(len=*) :: string
!!     integer          :: nint
!!
!!##DESCRIPTION
!!    nint(3f) returns an integer when given a numeric representation of a
!!    numeric value. This overloads the NINT(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to an integer
!!
!!##RETURNS
!!       NINT  integer represented by input string
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_nint
!!      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!      use M_strings, only: nint
!!      implicit none
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)nint('100'),nint('20.4')
!!         write(*,g)'intrinsic nint(3f) still works',nint(20.4)
!!         write(*,g)'elemental',&
!!         & nint([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_nint
!!
!! Results:
!!
!!     > 100 20
!!     > intrinsic nint(3f) still works 20
!!     > elemental 10 20 21 21
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
impure elemental integer function nint_s2v(chars)
character(len=*),intent(in) :: chars
   nint_s2v=nint(s2v(chars))
end function nint_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      value_to_string(3f) - [M_strings:TYPE] return numeric string
!!      from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine value_to_string(value,chars[,lgth,ierr,fmt,trimz])
!!
!!     character(len=*) :: chars  ! minimum of 23 characters required
!!     !--------
!!     ! VALUE may be any <em>one</em> of the following types:
!!     doubleprecision,intent(in)               :: value
!!     real,intent(in)                          :: value
!!     integer,intent(in)                       :: value
!!     logical,intent(in)                       :: value
!!     !--------
!!     character(len=*),intent(out)             :: chars
!!     integer,intent(out),optional             :: lgth
!!     integer,optional                         :: ierr
!!     character(len=*),intent(in),optional     :: fmt
!!     logical,intent(in)                       :: trimz
!!
!!##DESCRIPTION
!!    value_to_string(3f) returns a numeric representation of a numeric
!!    value in a string given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the string using internal writes. It
!!    then removes trailing zeros from non-zero values, and left-justifies
!!    the string.
!!
!!##OPTIONS
!!       VALUE   input value to be converted to a string
!!       FMT     You may specify a specific format that produces a string
!!               up to the length of CHARS; optional.
!!       TRIMZ   If a format is supplied the default is not to try to trim
!!               trailing zeros. Set TRIMZ to .true. to trim zeros from a
!!               string assumed to represent a simple numeric value.
!!
!!##RETURNS
!!       CHARS   returned string representing input value, must be at least
!!               23 characters long; or what is required by optional FMT
!!               if longer.
!!       LGTH    position of last non-blank character in returned string;
!!               optional.
!!       IERR    If not zero, error occurred; optional.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_value_to_string
!!      use M_strings, only: value_to_string
!!      implicit none
!!      character(len=80) :: string
!!      integer           :: lgth
!!         call value_to_string(3.0/4.0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(3.0/4.0,string,lgth,fmt='')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string&
!!         &(3.0/4.0,string,lgth,fmt='("THE VALUE IS ",g0)')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1234,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1.0d0/3.0d0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!      end program demo_value_to_string
!!
!!    Expected output
!!
!!     The value is [0.75]
!!     The value is [      0.7500000000]
!!     The value is [THE VALUE IS .750000000]
!!     The value is [1234]
!!     The value is [0.33333333333333331]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

! ident_55="@(#) M_strings value_to_string(3fp) subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         call journal('*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
       ! cannot currently do I/O from a function being called from I/O
       !write(stderr,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      v2s(3f) - [M_strings:TYPE] return numeric string from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function v2s(value) result(outstr)
!!
!!        integer|real|doubleprecision|logical,intent(in ) :: value
!!        character(len=:),allocatable :: outstr
!!        character(len=*),optional,intent(in) :: fmt
!!
!!##DESCRIPTION
!!    v2s(3f) returns a representation of a numeric value as a
!!    string when given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the strings using internal WRITE()
!!    statements. Trailing zeros are removed from non-zero values, and the
!!    string is left-justified.
!!
!!##OPTIONS
!!    VALUE   input value to be converted to a string
!!    FMT     format can be explicitly given, but is limited to
!!            generating a string of eighty or less characters.
!!
!!##RETURNS
!!    OUTSTR  returned string representing input value,
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_v2s
!!    use M_strings, only: v2s
!!    write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']'
!!    write(*,*) 'The value of 1234    is ['//v2s(1234)//']'
!!    write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']'
!!    write(*,*) 'The value of .false. is ['//v2s(.false.)//']'
!!    write(*,*) 'The value of .true. is  ['//v2s(.true.)//']'
!!    end program demo_v2s
!!
!!   Expected output
!!
!!     The value of 3.0/4.0 is [0.75]
!!     The value of 1234    is [1234]
!!     The value of 0d0     is [0]
!!     The value of .false. is [F]
!!     The value of .true. is  [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function d2s(dvalue,fmt) result(outstr)

! ident_56="@(#) M_strings d2s(3fp) private function returns string given doubleprecision value"

doubleprecision,intent(in)   :: dvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(dvalue,string,fmt=fmt)
   else
      call value_to_string(dvalue,string)
   endif
   outstr=trim(string)
end function d2s
!===================================================================================================================================
function r2s(rvalue,fmt) result(outstr)

! ident_57="@(#) M_strings r2s(3fp) private function returns string given real value"

real,intent(in)              :: rvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(rvalue,string,fmt=fmt)
   else
      call value_to_string(rvalue,string)
   endif
   outstr=trim(string)
end function r2s
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

! ident_58="@(#) M_strings i2s(3fp) private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
function l2s(lvalue,fmt) result(outstr)

! ident_59="@(#) M_strings l2s(3fp) private function returns string given logical value"

logical,intent(in)           :: lvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)             :: string
   if(present(fmt))then
      call value_to_string(lvalue,string,fmt=fmt)
   else
      call value_to_string(lvalue,string)
   endif
   outstr=trim(string)
end function l2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isnumber(3f) - [M_strings:TYPE] determine if a string represents a number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function isnumber(str,msg)
!!
!!     character(len=*),intent(in)  :: str
!!     character(len=:),intent(out),allocatable,optional  :: msg
!!
!!##DESCRIPTION
!!     ISNUMBER(3f) returns a value greater than zero if the string represents
!!     a number, and a number less than or equal to zero if it is a bad number.
!!     Blank characters are ignored.
!!
!!##OPTIONS
!!     str  the string to evaluate as to whether it represents a numeric value
!!          or not
!!     msg  An optional message describing the string
!!
!!##RETURNS
!!     isnumber  the following values are returned
!!
!!                1 for an integer             [-+]NNNNN
!!                2 for a whole number         [-+]NNNNN.
!!                3 for a real value           [-+]NNNNN.MMMM
!!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!!
!!               values less than 1 represent an error
!!
!!##EXAMPLES
!!
!!   As the example shows, you can use an internal READ(3f) along with the
!!   IOSTAT= parameter to check (and read) a string as well.
!!
!!     program demo_isnumber
!!     use M_strings, only : isnumber
!!     implicit none
!!     character(len=256) :: line
!!     real               :: value
!!     integer            :: ios1, ios2
!!     integer            :: answer
!!     character(len=256) :: message
!!     character(len=:),allocatable :: description
!!        write(*,*)'Begin entering values, one per line'
!!        do
!!           read(*,'(a)',iostat=ios1)line
!!           !
!!           ! try string as number using list-directed input
!!           line=''
!!           read(line,*,iostat=ios2,iomsg=message) value
!!           if(ios2 == 0)then
!!              write(*,*)'VALUE=',value
!!           elseif( is_iostat_end(ios1) ) then
!!              stop 'end of file'
!!           else
!!              write(*,*)'ERROR:',ios2,trim(message)
!!           endif
!!           !
!!           ! try string using isnumber(3f)
!!           answer=isnumber(line,msg=description)
!!           if(answer > 0)then
!!              write(*,*) &
!!              & ' for ',trim(line),' ',answer,':',description
!!           else
!!              write(*,*) &
!!              & ' ERROR for ',trim(line),' ',answer,':',description
!!           endif
!!           !
!!        enddo
!!     end program demo_isnumber
!!
!!  Example run
!!
!!    > Begin entering values
!!    > ERROR:          -1 End of file
!!    >  ERROR for            -1 :null string
!!    >10
!!    > VALUE=   10.0000000
!!    >  for 10            1 :integer
!!    >20
!!    > VALUE=   20.0000000
!!    >  for 20            1 :integer
!!    >20.
!!    > VALUE=   20.0000000
!!    >  for 20.            2 :whole number
!!    >30.1
!!    > VALUE=   30.1000004
!!    >  for 30.1            3 :real number
!!    >3e1
!!    > VALUE=   30.0000000
!!    >  for 3e1            4 :value with exponent
!!    >1-2
!!    > VALUE=   9.99999978E-03
!!    >  for 1-2            4 :value with exponent
!!    >100.22d-4
!!    > VALUE=   1.00220004E-02
!!    >  for 100.22d-4            4 :value with exponent
!!    >1--2
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1--2           -5 :bad number
!!    >e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e           -6 :missing leading value before exponent
!!    >e1
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e1           -6 :missing leading value before exponent
!!    >1e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e           -3 :missing exponent
!!    >1e+
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+           -4 :missing exponent after sign
!!    >1e+2.0
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+2.0           -5 :bad number
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function isNumber(string,msg,verbose)

! ident_60="@(#) M_strings isnumber(3f) Determines if a string is a number of not."

character(len=*),intent(in)    :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                      :: verbose
integer                      :: isnumber

integer             :: i,iend
character(len=1),allocatable :: z(:)
character(len=:),allocatable :: message
logical                      :: founddigit
logical                      :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=switch(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend == 0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)) /= 0) i=i+1  ! skip optional leading sign
      if(i > iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i > iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i) == '.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i > iend)then                ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)) /= 0)then
         i=i+1
         if(i == 2)then
            isnumber=-6                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i > iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)) /= 0) i=i+1
      if(i > iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i <= iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_strings:TYPE] Delete trailing zeros from
!!    numeric decimal string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros_
!!       use M_strings, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          write(*,*)trimzeros_('123.450000000000')
!!          write(*,*)trimzeros_('12345')
!!          write(*,*)trimzeros_('12345.')
!!          write(*,*)trimzeros_('12345.00e3')
!!       end program demo_trimzeros_
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_61="@(#) M_strings trimzeros_(3fp) Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)               :: string
character(len=len(string) + 2) :: str
character(len=len(string))     :: exp        ! the exponent string if present
integer                        :: ipos       ! where exponent letter appears if present
integer                        :: i, ii
   str = string                              ! working copy of string
   ipos = scan(str, 'eEdD')                  ! find end of real number if string uses exponent notation
   if (ipos > 0) then                        ! letter was found
      exp = str(ipos:)                       ! keep exponent string so it can be added back as a suffix
      str = str(1:ipos - 1)                  ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if (index(str, '.') == 0) then            ! if no decimal character in original string add one to end of string
      ii = len_trim(str)
      str(ii + 1:ii + 1) = '.'               ! add decimal to end of string
   endif
   do i = len_trim(str), 1, -1               ! scanning from end find a non-zero character
      select case (str(i:i))
      case ('0')                             ! found a trailing zero so keep trimming
         cycle
      case ('.')                             ! found a decimal character at end of remaining string
         if (i <= 1) then
            str = '0'
         else
            str = str(1:i - 1)
         endif
         exit
      case default
         str = str(1:i)                      ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if (ipos > 0) then                        ! if originally had an exponent place it back on
      string = trim(str)//trim(exp)
   else
      string = str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    listout(3f) - [M_strings:NUMERIC] expand a list of numbers where negative
!!    numbers denote range ends (1 -10 means 1 thru 10)
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine listout(icurve_lists,icurve_expanded,inums,ierr)
!!
!!    integer,intent(in)    :: icurve_lists(:)
!!    integer,intent(out)   :: icurve_expanded(:)
!!    integer,intent(out)   :: inums
!!    integer,intent(out)   :: ierr
!!
!!##DESCRIPTION
!!    expand a list of whole numbers where negative numbers indicate a range.
!!    So [10,-20] would be expanded to [10,11,12,13,14,15,16,17,18,19,20].
!!
!!##OPTIONS
!!    icurve_lists(:)      input array
!!
!!##RETURNS
!!    icurve_expanded(:)   output array; assumed large enough to hold
!!                         returned list
!!    inums                number of icurve_expanded numbers on output
!!    ierr                 zero if no error occurred
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_listout
!!     use M_strings, only : listout
!!     implicit none
!!     integer,allocatable :: icurve_lists(:)
!!     integer :: icurve_expanded(1000)
!!     ! icurve_lists is input array
!!     integer :: inums
!!     ! icurve_expanded is output array
!!     integer :: i
!!     ! number of icurve_lists values on input,
!!     ! number of icurve_expanded numbers on output
!!     integer :: ierr
!!        icurve_lists=[1, 20, -30, 101, 100, 99, 100, -120, 222, -200]
!!        inums=size(icurve_lists)
!!        call listout(icurve_lists,icurve_expanded,inums,ierr)
!!        if(ierr == 0)then
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        else
!!           write(*,'(a,i0)')'error occurred in *listout* ',ierr
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        endif
!!     end program demo_listout
!!
!! Results:
!!
!!     > 1 20 21 22 23
!!     > 24 25 26 27 28
!!     > 29 30 101 100 99
!!     > 100 101 102 103 104
!!     > 105 106 107 108 109
!!     > 110 111 112 113 114
!!     > 115 116 117 118 119
!!     > 120 222 221 220 219
!!     > 218 217 216 215 214
!!     > 213 212 211 210 209
!!     > 208 207 206 205 204
!!     > 203 202 201 200
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine listout(icurve_lists,icurve_expanded,inums_out,ierr)

! ident_62="@(#) M_strings listout(3f) copy icurve_lists to icurve_expanded expanding negative numbers to ranges (1 -10 means 1 thru 10)"

!   Created: 19971231
integer,intent(in)    :: icurve_lists(:)             ! input array
integer,intent(out)   :: icurve_expanded(:)          ! output array
integer,intent(out)   :: inums_out                   ! number of icurve_expanded numbers on output
integer,intent(out)   :: ierr                        ! status variable

character(len=80)     :: temp1
integer               :: i80, i90
integer               :: imin, imax
integer               :: idirection, icount
integer               :: iin
integer               :: inums_max

   ierr=0
   icurve_expanded=0                          ! initialize output array
   inums_out=0                                ! initialize number of significant values in output array

   inums_max=size(icurve_expanded)
   if(inums_max == 0)then
      ierr=-2
      return
   endif

   iin=size(icurve_lists)
   if(iin > 0)then
      icurve_expanded(1)=icurve_lists(1)
   endif

   icount=2
      do i90=2,iin
         if(icurve_lists(i90) < 0)then
            imax=abs(icurve_lists(i90))
            imin=abs(icurve_lists(i90-1))
            if(imin > imax)then
               idirection=-1
               imin=imin-1
            elseif(imax > imin)then
               idirection=1
               imin=imin+1
            else
               idirection=1
            endif
            do i80=imin,imax,idirection
               if(icount > inums_max) then
                  write(temp1,'(a,i5,a)')'*listout* only ',inums_max,' values allowed'
                  ierr=-1
                  call journal(temp1)
                  inums_out=icount-1
                  exit
               endif
               icurve_expanded(icount)=i80
               icount=icount+1
            enddo
         else
            icurve_expanded(icount)=icurve_lists(i90)
            icount=icount+1
         endif
      enddo
   inums_out=icount-1

end subroutine listout
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     quote(3f) - [M_strings:QUOTES] add quotes to string as if written
!!     with list-directed output
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed output. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str    input string to add quotes to, using the rules of
!!           list-directed output (single quotes are replaced by two
!!           adjacent quotes)
!!    mode   alternate quoting methods are supported:
!!
!!             DOUBLE   default. replace quote with double quotes
!!             ESCAPE   replace quotes with backslash-quote instead of
!!                      double quotes
!!
!!    clip   default is to trim leading and trailing spaces from the
!!           string. If CLIP is .FALSE. spaces are not trimmed
!!
!!##RESULT
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_quote
!!    use M_strings, only : quote
!!    implicit none
!!    integer                      :: i
!!    character(len=*),parameter   :: f='(*(g0))'
!!    character(len=:),allocatable :: str
!!    character(len=80),parameter  :: data(3)=[character(len=80)::&
!!       'test string',&
!!       'quote="',&
!!       '"word1" "word2"']
!!       do i=1,size(data)
!!          ! the original string
!!          write(*,'(a)')'ORIGINAL      '//trim(data(i))
!!
!!          ! the string processed by quote(3f)
!!          str=quote(data(i))
!!          write(*,'(a)')'QUOTED        '//str
!!
!!          ! write the string list-directed to compare the results
!!          write(*,f,advance='no') 'LIST DIRECTED'
!!          ! default is often NONE or APOSTROPHE
!!          write(*,*,delim='quote') trim(data(i))
!!       enddo
!!    end program demo_quote
!!
!! Results:
!!
!!  > ORIGINAL      test string
!!  > QUOTED        "test string"
!!  > LIST DIRECTED "test string"
!!  > ORIGINAL      quote="
!!  > QUOTED        "quote="""
!!  > LIST DIRECTED "quote="""
!!  > ORIGINAL      "word1" "word2"
!!  > QUOTED        """word1"" ""word2"""
!!  > LIST DIRECTED """word1"" ""word2"""
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode

   if(present(clip))then
      if(clip)then
         quoted_str=adjustl(str)
      else
         quoted_str=str
      endif
   else
      quoted_str=str
   endif

   local_mode=merge_str(mode,'DOUBLE',present(mode))

   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace(quoted_str,'"','\"'))//double_quote
   case default
      call journal('sc','*quote* ERROR: unknown quote mode ',local_mode)
      quoted_str=str
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     unquote(3f) - [M_strings:QUOTES] remove quotes from string as if
!!     read with list-directed input
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!
!!##RESULT
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_unquote
!!       use M_strings, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: msg
!!       integer                      :: ios
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=ios,iomsg=msg)quoted_str
!!          if(ios /= 0)then
!!             write(*,*)trim(msg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=ios,iomsg=msg)dummy
!!          if(ios /= 0)then
!!             write(*,*)trim(msg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!    end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=iachar(esc)                            ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen >= 1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1) == single_quote)then
         quote=iachar(single_quote)
      else
         quote=iachar(double_quote)
      endif
   else
      quote=iachar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=iachar(quoted_str(i:i))
      if(before == iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current == quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    edit_distance(3f) - [M_strings:DESCRIBE] returns a naive edit distance using
!!    the Levenshtein distance algorithm
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure elemental function edit_distance(str1,str2) result (distance)
!!
!!     character(len=*),intent(in)   :: str1, str2
!!     integer :: distance
!!
!!##DESCRIPTION
!!
!!   The Levenshtein distance function returns how many edits (deletions,
!!   insertions, transposition) are required to turn one string into another.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_edit_distance
!!    use M_strings, only : edit_distance
!!       write(*,*)edit_distance('kittens','sitting')==3
!!       write(*,*)edit_distance('geek','gesek')==1
!!       write(*,*)edit_distance('Saturday','Sunday')==3
!!    end program demo_edit_distance
!!
!!   Expected output
!!
!!     T
!!     T
!!     T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
! The Levenshtein distance function returns how many edits (deletions,
! insertions, transposition) are required to turn one string into another.

pure elemental integer function edit_distance (a,b)
character(len=*), intent(in) :: a, b
integer                      :: len_a, len_b, i, j, cost
! matrix for calculating Levenshtein distance
!integer                      :: matrix(0:len_trim(a), 0:len_trim(b)) ! not supported by all compilers yet
integer,allocatable          :: matrix(:,:)
   len_a = len_trim(a)
   len_b = len_trim(b)
   !-------------------------------------- ! required by older compilers instead of above declaration
   if(allocated(matrix))deallocate(matrix)
   allocate(matrix(0:len_a,0:len_b))
   !--------------------------------------
   matrix(:,0) = [(i,i=0,len_a)]
   matrix(0,:) = [(j,j=0,len_b)]
   do i = 1, len_a
      do j = 1, len_b
         cost=merge(0,1,a(i:i)==b(j:j))
         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)
      enddo
   enddo
   edit_distance = matrix(len_a,len_b)
end function edit_distance
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    bundle(3f) - [M_strings:ARRAY] return up to twenty strings of arbitrary length
!!                 as an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function bundle(str1,str2,...str20,len) result (vec)
!!
!!     character(len=*),intent(in),optional   :: str1, str2 ... str20
!!     integer,intent(in),optional            :: len
!!
!!##DESCRIPTION
!!    Given a list of up to twenty strings create a string array. The
!!    length of the variables with be the same as the maximum length
!!    of the input strings unless explicitly specified via LEN.
!!
!!    This is an alternative to the syntax
!!
!!      [ CHARACTER(LEN=NN) :: str1, str2, ... ]
!!
!!    that by default additionally calculates the minimum length required
!!    to prevent truncation.
!!
!!##OPTIONS
!!    str1,str2, ... str20  input strings to combine into a vector
!!    len   length of returned array variables
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_bundle
!!    use M_strings, only: bundle
!!    implicit none
!!       print "(*('""',a,'""':,',',1x))", bundle("one")
!!       print "(*('""',a,'""':,',',1x))", bundle("one","two")
!!       print "(*('""',a,'""':,',',1x))", bundle("one","two","three")
!!       print "(*('""',a,'""':,',',1x))", bundle("one","two","three",&
!!               & "four","five","six","seven")
!!    end program demo_bundle
!!
!!   Expected output
!!
!!    "one"
!!    "one", "two"
!!    "one  ", "two  ", "three"
!!    "one  ", "two  ", "three", "four ", "five ", "six  ", "seven"
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function bundle(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,len) result(vec)
! return character array containing present arguments
character(len=*),intent(in),optional  :: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
character(len=*),intent(in),optional  :: x11,x12,x13,x14,x15,x16,x17,x18,x19,x20
integer,intent(in),optional           :: len
character(len=:),allocatable          :: vec(:)
integer                               :: ilen, icount, iset
   ilen=0
   icount=0
   iset=0
   call increment(x1)
   call increment(x2)
   call increment(x3)
   call increment(x4)
   call increment(x5)
   call increment(x6)
   call increment(x7)
   call increment(x8)
   call increment(x9)
   call increment(x10)
   call increment(x11)
   call increment(x12)
   call increment(x13)
   call increment(x14)
   call increment(x15)
   call increment(x16)
   call increment(x17)
   call increment(x18)
   call increment(x19)
   call increment(x20)

   if(present(len)) ilen=len
   allocate (character(len=ilen) ::vec(icount))

   call set(x1)
   call set(x2)
   call set(x3)
   call set(x4)
   call set(x5)
   call set(x6)
   call set(x7)
   call set(x8)
   call set(x9)
   call set(x10)
   call set(x11)
   call set(x12)
   call set(x13)
   call set(x14)
   call set(x15)
   call set(x16)
   call set(x17)
   call set(x18)
   call set(x19)
   call set(x20)

contains

subroutine increment(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      ilen=max(ilen,len_trim(str))
      icount=icount+1
   endif
end subroutine increment

subroutine set(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      iset=iset+1
      vec(iset)=str
   endif
end subroutine set

end function bundle
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    describe(3f) - [M_strings:DESCRIBE] returns a string describing the name of
!!    a single character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function describe(ch) result (string)
!!
!!     character(len=1),intent(in)   :: ch
!!     character(len=:),allocatable  :: string
!!
!!##DESCRIPTION
!!    describe(3f) returns a string describing long name of a single
!!    character
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_describe
!!     use M_strings, only : describe
!!     implicit none
!!     integer :: i
!!        do i=1,128  ! fill variable with base ASCII character set
!!           write(*,*)describe(char(i-1))
!!        enddo
!!    end program demo_describe
!!
!!   Expected output
!!
!!     ctrl-@ or ctrl-? (NUL) null
!!     ctrl-A (SOH) start of heading
!!     ctrl-B (STX) start of text
!!     ctrl-C (ETX) end of text
!!     ctrl-D (EOT) end of transmission
!!     ctrl-E (ENQ) enquiry
!!     ctrl-F (ACK) acknowledge
!!     ctrl-G (BEL) bell
!!     ctrl-H (BS) backspace
!!     ctrl-I (HT) horizontal tabulation
!!     ctrl-J (LF) line feed
!!     ctrl-K (VT) vertical tabulation
!!     ctrl-L (FF) form feed
!!     ctrl-M (CR) carriage return
!!     ctrl-N (SO) shift out
!!     ctrl-O (SI) shift in
!!     ctrl-P (DLE) data link escape
!!     ctrl-Q (DC1) device control 1
!!     ctrl-R (DC2) device control 2
!!     ctrl-S (DC3) device control 3
!!     ctrl-T (DC4) device control 4
!!     ctrl-U (NAK) negative acknowledge
!!     ctrl-V (SYN) synchronous idle
!!     ctrl-W (ETB) end of transmission block
!!     ctrl-X (CAN) cancel
!!     ctrl-Y (EM) end of medium
!!     ctrl-Z (SUB) substitute
!!     ctrl-[ (ESC) escape
!!     ctrl-\ or ctrl-@ (FS) file separator
!!     ctrl-] (GS) group separator
!!     ctrl-^ or ctrl-= (RS) record separator
!!     ctrl-_ (US) unit separator
!!     space
!!     ! exclamation point
!!     " quotation marks
!!     # number sign
!!     $ currency symbol
!!     % percent
!!     & ampersand
!!     ' apostrophe
!!     ( left parenthesis
!!     ) right parenthesis
!!     * asterisk
!!     + plus
!!     , comma
!!     - minus
!!     . period
!!     / slash
!!     0 zero
!!     1 one
!!     2 two
!!     3 three
!!     4 four
!!     5 five
!!     6 six
!!     7 seven
!!     8 eight
!!     9 nine
!!     : colon
!!     ; semicolon
!!     < less than
!!     = equals
!!     > greater than
!!     ? question mark
!!     @ at sign
!!     majuscule A
!!     majuscule B
!!     majuscule C
!!     majuscule D
!!     majuscule E
!!     majuscule F
!!     majuscule G
!!     majuscule H
!!     majuscule I
!!     majuscule J
!!     majuscule K
!!     majuscule L
!!     majuscule M
!!     majuscule N
!!     majuscule O
!!     majuscule P
!!     majuscule Q
!!     majuscule R
!!     majuscule S
!!     majuscule T
!!     majuscule U
!!     majuscule V
!!     majuscule W
!!     majuscule X
!!     majuscule Y
!!     majuscule Z
!!     [ left bracket
!!     \ backslash
!!     ] right bracket
!!     ^ caret
!!     _ underscore
!!     ` grave accent
!!     miniscule a
!!     miniscule b
!!     miniscule c
!!     miniscule d
!!     miniscule e
!!     miniscule f
!!     miniscule g
!!     miniscule h
!!     miniscule i
!!     miniscule j
!!     miniscule k
!!     miniscule l
!!     miniscule m
!!     miniscule n
!!     miniscule o
!!     miniscule p
!!     miniscule q
!!     miniscule r
!!     miniscule s
!!     miniscule t
!!     miniscule u
!!     miniscule v
!!     miniscule w
!!     miniscule x
!!     miniscule y
!!     miniscule z
!!     { left brace
!!     | vertical line
!!     } right brace
!!     ~ tilde
!!     ctrl-? (DEL) delete
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function describe(ch) result (string)

! ident_63="@(#) M_strings describe(3f) return string describing long name of a single character"

character(len=1),intent(in)   :: ch
character(len=:),allocatable  :: string
! LATER: add hex, octal, decimal, key-press description, alternate names
!  ASCII character codes
   select case (iachar(ch))
   case(     0  ); STRING="ctrl-@ or ctrl-? (NUL) null"
   case(     1  ); STRING="ctrl-A (SOH) start of heading"
   case(     2  ); STRING="ctrl-B (STX) start of text"
   case(     3  ); STRING="ctrl-C (ETX) end of text"
   case(     4  ); STRING="ctrl-D (EOT) end of transmission"
   case(     5  ); STRING="ctrl-E (ENQ) enquiry"
   case(     6  ); STRING="ctrl-F (ACK) acknowledge"
   case(     7  ); STRING="ctrl-G (BEL) bell"
   case(     8  ); STRING="ctrl-H (BS) backspace"
   case(     9  ); STRING="ctrl-I (HT) horizontal tabulation"
   case(    10  ); STRING="ctrl-J (LF) line feed"
   case(    11  ); STRING="ctrl-K (VT) vertical tabulation"
   case(    12  ); STRING="ctrl-L (FF) form feed"
   case(    13  ); STRING="ctrl-M (CR) carriage return"
   case(    14  ); STRING="ctrl-N (SO) shift out"
   case(    15  ); STRING="ctrl-O (SI) shift in"
   case(    16  ); STRING="ctrl-P (DLE) data link escape"
   case(    17  ); STRING="ctrl-Q (DC1) device control 1"
   case(    18  ); STRING="ctrl-R (DC2) device control 2"
   case(    19  ); STRING="ctrl-S (DC3) device control 3"
   case(    20  ); STRING="ctrl-T (DC4) device control 4"
   case(    21  ); STRING="ctrl-U (NAK) negative acknowledge"
   case(    22  ); STRING="ctrl-V (SYN) synchronous idle"
   case(    23  ); STRING="ctrl-W (ETB) end of transmission block"
   case(    24  ); STRING="ctrl-X (CAN) cancel"
   case(    25  ); STRING="ctrl-Y (EM) end of medium"
   case(    26  ); STRING="ctrl-Z (SUB) substitute"
   case(    27  ); STRING="ctrl-[ (ESC) escape"
   case(    28  ); STRING="ctrl-\ or ctrl-@ (FS) file separator"
   case(    29  ); STRING="ctrl-] (GS) group separator"
   case(    30  ); STRING="ctrl-^ or ctrl-= (RS) record separator"
   case(    31  ); STRING="ctrl-_ (US) unit separator"
   case(    32  ); STRING="space"
   case(    33  ); STRING="! exclamation point (screamer, gasper, slammer, startler, bang, shriek, pling)"
   case(    34  ); STRING=""" quotation marks"
   case(    35  ); STRING="# number sign (hash, pound sign, hashtag)"
   case(    36  ); STRING="$ currency symbol"
   case(    37  ); STRING="% percent"
   case(    38  ); STRING="& ampersand"
   case(    39  ); STRING="' apostrophe"
   case(    40  ); STRING="( left parenthesis"
   case(    41  ); STRING=") right parenthesis"
   case(    42  ); STRING="* asterisk"
   case(    43  ); STRING="+ plus"
   case(    44  ); STRING=", comma"
   case(    45  ); STRING="- minus"
   case(    46  ); STRING=". period"
   case(    47  ); STRING="/ slash"
   case(    48  ); STRING="0 zero"
   case(    49  ); STRING="1 one"
   case(    50  ); STRING="2 two"
   case(    51  ); STRING="3 three"
   case(    52  ); STRING="4 four"
   case(    53  ); STRING="5 five"
   case(    54  ); STRING="6 six"
   case(    55  ); STRING="7 seven"
   case(    56  ); STRING="8 eight"
   case(    57  ); STRING="9 nine"
   case(    58  ); STRING=": colon"
   case(    59  ); STRING="; semicolon"
   case(    60  ); STRING="< less than"
   case(    61  ); STRING="= equals"
   case(    62  ); STRING="> greater than"
   case(    63  ); STRING="? question mark"
   case(    64  ); STRING="@ at (at cost of, at sign, each at, commercial at, commat, rollmop, monkey|pigs|elephant tail,&
                   & snail, arroba, strudel, asperand, ampersat, rose, cabbage, swirl, whorl)"
   case(    65  ); STRING="A majuscule A"
   case(    66  ); STRING="B majuscule B"
   case(    67  ); STRING="C majuscule C"
   case(    68  ); STRING="D majuscule D"
   case(    69  ); STRING="E majuscule E"
   case(    70  ); STRING="F majuscule F"
   case(    71  ); STRING="G majuscule G"
   case(    72  ); STRING="H majuscule H"
   case(    73  ); STRING="I majuscule I"
   case(    74  ); STRING="J majuscule J"
   case(    75  ); STRING="K majuscule K"
   case(    76  ); STRING="L majuscule L"
   case(    77  ); STRING="M majuscule M"
   case(    78  ); STRING="N majuscule N"
   case(    79  ); STRING="O majuscule O"
   case(    80  ); STRING="P majuscule P"
   case(    81  ); STRING="Q majuscule Q"
   case(    82  ); STRING="R majuscule R"
   case(    83  ); STRING="S majuscule S"
   case(    84  ); STRING="T majuscule T"
   case(    85  ); STRING="U majuscule U"
   case(    86  ); STRING="V majuscule V"
   case(    87  ); STRING="W majuscule W"
   case(    88  ); STRING="X majuscule X"
   case(    89  ); STRING="Y majuscule Y"
   case(    90  ); STRING="Z majuscule Z"
   case(    91  ); STRING="[ left bracket"
   case(    92  ); STRING="\ backslash"
   case(    93  ); STRING="] right bracket"
   case(    94  ); STRING="^ caret"
   case(    95  ); STRING="_ underscore"
   case(    96  ); STRING="` grave accent"
   case(    97  ); STRING="a miniscule a"
   case(    98  ); STRING="b miniscule b"
   case(    99  ); STRING="c miniscule c"
   case(   100  ); STRING="d miniscule d"
   case(   101  ); STRING="e miniscule e"
   case(   102  ); STRING="f miniscule f"
   case(   103  ); STRING="g miniscule g"
   case(   104  ); STRING="h miniscule h"
   case(   105  ); STRING="i miniscule i"
   case(   106  ); STRING="j miniscule j"
   case(   107  ); STRING="k miniscule k"
   case(   108  ); STRING="l miniscule l"
   case(   109  ); STRING="m miniscule m"
   case(   110  ); STRING="n miniscule n"
   case(   111  ); STRING="o miniscule o"
   case(   112  ); STRING="p miniscule p"
   case(   113  ); STRING="q miniscule q"
   case(   114  ); STRING="r miniscule r"
   case(   115  ); STRING="s miniscule s"
   case(   116  ); STRING="t miniscule t"
   case(   117  ); STRING="u miniscule u"
   case(   118  ); STRING="v miniscule v"
   case(   119  ); STRING="w miniscule w"
   case(   120  ); STRING="x miniscule x"
   case(   121  ); STRING="y miniscule y"
   case(   122  ); STRING="z miniscule z"
   case(   123  ); STRING="{ left brace"
   case(   124  ); STRING="| vertical line"
   case(   125  ); STRING="} right brace"
   case(   126  ); STRING="~ tilde"
   case(   127  ); STRING="ctrl-? (DEL) delete"
   case default
         STRING='UNKNOWN'//v2s(IACHAR(ch))
   end select
end function describe
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getvals(3f) - [M_strings:TYPE] read arbitrary number of REAL values
!!    from a character variable up to size of VALUES() array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine getvals(line,values,icount,ierr)
!!
!!     character(len=*),intent(in)  :: line
!!     class(*),intent(out)         :: values(:)
!!     integer,intent(out)          :: icount
!!     integer,intent(out),optional :: ierr
!!
!!##DESCRIPTION
!!   GETVALS(3f) reads a relatively arbitrary number of numeric values from
!!   a character variable into a REAL array using list-directed input.
!!
!!   NOTE: In this version null values are skipped instead of meaning to leave
!!         that value unchanged
!!
!!        1,,,,,,,2 / reads VALUES=[1.0,2.0]
!!
!!   Per list-directed rules when reading values, allowed delimiters are
!!   comma, semi-colon and space.
!!
!!   the slash separator can be used to add inline comments.
!!
!!        10.1, 20.43e-1 ; 11 / THIS IS TREATED AS A COMMENT
!!
!!   Repeat syntax can be used up to the size of the output array. These are
!!   equivalent input lines:
!!
!!        4*10.0
!!        10.0, 10.0, 10.0, 10.0
!!
!!##OPTIONS
!!   LINE      A character variable containing the characters representing
!!             a list of numbers
!!
!!##RETURNS
!!   VALUES()  array holding numbers read from string. May be of type
!!             INTEGER, REAL, DOUBLEPRECISION, or CHARACTER. If CHARACTER the
!!             strings are returned as simple words instead of numeric values.
!!   ICOUNT    number of defined numbers in VALUES(). If ICOUNT reaches
!!             the size of the VALUES() array parsing stops.
!!   IERR      zero if no error occurred in reading numbers. Optional.
!!             If not present and an error occurs the program is terminated.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_getvals
!!       use M_strings, only: getvals
!!       implicit none
!!       integer,parameter  :: longest_line=256
!!       character(len=longest_line) :: line
!!       real               :: values(longest_line/2+1)
!!       integer            :: ios,icount,ierr
!!       INFINITE: do
!!          read(*,'(a)',iostat=ios) line
!!          if(ios /= 0)exit INFINITE
!!          call getvals(line,values,icount,ierr)
!!          write(*,'(4(g0,1x))')'VALUES=',values(:icount)
!!       enddo INFINITE
!!       end program demo_getvals
!!
!!  Sample input lines
!!
!!        10,20 30.4
!!        1 2 3
!!        1
!!
!!        3 4*2.5 8
!!        32.3333 / comment 1
!!        30e3;300,    30.0, 3
!!        even 1 like this! 10
!!        11,,,,22,,,,33
!!
!!  Expected output:
!!
!!     VALUES=   10.0000000       20.0000000       30.3999996
!!     VALUES=   1.00000000       2.00000000       3.00000000
!!     VALUES=   1.00000000
!!     VALUES=
!!     VALUES=   3.00000000       2.50000000       2.50000000
!!     2.50000000       2.50000000       8.00000000
!!     VALUES=   32.3333015
!!     VALUES=   30000.0000       300.000000       30.0000000
!!     3.00000000
!!     *getvals* WARNING:[even] is not a number
!!     *getvals* WARNING:[like] is not a number
!!     *getvals* WARNING:[this!] is not a number
!!     VALUES=   1.00000000       10.0000000
!!     VALUES=   11.0000000       22.0000000       33.0000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine getvals(line,values,icount,ierr)

! ident_64="@(#) M_strings getvals(3f) read arbitrary number of values from a character variable"

! JSU 20170831

character(len=*),intent(in)  :: line
class(*),intent(out)         :: values(:)
integer,intent(out)          :: icount
integer,intent(out),optional :: ierr

character(len=:),allocatable :: buffer
character(len=len(line))     :: words(size(values))
integer                      :: ios, i, ierr_local,isize

   isize=0
   select type(values)
   type is (integer);          isize=size(values)
   type is (real);             isize=size(values)
   type is (doubleprecision);  isize=size(values)
   type is (character(len=*)); isize=size(values)
   end select

   ierr_local=0

   words=' '                            ! make sure words() is initialized to null+blanks
   buffer=trim(unquote(line))//"/"      ! add a slash to the end so how the read behaves with missing values is clearly defined
   read(buffer,*,iostat=ios) words      ! undelimited strings are read into an array
   icount=0
   do i=1,isize                         ! loop thru array and convert non-blank words to numbers
      if(words(i) == ' ')cycle

      select type(values)
      type is (integer);          read(words(i),*,iostat=ios)values(icount+1)
      type is (real);             read(words(i),*,iostat=ios)values(icount+1)
      type is (doubleprecision);  read(words(i),*,iostat=ios)values(icount+1)
      type is (character(len=*)); values(icount+1)=words(i)
      end select

      if(ios == 0)then
         icount=icount+1
      else
         ierr_local=ios
         write(stderr,*)'*getvals* WARNING:['//trim(words(i))//'] is not a number of specified type'
      endif
   enddo

   if(present(ierr))then
      ierr=ierr_local
   elseif(ierr_local /= 0)then        ! error occurred and not returning error to main program to print message and stop program
      write(stderr,*)'*getval* error reading line ['//trim(line)//']'
      stop 2
   endif

end subroutine getvals
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_values(3f) - [M_strings:TYPE] read a string representing
!!      numbers into a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine string_to_values(line,iread,values,inums,delims,ierr)
!!
!!        character(len=*) :: line
!!        integer          :: iread
!!        real             :: values(*)
!!        integer          :: inums
!!        character(len=*) :: delims
!!        integer          :: ierr
!!
!!##DESCRIPTION
!!    This routine can take a string representing a series of numbers and
!!    convert it to a numeric array and return how many numbers were found.
!!
!!##OPTIONS
!!       LINE     Input string containing numbers
!!       IREAD    maximum number of values to try to read from input string
!!
!!##RESULTS
!!       VALUES   real array to be filled with numbers
!!       INUMS    number of values successfully read (before error occurs
!!                if one does)
!!       DELIMS   delimiter character(s), usually a space. must not be a
!!                null string. If more than one character, a space must
!!                not be the last character or it will be ignored.
!!       IERR     error flag (0=no error, else column number string starts
!!                at that error occurred on).
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!      program demo_string_to_values
!!       use M_strings, only : string_to_values
!!       implicit none
!!       character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!       integer,parameter  :: isz=10
!!       real               :: array(isz)
!!       integer            :: inums, ierr, ii
!!
!!       call string_to_values(s,10,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       contains
!!          subroutine reportit()
!!             write(*,*)'string_to_values:'
!!             write(*,*)'input string.............',trim(s)
!!             write(*,*)'number of values found...',inums
!!             write(*,*)'values...................',(array(ii),ii=1,inums)
!!          end subroutine reportit
!!      end program demo_string_to_values
!!
!!    Expected output
!!
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000  20000.0000  3.45000005
!!     -4.00299978  1234.00000  5678.00000
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           3
!!     values...................   10.0000000  2.29999995  3.14159989
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine string_to_values(line,iread,values,inums,delims,ierr)
!----------------------------------------------------------------------------------------------------------------------------------
!   1989,1997-12-31,2014 John S. Urban

!   given a line of structure , string , string , string process each
!   string as a numeric value and store into an array.
!   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS.
!   There is no direct checking for more values than can fit in VALUES.
!   Quits if encounters any errors in read.
!----------------------------------------------------------------------------------------------------------------------------------

! ident_65="@(#) M_strings string_to_values(3f) reads an array of numbers from a numeric string"

character(len=*),intent(in)  :: line          ! input string
integer,intent(in)           :: iread         ! maximum number of values to try to read into values
real,intent(inout)           :: values(iread) ! real array to be filled with values
integer,intent(out)          :: inums         ! number of values successfully read from string
character(len=*),intent(in)  :: delims        ! allowed delimiters
integer,intent(out)          :: ierr          ! 0 if no error, else column number undecipherable string starts at
!----------------------------------------------------------------------------------------------------------------------------------
character(len=256)           :: delims_local        ! mutable copy of allowed delimiters
integer                      :: ibegin,iend,lgth,icol
integer                      :: i10,i20,i40
real                         :: rval
integer                      :: ier
integer                      :: delimiters_length
!----------------------------------------------------------------------------------------------------------------------------------
      delims_local=delims                                 ! need a mutable copy of the delimiter list
      if(delims_local == '')then                          ! if delimiter list is null or all spaces make it a space
         delims_local=' '                                 ! delimiter is a single space
         delimiters_length=1                        ! length of delimiter list
      else
         delimiters_length=len_trim(delims)         ! length of variable WITH TRAILING WHITESPACE TRIMMED
      endif
!----------------------------------------------------------------------------------------------------------------------------------
      ierr=0                                        ! initialize error code returned
      inums=0                                       ! initialize count of values successfully returned
      ibegin=0
!----------------------------------------------------------------------------------------------------------------------------------
      lgth=0                                        ! lgth will be the position of the right-most non-delimiter in the input line
      do i20=len(line),1,-1                         ! loop from end of string to beginning to find right-most non-delimiter
         if(index(delims_local(:delimiters_length),line(i20:i20)) == 0)then   ! found a non-delimiter
            lgth=i20
            exit
         endif
      enddo
      if(lgth == 0)then                             ! command was totally composed of delimiters
         call journal('*string_to_values* blank line passed as a list of numbers')
         return
      endif
!----------------------------------------------------------------------------------------------------------------------------------
!     there is at least one non-delimiter sub-string
!     lgth is the column position of the last non-delimiter character
!     now, starting at beginning of string find next non-delimiter
      icol=1                                                     ! pointer to beginning of unprocessed part of LINE
      LOOP: dO i10=1,iread,1                                     ! each pass should find a value
         if(icol > lgth) EXIT LOOP                              ! everything is done
         INFINITE: do
            if(index(delims_local(:delimiters_length),line(icol:icol)) == 0)then           ! found non-delimiter
               ibegin=icol
               iend=0                                            ! FIND END OF SUBSTRING
               do i40=ibegin,lgth                                ! look at each character starting at left
                  if(index(delims_local(:delimiters_length),line(i40:i40)) /= 0)then       ! determine if character is a delimiter
                     iend=i40                                    ! found a delimiter. record where it was found
                     EXIT                                        ! found end of substring so leave loop
                  endif
               enddo
              if(iend == 0)iend=lgth+1                           ! no delimiters found, so this substring goes to end of line
               iend=iend-1                                       ! do not want to pass delimiter to be converted
               rval=0.0
               call string_to_value(line(ibegin:iend),rval,ier)  ! call procedure to convert string to a numeric value
               if(ier == 0)then                                  ! a substring was successfully converted to a numeric value
                  values(i10)=rval                               ! store numeric value in return array
                  inums=inums+1                                  ! increment number of values converted to a numeric value
               else                                              ! an error occurred converting string to value
                  ierr=ibegin                                    ! return starting position of substring that could not be converted
                  return
               endif
               icol=iend+2                                       ! set to next character to look at
               CYCLE LOOP                                        ! start looking for next value
            else                                                 ! this is a delimiter so keep looking for start of next string
               icol=icol+1                                       ! increment pointer into LINE
               CYCLE INFINITE
            endif
         enddo INFINITE
      enddo LOOP
!     error >>>>> more than iread numbers were in the line.
end subroutine string_to_values
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2vs(3f) - [M_strings:TYPE] given a string representing numbers
!!      return a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function s2vs(line[,delim])
!!
!!        character(len=*) :: line
!!        doubleprecision,allocatable :: s2vs(:)
!!
!!##DESCRIPTION
!!    The function S2VS(3f) takes a string representing a series of numbers
!!    and converts it to a numeric doubleprecision array. The string values
!!    may be delimited by spaces, semi-colons, and commas by default.
!!
!!##OPTIONS
!!       LINE   Input string containing numbers
!!       DELIM  optional list of delimiter characters. If a space is
!!              included, it should appear as the left-most character
!!              in the list. The default is " ;," (spaces, semi-colons,
!!              and commas).
!!
!!##RESULTS
!!       S2VS   doubleprecision array
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!      program demo_s2vs
!!      use M_strings, only : s2vs
!!      implicit none
!!      character(len=80) :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!      real,allocatable :: values(:)
!!      integer,allocatable :: ivalues(:)
!!      integer :: ii
!!
!!      values=s2vs(s)
!!      ivalues=int(s2vs(s))
!!      call reportit()
!!
!!      contains
!!        subroutine reportit()
!!          write(*,*)'S2VS:'
!!          write(*,*)'input string.............',&
!!           & trim(s)
!!          write(*,*)'number of values found...',&
!!           & size(values)
!!          write(*,*)'values...................',&
!!           & (values(ii),ii=1,size(values))
!!          write(*,'(*(g0,1x))')'ivalues..................',&
!!           & (ivalues(ii),ii=1,size(values))
!!        end subroutine reportit
!!      end program demo_s2vs
!!
!!   Expected output
!!
!!     S2VS:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000 20000.0000 3.45000005
!!     -4.00299978 1234.00000 5678.00000
!!    ivalues.................. 10 20000 3 -4 1234 5678
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function s2vs(string,delim) result(darray)

! ident_66="@(#) M_strings s2vs(3f) function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isprint(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     ASCII printable character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isprint(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isprint
!!
!!##DESCRIPTION
!!     isprint(3f) returns .true. if character is an ASCII printable character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isprint  logical value returns true if character is a
!!             printable ASCII character else false.
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_isprint
!!    use M_strings, only : isprint
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISPRINT: ',pack( string, isprint(string) )
!!    end program demo_isprint
!!
!!   Results:
!!
!!    ISPRINT:  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEF
!!    GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn
!!    opqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isprint(onechar)

! ident_67="@(#) M_strings isprint(3f) indicates if input character is a printable ASCII character"

character,intent(in) :: onechar
logical              :: isprint
   select case (onechar)
      case (' ':'~')   ; isprint=.TRUE.
      case default     ; isprint=.FALSE.
   end select
end function isprint
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isgraph(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable character except a space is considered non-printable
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isgraph(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isgraph
!!
!!##DESCRIPTION
!!    isgraph(3f) returns .true. if character is a printable character
!!    except a space is considered non-printable
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isgraph   logical value returns true if character is a printable
!!              non-space character
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_isgraph
!!    use M_strings, only : isgraph
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISGRAPH: ',pack( string, isgraph(string) )
!!    end program demo_isgraph
!!
!!   Results:
!!
!!    ISGRAPH: !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG
!!    HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno
!!    pqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isgraph(onechar)

! ident_68="@(#) M_strings isgraph(3f) indicates if character is printable ASCII character excluding space"

character,intent(in) :: onechar
logical              :: isgraph
   select case (iachar(onechar))
   case (33:126)
     isgraph=.TRUE.
   case default
     isgraph=.FALSE.
   end select
end function isgraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalpha(3f) - [M_strings:COMPARE] returns .true. if character is a
!!    letter and .false. otherwise
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   elemental function isalpha(onechar)
!!
!!    character,intent(in) :: onechar
!!    logical              :: isalpha
!!
!!##DESCRIPTION
!!    isalpha(3f) returns .true. if character is a letter and
!!    .false. otherwise
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isalpha  logical value returns .true. if character is a ASCII letter
!!             or false otherwise.
!!##EXAMPLE
!!
!!
!!   Sample program
!!
!!     program demo_isalpha
!!     use M_strings, only : isalpha
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISGRAPH: ',pack( string, isalpha(string) )
!!     end program demo_isalpha
!!
!!   Results:
!!
!!    ISGRAPH: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm
!!    nopqrstuvwxyz
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function isalpha(ch) result(res)

! ident_69="@(#) M_strings isalpha(3f) Return .true. if character is a letter and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z','a':'z')
     res=.true.
   case default
     res=.false.
   end select
end function isalpha
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isxdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     hexadecimal digit (0-9, a-f, or A-F).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isxdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isxdigit
!!
!!##DESCRIPTION
!!     isxdigit(3f) returns .true. if character is a hexadecimal digit (0-9,
!!     a-f, or A-F).
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isxdigit  logical value returns true if character is a hexadecimal digit
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!     program demo_isxdigit
!!     use M_strings, only : isxdigit
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISXDIGIT: ',pack( string, isxdigit(string) )
!!     end program demo_isxdigit
!!
!!   Results:
!!
!!    ISXDIGIT: 0123456789ABCDEFabcdef
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isxdigit(ch) result(res)

! ident_70="@(#) M_strings isxdigit(3f) returns .true. if c is a hexadecimal digit (0-9 a-f or A-F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'F','a':'f','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isxdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     digit (0,1,...,9) and .false. otherwise
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isdigit
!!
!!##DESCRIPTION
!!     isdigit(3f) returns .true. if character is a digit (0,1,...,9)
!!     and .false. otherwise
!!
!!##EXAMPLES
!!
!!
!!  Sample Program:
!!
!!     program demo_isdigit
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!            & all(isdigit(switch(string(i))).or.&
!!            & isspace(switch(string(i))))
!!        enddo
!!     end program demo_isdigit
!!
!!  Expected output:
!!
!!        For string[1 2 3 4 5 ] T
!!        For string[letters   ] F
!!        For string[1234567890] T
!!        For string[both 8787 ] F
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isdigit(ch) result(res)

! ident_71="@(#) M_strings isdigit(3f) Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isblank(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     blank character (space or horizontal tab).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isblank(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isblank
!!
!!##DESCRIPTION
!!     isblank(3f) returns .true. if character is a blank character (space
!!     or horizontal tab).
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isblank  logical value returns true if character is a "blank"
!!             ( an ASCII  space or horizontal tab character).
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_isblank
!!     use M_strings, only : isblank
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(*(g0,1x))')'ISXBLANK: ',&
!!        & iachar(pack( string, isblank(string) ))
!!     end program demo_isblank
!!
!!   Results:
!!
!!    ISXBLANK:  9 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isblank(ch) result(res)

! ident_72="@(#) M_strings isblank(3f) returns .true. if character is a blank (space or horizontal tab)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ',char(9))
     res=.true.
   case default
     res=.false.
   end select
end function isblank
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isascii(3f) - [M_strings:COMPARE] returns .true. if the character is
!!     in the range char(0) to char(256)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isascii(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isascii
!!
!!##DESCRIPTION
!!     isascii(3f) returns .true. if the character is in the range char(0)
!!     to char(127)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isupper  logical value returns true if character is an ASCII
!!             character.
!!##EXAMPLE
!!
!!  Sample program
!!
!!     program demo_isascii
!!     use M_strings, only : isascii
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,255)]
!!        write(*,'(10(g0,1x))')'ISASCII: ', &
!!        & iachar(pack( string, isascii(string) ))
!!     end program demo_isascii
!!
!!  Results:
!!
!!    ISASCII:  0 1 2 3 4 5 6 7 8
!!    9 10 11 12 13 14 15 16 17 18
!!    19 20 21 22 23 24 25 26 27 28
!!    29 30 31 32 33 34 35 36 37 38
!!    39 40 41 42 43 44 45 46 47 48
!!    49 50 51 52 53 54 55 56 57 58
!!    59 60 61 62 63 64 65 66 67 68
!!    69 70 71 72 73 74 75 76 77 78
!!    79 80 81 82 83 84 85 86 87 88
!!    89 90 91 92 93 94 95 96 97 98
!!    99 100 101 102 103 104 105 106 107 108
!!    109 110 111 112 113 114 115 116 117 118
!!    119 120 121 122 123 124 125 126 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isascii(ch) result(res)

! ident_73="@(#) M_strings isascii(3f) returns .true. if character is in the range char(0) to char(127)"

character,intent(in) :: ch
logical              :: res
   select case(iachar(ch))
   case(0:127)
     res=.true.
   case default
     res=.false.
   end select
end function isascii
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & iachar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_74="@(#) M_strings isspace(3f) true if null space tab return new line vertical tab or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     iscntrl(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     delete character or ordinary control character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function iscntrl(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: iscntrl
!!
!!##DESCRIPTION
!!     iscntrl(3f) returns .true. if character is a delete character or
!!     ordinary control character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    iscntrl  logical value returns true if character is a control character
!!
!!##EXAMPLE
!!
!!  Sample program
!!
!!     program demo_iscntrl
!!     use M_strings, only : iscntrl
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISCNTRL: ', &
!!        & iachar(pack( string, iscntrl(string) ))
!!     end program demo_iscntrl
!!
!!   Results:
!!
!!    ISCNTRL:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
!!    20 21 22 23 24 25 26 27 28 29 30 31 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function iscntrl(ch) result(res)

! ident_75="@(#) M_strings iscntrl(3f) true if a delete or ordinary control character(0x7F or 0x00-0x1F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(char(127),char(0):char(31))
     res=.true.
   case default
     res=.false.
   end select
end function iscntrl
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     ispunct(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable punctuation character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function ispunct(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: ispunct
!!
!!##DESCRIPTION
!!     ispunct(3f) returns .true. if character is a printable punctuation
!!     character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    ispunct  logical value returns true if character is a printable
!!             punctuation character.
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_ispunct
!!     use M_strings, only : ispunct
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & iachar(pack( string, ispunct(string) ))
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & pack( string, ispunct(string) )
!!     end program demo_ispunct
!!   Results:
!!
!!    ISPUNCT:  33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61
!!    62 63 64 91 92 93 94 95 96 123 124 125 126
!!    ISPUNCT:  ! " # $ % & ' ( ) * + , - . / : ; < =
!!    > ? @ [ \ ] ^ _ ` { | } ~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function ispunct(ch) result(res)

! ident_76="@(#) M_strings ispunct(3f) true if a printable punctuation character (isgraph(c)&&!isalnum(c))"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case (char(33):char(47), char(58):char(64), char(91):char(96), char(123):char(126))
     res=.true.
!  case(' ','0':'9','A':'Z','a':'z',char(128):)
!    res=.true.
!  case(char(0):char(31),char(127))
!    res=.true.
   case default
     res=.false.
   end select
end function ispunct
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     fortran_name(3f) - [M_strings:COMPARE] test if string meets criteria
!!     for being a fortran name
!!
!!##SYNOPSIS
!!
!!
!!     elemental function fortran_name(line) result (lout)
!!
!!      character(len=*),intent(in)  :: line
!!      logical                      :: lout
!!
!!##DESCRIPTION
!!     Determines if a string is an allowed Fortran name. To pass the input
!!     string must be composed of 1 to 63 ASCII characters and start with a
!!     letter and be composed entirely of alphanumeric characters [a-zA-Z0-9]
!!     and underscores.
!!
!!##OPTIONS
!!     LINE   input string to test. Leading spaces are significant but
!!            trailing spaces are ignored.
!!
!!##RETURNS
!!     LOUT   a logical value indicating if the input string passed or failed
!!            the test to see if it is a valid Fortran name or not.
!!
!!##EXAMPLE
!!
!!    Sample program
!!
!!      program demo_fortran_name
!!      use M_strings, only : fortran_name
!!      implicit none
!!      character(len=20),parameter :: names(*)=[character(len=20) ::  &
!!       & '_name',         'long_variable_name', 'name_',         &
!!       & '12L',           'a__b__c  ',          'PropertyOfGas', &
!!       & '3%3',           '$NAME',              ' ',             &
!!       & 'Variable-name', 'A',                  'x@x' ]
!!      integer :: i
!!         write(*,'(i3,1x,a20,1x,l1)')&
!!         & (i,names(i),fortran_name(names(i)),i=1,size(names))
!!      end program demo_fortran_name
!!
!!    Results:
!!
!!      >  1 _name                F
!!      >  2 long_variable_name   T
!!      >  3 name_                T
!!      >  4 12L                  F
!!      >  5 a__b__c              T
!!      >  6 PropertyOfGas        T
!!      >  7 3%3                  F
!!      >  8 $NAME                F
!!      >  9                      F
!!      > 10 Variable-name        F
!!      > 11 A                    T
!!      > 12 x@x                  F
elemental function fortran_name(line) result (lout)

! ident_77="@(#) M_strings fortran_name(3f) Return .true. if name is a valid Fortran name"

! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)
character(len=*),parameter   :: int='0123456789'
character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
character(len=*),parameter   :: allowed=upper//lower//int//'_'

character(len=*),intent(in)  :: line
character(len=:),allocatable :: name
logical                      :: lout
   name=trim(line)
   if(len(name) /= 0)then
      lout = verify(name(1:1), lower//upper) == 0  &
       & .and. verify(name,allowed) == 0           &
       & .and. len(name) <= 63
   else
      lout = .false.
   endif
end function fortran_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isupper(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     uppercase letter (A-Z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isupper(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isupper
!!
!!##DESCRIPTION
!!     isupper(3f) returns .true. if character is an uppercase letter (A-Z)
!!
!!##OPTIONS
!!    onechar  character to test
!!##RETURNS
!!    isupper  logical value returns true if character is an uppercase
!!             ASCII character else false.
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isupper
!!     use M_strings, only : isupper
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & iachar(pack( string, isupper(string) ))
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & pack( string, isupper(string) )
!!     end program demo_isupper
!!
!!  Results:
!!
!!    ISUPPER:  65 66 67 68 69 70 71 72 73
!!    74 75 76 77 78 79 80 81 82 83
!!    84 85 86 87 88 89 90
!!    ISUPPER:  A B C D E F G H I
!!    J K L M N O P Q R S
!!    T U V W X Y Z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
pure elemental function isupper(ch) result(res)

! ident_78="@(#) M_strings isupper(3f) returns true if character is an uppercase letter (A-Z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z'); res=.true.
   case default;  res=.false.
   end select
end function isupper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     islower(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     miniscule letter (a-z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function islower(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: islower
!!
!!##DESCRIPTION
!!     islower(3f) returns .true. if character is a miniscule letter (a-z)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    islower  logical value returns true if character is a lowercase
!!             ASCII character else false.
!!##EXAMPLE
!!
!!  Sample program
!!
!!     program demo_islower
!!     use M_strings, only : islower
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & iachar(pack( string, islower(string) ))
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & pack( string, islower(string) )
!!     end program demo_islower
!!   Results:
!!
!!    ISLOWER:  97 98 99 100 101 102 103 104 105 106 107 108 109 110
!!    111 112 113 114 115 116 117 118 119 120 121 122
!!    ISLOWER:  a b c d e f g h i j k l m n
!!    o p q r s t u v w x y z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function islower(ch) result(res)

! ident_79="@(#) M_strings islower(3f) returns true if character is a miniscule letter (a-z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('a':'z'); res=.true.
   case default;  res=.false.
   end select
end function islower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalnum,isalpha,iscntrl,isdigit,isgraph,islower,
!!    isprint,ispunct,isspace,isupper,
!!    isascii,isblank,isxdigit(3f) - [M_strings:COMPARE] test membership in
!!    subsets of ASCII set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Where "FUNCNAME" is one of the function names in the group, the
!!    functions are defined by
!!
!!     elemental function FUNCNAME(onechar)
!!     character,intent(in) :: onechar
!!     logical              :: FUNC_NAME
!!##DESCRIPTION
!!
!!       These elemental functions test if a character belongs to various
!!       subsets of the ASCII character set.
!!
!!       isalnum    returns .true. if character is a letter (a-z,A-Z)
!!                  or digit (0-9)
!!       isalpha    returns .true. if character is a letter and
!!                  .false. otherwise
!!       isascii    returns .true. if character is in the range char(0)
!!                  to char(127)
!!       isblank    returns .true. if character is a blank (space or
!!                  horizontal tab).
!!       iscntrl    returns .true. if character is a delete character or
!!                  ordinary control character (0x7F or 0x00-0x1F).
!!       isdigit    returns .true. if character is a digit (0,1,...,9)
!!                  and .false. otherwise
!!       isgraph    returns .true. if character is a printable ASCII
!!                  character excluding space
!!       islower    returns .true. if character is a miniscule letter (a-z)
!!       isprint    returns .true. if character is a printable ASCII character
!!       ispunct    returns .true. if character is a printable punctuation
!!                  character (isgraph(c) && !isalnum(c)).
!!       isspace    returns .true. if character is a null, space, tab,
!!                  carriage return, new line, vertical tab, or formfeed
!!       isupper    returns .true. if character is an uppercase letter (A-Z)
!!       isxdigit   returns .true. if character is a hexadecimal digit
!!                  (0-9, a-f, or A-F).
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isdigit
!!
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!           all(isdigit(switch(string(i))) .or. &
!!           & isspace(switch(string(i))))
!!        enddo
!!
!!     end program demo_isdigit
!!
!!   Expected output:
!!
!!    For string[1 2 3 4 5 ] T
!!    For string[letters   ] F
!!    For string[1234567890] T
!!    For string[both 8787 ] F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental function isalnum(ch) result(res)

! ident_80="@(#) M_strings isalnum(3f) returns true if character is a letter (a-z A-Z) or digit(0-9)"

character,intent(in)       :: ch
logical                    :: res
   select case(ch)
   case('a':'z','A':'Z','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isalnum
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base(3f) - [M_strings:BASE] convert whole number string in base [2-36]
!!    to string in alternate base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   elemental impure logical function base(x,b,y,a)
!!
!!    character(len=*),intent(in)  :: x
!!    character(len=*),intent(out) :: y
!!    integer,intent(in)           :: b,a
!!##DESCRIPTION
!!
!!    Convert a numeric string from base B to base A. The function returns
!!    FALSE if B is not in the range [2..36] or if string X contains invalid
!!    characters in base B or if result Y is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in a base > 10.
!!
!!##OPTIONS
!!    x   input string representing numeric whole value
!!    b   assumed base of input string
!!    y   output string
!!    a   base specified for output string
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_base
!!    use M_strings, only : base
!!    implicit none
!!    integer           :: ba,bd
!!    character(len=40) :: x,y
!!
!!    print *,' BASE CONVERSION'
!!    write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!    write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!    INFINITE: do
!!       write(*,'("Enter number in start base (0 to quit): ")',advance='no')
!!       read *, x
!!       if(x == '0') exit INFINITE
!!       if(base(x,bd,y,ba))then
!!            write(*,'("In base ",I2,": ",A20)')  ba, y
!!        else
!!          print *,'Error in decoding/encoding number.'
!!        endif
!!     enddo INFINITE
!!
!!     end program demo_base
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental impure logical function base(x, b, y, a)
character(len=*), intent(in)  :: x
character(len=*), intent(out) :: y
integer, intent(in)           :: b, a
integer                       :: temp

! ident_81="@(#) M_strings base(3f) convert whole number string in base [2-36] to string in alternate base [2-36]"

   base = .true.
   if (decodebase(x, b, temp)) then
      if (codebase(temp, a, y)) then
      else
         write(stderr,*) 'Error in coding number.'
         base = .false.
      endif
   else
      write(stderr,*) 'Error in decoding number.'
      base = .false.
   endif

end function base
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base2(3f) - [M_strings:BASE] convert whole number to string in base 2
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function base2(int)
!!
!!     integer,intent(in)           :: int
!!     character(len=:),allocatable :: base2
!!
!!##DESCRIPTION
!!
!!    Convert a whole number to a string in base 2.
!!
!!    This is often done with the B edit descriptor and
!!    an internal WRITE() statement, but is done without
!!    calling the I/O routines, and as a function.
!!
!!##OPTIONS
!!    int   input string representing numeric whole value
!!##RETURNS
!!    base2   string representing input value in base 2
!!##EXAMPLE
!!
!!   Sample program:
!!
!!      program demo_base2
!!      use M_strings, only : base2
!!      implicit none
!!         write(*,'(a)') base2(huge(0))
!!         write(*,'(a)') base2(0)
!!         write(*,'(a)') base2(64)
!!         write(*,'(a)') base2(-64)
!!         write(*,'(a)') base2(-huge(0)-1)
!!      end program demo_base2
!! Results:
!!
!!     > 1111111111111111111111111111111
!!     > 0
!!     > 1000000
!!     > 11111111111111111111111111000000
!!     > 10000000000000000000000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2(x) result(str)
!  return string representing number as a binary number.  Fixed-length string:
integer, intent(in)                        :: x
integer                                    :: i
character(len=max(1,bit_size(x)-leadz(x))) :: str
    associate(n => len(str))
      str = repeat('0',n)
      do i = 0,n-1
        if (btest(x,i)) str(n-i:n-i) = '1'
      end do
    end associate
end function base2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_strings:BASE] convert whole number string in base
!!    [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_decodebase
!!    use M_strings, only : codebase, decodebase
!!    implicit none
!!    integer           :: ba,bd
!!    character(len=40) :: x,y
!!    integer           :: r
!!
!!    print *,' BASE CONVERSION'
!!    write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!    write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!    INFINITE: do
!!       print *,''
!!       write(*,'("Enter number in start base: ")',advance='no'); read *, x
!!       if(x == '0') exit INFINITE
!!       if(decodebase(x,bd,r)) then
!!          if(codebase(r,ba,y)) then
!!            write(*,'("In base ",I2,": ",A20)')  ba, y
!!          else
!!            print *,'Error in coding number.'
!!          endif
!!       else
!!          print *,'Error in decoding number.'
!!       endif
!!    enddo INFINITE
!!
!!    end program demo_decodebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function decodebase(string,basein,out_baseten)

! ident_82="@(#) M_strings decodebase(3f) convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                  ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    write(stderr,*) '(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(stderr,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    codebase(3f) - [M_strings:BASE] convert whole number in base 10 to
!!    string in base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function codebase(in_base10,out_base,answer)
!!
!!    integer,intent(in)           :: in_base10
!!    integer,intent(in)           :: out_base
!!    character(len=*),intent(out) :: answer
!!
!!##DESCRIPTION
!!    Convert a number from base 10 to base OUT_BASE. The function returns
!!    .FALSE. if OUT_BASE is not in [2..36] or if number IN_BASE10 is
!!    too big.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_codebase
!!    use M_strings, only : codebase
!!    implicit none
!!    character(len=20) :: answer
!!    integer           :: i, j
!!    logical           :: ierr
!!    do j=1,100
!!       do i=2,36
!!          ierr=codebase(j,i,answer)
!!          write(*,*)'VALUE=',j,' BASE=',i,' ANSWER=',answer
!!       enddo
!!    enddo
!!    end program demo_codebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!     Ref.: "Math matiques en Turbo-Pascal by
!!            M. Ducamp and A. Reverchon (2),
!!            Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function codebase(inval10,outbase,answer)

! ident_83="@(#) M_strings codebase(3f) convert whole number in base 10 to string in base [2-36]"

integer,intent(in)           :: inval10
integer,intent(in)           :: outbase
character(len=*),intent(out) :: answer
integer                      :: n
real                         :: inval10_local
integer                      :: outbase_local
integer                      :: in_sign
  answer=''
  in_sign=sign(1,inval10)*sign(1,outbase)
  inval10_local=abs(inval10)
  outbase_local=abs(outbase)
  if(outbase_local<2.or.outbase_local>36) then
    write(stderr,*) '*codebase* ERROR: base must be between 2 and 36. base was',outbase_local
    codebase=.false.
  else
     do while(inval10_local>0.0 )
        n=INT(inval10_local-outbase_local*INT(inval10_local/outbase_local))
        if(n<10) then
           answer=ACHAR(IACHAR('0')+n)//answer
        else
           answer=ACHAR(IACHAR('A')+n-10)//answer
        endif
        inval10_local=INT(inval10_local/outbase_local)
     enddo
     codebase=.true.
  endif
  if(in_sign == -1)then
     answer='-'//trim(answer)
  endif
  if(answer == '')then
     answer='0'
  endif
end function codebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function todecimal(base, instr)

! ident_84="@(#) M_strings todecimal(3f) given string and base return decimal integer"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
character(*),intent(in)      :: instr
character(len=:),allocatable :: instr_local
integer                      :: todecimal
integer                      :: length, i, n

   instr_local=trim(lower(instr))
   todecimal = 0
   length = len(instr_local)
   do i = 1, length
      n = index(alphanum, instr_local(i:i)) - 1
      n = n * base**(length-i)
      todecimal = todecimal + n
   enddo
end function todecimal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function tobase(base, number)

! ident_85="@(#) M_strings tobase(3f) given integer and base return string"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
integer,intent(in)           :: number
character(len=:),allocatable :: tobase
character(len=31)            :: holdit
integer                      :: number_local, i, rem
   number_local=number

   holdit = "                               "
   do i = 31, 1, -1
      if(number_local < base) then
         holdit(i:i) = alphanum(number_local+1:number_local+1)
         exit
      endif
      rem = mod(number_local, base)
      holdit(i:i) = alphanum(rem+1:rem+1)
      number_local = number_local / base
   enddo
   tobase = adjustl(holdit)
end function tobase

!SUBROUTINE DectoBase(decimal, string, base)
! CHARACTER string
!    string = '0'
!    temp = decimal
!    length = CEILING( LOG(decimal+1, base) )   !<<<<<<<< INTERESTING
!    DO i = length, 1, -1
!      n = MOD( temp, base )
!      string(i) = "0123456789abcdefghijklmnopqrstuvwxyz"(n+1)
!      temp = INT(temp / base)
!    ENDDO
! END
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    paragraph(3f) - [M_strings:TOKENS] break a long line into a paragraph
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function paragraph(source_string,length)
!!
!!    character(len=*),intent(in)       :: source_string
!!    integer,intent(in)                :: length
!!    character(allocatable(len=length)    :: paragraph(:)
!!
!!##DESCRIPTION
!!    paragraph(3f) breaks a long line into a simple paragraph of specified
!!    line length.
!!
!!    Given a long string break it on spaces into an array such that no
!!    variable is longer than the specified length. Individual words longer
!!    than LENGTH will be placed in variables by themselves.
!!
!!##OPTIONS
!!     SOURCE_STRING  input string to break into an array of shorter strings
!!                    on blank delimiters
!!     LENGTH         length of lines to break the string into.
!!
!!##RETURNS
!!     PARAGRAPH  character array filled with data from source_string
!!                broken at spaces into variables of length LENGTH.
!!
!!##EXAMPLE
!!
!!  sample program
!!
!!    program demo_paragraph
!!    use M_strings, only : paragraph
!!    implicit none
!!    character(len=:),allocatable :: paragrph(:)
!!    character(len=*),parameter    :: string= '&
!!     &one two three four five &
!!     &six seven eight &
!!     &nine ten eleven twelve &
!!     &thirteen fourteen fifteen sixteen &
!!     &seventeen'
!!
!!    write(*,*)'LEN=',len(string)
!!    write(*,*)'INPUT:'
!!    write(*,*)string
!!
!!    paragrph=paragraph(string,40)
!!    write(*,*)'LEN=',len(paragrph),' SIZE=',size(paragrph)
!!    write(*,*)'OUTPUT:'
!!    write(*,'(a)')paragrph
!!
!!    write(*,'(a)')paragraph(string,0)
!!    write(*,'(3x,a)')paragraph(string,47)
!!
!!    end program demo_paragraph
!!
!!   Results:
!!
!!     LEN=         106
!!     INPUT:
!!     one two three four five six seven eight nine ten eleven twelve
!!     thirteen fourteen fifteen sixteen seventeen
!!     LEN=          40  SIZE=           3
!!     OUTPUT:
!!    one two three four five six seven eight
!!    nine ten eleven twelve thirteen fourteen
!!    fifteen sixteen seventeen
!!    one
!!    two
!!    three
!!    four
!!    five
!!    six
!!    seven
!!    eight
!!    nine
!!    ten
!!    eleven
!!    twelve
!!    thirteen
!!    fourteen
!!    fifteen
!!    sixteen
!!    seventeen
!!       one two three four five six seven eight nine
!!       ten eleven twelve thirteen fourteen fifteen
!!       sixteen seventeen
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function paragraph(source_string,length)

! ident_86="@(#) M_strings paragraph(3f) wrap a long string into a paragraph"

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: ibegin
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: paragraph(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
!-----------------------------------------------------------------------------------------------------------------------------------
!  parse string once to find out how big to make the returned array, then redo everything but store the data
!  could store array of endpoints and leave original whitespace alone or many other options
   do i=1,2
      iword_max=0                                  ! length of longest token
      ilines=1                                     ! number of output line output will go on
      ilength=0                                    ! length of output line so far
      itoken=0                                     ! must set ITOKEN=0 before looping on strtok(3f) on a new string.
      do while ( strtok(source_string,itoken,ibegin,iend,delimiters) )
         iword=iend-ibegin+1
         iword_max=max(iword_max,iword)
         if(iword > length)then                   ! this token is longer than the desired line length so put it on a line by itself
            if(ilength /= 0)then
               ilines=ilines+1
            endif
            if(i == 2)then     ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph
               paragraph(ilines)=source_string(ibegin:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword <= length)then       ! this word will fit on current line
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=ilength+iword+1
         else                                      ! adding this word would make line too long so start new line
            ilines=ilines+1
            ilength=0
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then                                 ! determined number of lines needed so allocate output array
         allocate(character(len=max(length,iword_max)) :: paragraph(ilines))
         paragraph=' '
      endif
   enddo
   paragraph=paragraph(:ilines)
end function paragraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function setbits8(string) result(answer)
integer(kind=int8)          :: answer
character(len=8),intent(in) :: string
integer                     :: pos
integer                     :: lgth
   answer=0_int8
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits8* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,lgth
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits8* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits8
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits16(string) result(answer)
integer(kind=int16)          :: answer
character(len=16),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int16
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits16* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits16* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits16
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits32(string) result(answer)
integer(kind=int32)          :: answer
character(len=32),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int32
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits32* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits32* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits32
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits64(string) result(answer)
integer(kind=int64)          :: answer
character(len=64),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int64
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits64* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits64* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     msg(3f) - [M_strings:TYPE] converts any standard scalar type to a string
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!     function msg(g1,g2g3,g4,g5,g6,g7,g8,g9,sep)
!!
!!      class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!      character(len=*),intent(in),optional :: sep
!!      character(len=:),allocatable :: msg
!!
!!##DESCRIPTION
!!     msg(3f) builds a space-separated string from up to nine scalar values.
!!
!!##OPTIONS
!!     g[1-9]  optional value to print the value of after the message. May
!!             be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!             or CHARACTER.
!!     sep     separator between values. Defaults to a space
!!
!!##RETURNS
!!     msg     description to print
!!
!!##EXAMPLES
!!
!!
!!   Sample program:
!!
!!        program demo_msg
!!        use M_strings, only : msg
!!        implicit none
!!        character(len=:),allocatable :: pr
!!        character(len=:),allocatable :: frmt
!!        integer                      :: biggest
!!
!!        pr=msg('HUGE(3f) integers',huge(0),&
!!        & 'and real',huge(0.0),'and double',huge(0.0d0))
!!        write(*,'(a)')pr
!!        pr=msg('real            :',&
!!         & huge(0.0),0.0,12345.6789,tiny(0.0) )
!!        write(*,'(a)')pr
!!        pr=msg('doubleprecision :',&
!!         & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!        write(*,'(a)')pr
!!        pr=msg('complex         :',&
!!         & cmplx(huge(0.0),tiny(0.0)) )
!!        write(*,'(a)')pr
!!
!!        ! create a format on the fly
!!        biggest=huge(0)
!!        ! +0 for gfortran-11 bug
!!        frmt=msg('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='')
!!        write(*,*)'format=',frmt
!!
!!        ! although it will often work, using msg(3f) in an I/O statement
!!        ! is not recommended
!!        write(*,*)msg('program will now stop')
!!
!!        end program demo_msg
!!
!!   Output
!!
!!       HUGE(3f) integers 2147483647 and real 3.40282347E+38
!!       and double 1.7976931348623157E+308
!!       real            : 3.40282347E+38 0.00000000
!!       12345.6787 1.17549435E-38
!!       doubleprecision : 1.7976931348623157E+308 0.0000000000000000
!!       12345.678900000001 2.2250738585072014E-308
!!       complex         : (3.40282347E+38,1.17549435E-38)
!!        format=(*(i9:,1x))
!!        program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function msg_scalar(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)

! ident_87="@(#) M_strings msg_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: generic1 ,generic2 ,generic3 ,generic4 ,generic5
class(*),intent(in),optional  :: generic6 ,generic7 ,generic8 ,generic9
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: ibegin
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   ibegin=1
   line=' '
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_scalar=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int16));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int32));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int64));    write(line(ibegin:),'(i0)') generic
      type is (real(kind=real32));      write(line(ibegin:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real128));     write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real256));     write(line(ibegin:),'(1pg0)') generic
      type is (logical);                write(line(ibegin:),'(l1)') generic
      type is (character(len=*));       write(line(ibegin:),'(a)') trim(generic)
      type is (complex);                write(line(ibegin:),'("(",1pg0,",",1pg0,")")') generic
   end select
   ibegin=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function msg_one(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)

! ident_88="@(#) M_strings msg_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)           :: generic1(:)
class(*),intent(in),optional  :: generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable   :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: ibegin
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   ibegin=1
   line=' '
   call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(ibegin:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(ibegin:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real128));     write(line(ibegin:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real256));     write(line(ibegin:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(ibegin:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(ibegin:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(ibegin:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
   end select
   ibegin=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    find_field(3f) - [M_strings:TOKENS] parse a string into tokens
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine find_field (string, field, position, delims, delim, found)
!!
!!     character*(*),intent(in)           :: string
!!     character*(*),intent(out)          :: field
!!     integer,optional,intent(inout)     :: position
!!     character*(*),optional,intent(in)  :: delims
!!     character*(*),optional,intent(out) :: delim
!!     logical,optional,intent(out)       :: found
!!
!!##DESCRIPTION
!!
!!    Find a delimited field in a string.
!!
!!    Here's my equivalent, which I've used for nearly 2 decades, as you can
!!    see from the date. This doesn't try to mimic the C strtok (and doesn't
!!    have its limitations either). It is in a much more native Fortran style.
!!
!!    It is a little more complicated than some because it does some things
!!    that I regularly find useful. For example, it can tell the caller what
!!    trailing delimiter it found. This can be useful, for example, to
!!    distinguish between
!!
!!        somefield, someotherfield
!!
!!    versus
!!
!!        somefield=somevalue, someotherfield
!!
!!    Also, I have a bit of special handling for blanks. All the usage
!!    information is in the argument descriptions. Note that most of the
!!    arguments are optional.
!!
!!        from comp.lang.fortran @ Richard Maine
!!
!!##OPTIONS
!!    STRING     The string input.
!!
!!    FIELD      The returned field. Blank if no field found.
!!
!!    POSITION   On entry, the starting position for searching for the field.
!!               Default is 1 if the argument is not present.
!!               On exit, the starting position of the next field or
!!               len(string)+1 if there is no following field.
!!
!!    DELIMS     String containing the characters to be accepted as delimiters.
!!               If this includes a blank character, then leading blanks are
!!               removed from the returned field and the end delimiter may
!!               optionally be preceded by blanks. If this argument is
!!               not present, the default delimiter set is a blank.
!!
!!    DELIM      Returns the actual delimiter that terminated the field.
!!               Returns char(0) if the field was terminated by the end of
!!               the string or if no field was found.
!!               If blank is in delimiters and the field was terminated
!!               by one or more blanks, followed by a non-blank delimiter,
!!               the non-blank delimiter is returned.
!!
!!    FOUND      True if a field was found.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!        program demo_find_field
!!        use M_strings, only : find_field
!!        implicit none
!!        character(len=256)           :: string
!!        character(len=256)           :: field
!!        integer                      :: position
!!        character(len=:),allocatable :: delims
!!        character(len=1)             :: delim
!!        logical                      :: found
!!
!!        delims='[,]'
!!        position=1
!!        found=.true.
!!        string='[a,b,[ccc,ddd],and more]'
!!        write(*,'(a)')trim(string)
!!        do
!!           call find_field(string,field,position,delims,delim,found=found)
!!           if(.not.found)exit
!!           write(*,'("<",a,">")')trim(field)
!!        enddo
!!        write(*,'(*(g0))')repeat('=',70)
!!
!!        position=1
!!        found=.true.
!!        write(*,'(a)')trim(string)
!!        do
!!           call find_field(string,field,position,'[], ',delim,found=found)
!!           if(.not.found)exit
!!           write(*,'("<",a,">",i0,1x,a)')trim(field),position,delim
!!        enddo
!!        write(*,'(*(g0))')repeat('=',70)
!!
!!        end program demo_find_field
!! ```
!! Results:
!! ```text
!!  > [a,b,[ccc,ddd],and more]
!!  > <>
!!  > <a>
!!  > <b>
!!  > <>
!!  > <ccc>
!!  > <ddd>
!!  > <>
!!  > <and more>
!!  > <>
!!  > ======================================================================
!!  > [a,b,[ccc,ddd],and more]
!!  > <>2 [
!!  > <a>4 ,
!!  > <b>6 ,
!!  > <>7 [
!!  > <ccc>11 ,
!!  > <ddd>15 ]
!!  > <>16 ,
!!  > <and>20
!!  > <more>257 ]
!!  > ======================================================================
!!
!!##AUTHOR
!!    Richard Maine
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright Nov 15 1990, Richard Maine
!!
!!    Minor editing to conform to inclusion in the string procedure module
subroutine find_field (string, field, position, delims, delim, found)

!-- Find a delimited field in a string.
!-- 15 Nov 90, Richard Maine.

!-------------------- interface.
character*(*),intent(in)           :: string
character*(*),intent(out)          :: field
integer,optional,intent(inout)     :: position
character*(*),optional,intent(in)  :: delims
character*(*),optional,intent(out) :: delim
logical,optional,intent(out)       :: found
!-------------------- local.
character  :: delimiter*1
integer    :: pos, field_start, field_end, i
logical    :: trim_blanks
!-------------------- executable code.
   field = ''
   delimiter = char(0)
   pos = 1
   if (present(found)) found = .false.
   if (present(position)) pos = position
   if (pos > len(string)) goto 9000
   !if (pos < 1) error stop 'Illegal position in find_field'
   if (pos < 1) stop 'Illegal position in find_field'

   !-- Skip leading blanks if blank is a delimiter.
   field_start = pos
   trim_blanks = .true.
   if (present(delims)) trim_blanks = index(delims,' ') /= 0
   if (trim_blanks) then
      i = verify(string(pos:),' ')
      if (i == 0) then
         pos = len(string) + 1
         goto 9000
      end if
      field_start = pos + i - 1
   end if
   if (present(found)) found = .true.

   !-- Find the end of the field.
   if (present(delims)) then
      i = scan(string(field_start:), delims)
   else
      i = scan(string(field_start:), ' ')
   end if
   if (i == 0) then
      field_end = len(string)
      delimiter = char(0)
      pos = field_end + 1
   else
      field_end = field_start + i - 2
      delimiter = string(field_end+1:field_end+1)
      pos = field_end + 2
   end if

   !-- Return the field.
   field = string(field_start:field_end)

   !-- Skip trailing blanks if blank is a delimiter.
   if (trim_blanks) then
      i = verify(string(field_end+1:), ' ')
      if (i == 0) then
         pos = len(string) + 1
         goto 9000
      end if
      pos = field_end + i

      !-- If the first non-blank character is a delimiter,
      !-- skip blanks after it.
      i = 0
      if (present(delims)) i = index(delims, string(pos:pos))
      if (i /= 0) then
         delimiter = string(pos:pos)
         pos = pos + 1
         i = verify(string(pos:), ' ')
         if (i == 0) then
            pos = len(string) + 1
         else
            pos = pos + i - 1
         end if
      end if
   end if
   !---------- Normal exit.
   9000 continue
   if (present(delim)) delim = delimiter
   if (present(position)) position = pos
end subroutine find_field
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split2020(3f) - [M_strings:TOKENS] parse a string into tokens using
!!    proposed f2023 method
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   TOKEN form
!!
!!    subroutine split2020 (string, set, tokens, separator)
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    character(len=:),allocatable,intent(out) :: tokens(:)
!!    character(len=1),allocatable,intent(out),optional :: separator(:)
!!
!!   BOUNDS ARRAY form
!!
!!    subroutine split2020 (string, set, first, last)
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    integer,allocatable,intent(out) :: first(:)
!!    integer,allocatable,intent(out) :: last(:)
!!
!!   STEP THROUGH BY POSITION form
!!
!!    subroutine split2020 (string, set, pos [, back])
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    integer,intent(inout)       :: pos
!!    logical,intent(in),optional :: back
!!
!!##DESCRIPTION
!!    Parse a string into tokens. STRING, SET, TOKENS and SEPARATOR must
!!    all be of the same CHARACTER kind type parameter.
!!
!!##OPTIONS
!!    STRING      string to break into tokens
!!
!!    SET         Each character in SET is a token delimiter. A
!!                sequence of zero or more characters in STRING delimited by
!!                any token delimiter, or the beginning or end of STRING,
!!                comprise a token. Thus, two consecutive token delimiters
!!                in STRING, or a token delimiter in the first or last
!!                character of STRING, indicate a token with zero length.
!!
!!                ??? how about if null defaults to all whitespace characters
!!
!!    TOKENS      It is allocated with the lower bound equal to
!!                one and the upper bound equal to the number of tokens in
!!                STRING, and with character length equal to the length of
!!                the longest token. The tokens in STRING are assigned by
!!                intrinsic assignment, in the order found, to the elements
!!                of TOKENS, in array element order.
!!
!!                ???If input is null it still must be of size 1?
!!
!!    SEPARATOR   Each element in SEPARATOR(i) is assigned the value of
!!                the ith token delimiter in STRING.
!!                It is allocated with the lower bound equal to
!!                one and the upper bound equal to one less than the number
!!                of tokens in STRING, and with character length equal to
!!                one.
!!
!!                ???one less than? '' ' '
!!
!!    FIRST     It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the starting
!!              position of each token in STRING, in the order found. If a
!!              token has zero length, the starting position is equal to one
!!              if the token is at the beginning of STRING, and one greater
!!              than the position of the preceding delimiter otherwise.
!!
!!    LAST      It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the ending
!!              position of each token in STRING, in the order found. If
!!              a token has zero length, the ending position is one less
!!              than the starting position.
!!
!!    POS       If BACK is present with the value .TRUE., the value
!!              of POS shall be in the range 0 < POS     LEN (STRING)+1;
!!              otherwise it shall be in the range 0     POS LEN (STRING).
!!
!!              If BACK is absent or is present with the value .FALSE., POS
!!              is assigned the position of the leftmost token delimiter in
!!              STRING whose position is greater than POS, or if there is
!!              no such character, it is assigned a value one greater than
!!              the length of STRING. This identifies a token with starting
!!              position one greater than the value of POS on invocation,
!!              and ending position one less than the value of POS on return.
!!
!!              If BACK is present with the value true, POS is assigned the
!!              position of the rightmost token delimiter in STRING whose
!!              position is less than POS, or if there is no such character,
!!              it is assigned the value zero. This identifies a token with
!!              ending position one less than the value of POS on invocation,
!!              and starting position one greater than the value of POS
!!              on return.
!!
!!              When SPLIT is invoked with a value for POS of
!!              1 <= POS <= LEN(STRING) and STRING(POS:POS) is not a
!!              token delimiter present in SET, the token identified by
!!              SPLIT does not comprise a complete token as described in the
!!              description of the SET argument, but rather a partial token.
!!
!!    BACK      shall be a logical scalar. It is an INTENT (IN) argument. If
!!              POS does not appear and BACK is present with the value true,
!!              STRING is scanned backwards for tokens starting from the
!!              end. If POS does not appear and BACK is absent or present
!!              with the value false, STRING is scanned forwards for tokens
!!              starting from the beginning.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!    program demo_sort2020
!!    use M_strings, only : split2020
!!    implicit none
!!    character(len=*),parameter :: gen='(*("[",g0,"]":,","))'
!!
!!     ! Execution of TOKEN form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=:), allocatable :: tokens(:)
!!       character (len=*),parameter :: set = " ,"
!!       string = 'first,second,third'
!!       call split2020(string, set, tokens )
!!       write(*,gen)tokens
!!
!!     ! assigns the value ['first ','second','third ' ]
!!     ! to TOKENS.
!!     endblock
!!
!!     ! Execution of BOUNDS form
!!
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer, allocatable        :: first(:), last(:)
!!       string =    'first,second,,forth'
!!       call split2020 (string, set, first, last)
!!       write(*,gen)first
!!       write(*,gen)last
!!
!!     ! will assign the value [ 1, 7, 14, 15 ] to FIRST,
!!     ! and the value [ 5, 12, 13, 19 ] to LAST.
!!     endblock
!!
!!     ! Execution of STEP form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer :: p, ibegin, iend
!!       string = " one,   last  example  "
!!       do while (p < len(string))
!!         ibegin = p + 1
!!         call split2020 (string, set, p)
!!         iend=p-1
!!         if(iend > ibegin)then
!!            print '(t3,a,1x,i0,1x,i0)', string (ibegin:iend),ibegin,iend
!!         endif
!!       enddo
!!     endblock
!!    end program demo_sort2020
!!
!!   Results:
!!
!!    [first ],[second],[third ]
!!    [1],[7],[14],[15]
!!    [5],[12],[13],[19]
!!      one 2 4
!!      last 9 12
!!      example 15 21
!!
!!      > ??? option to skip adjacent delimiters (not return null tokens)
!!      >     common with whitespace
!!      > ??? quoted strings, especially CSV both " and ', Fortran adjacent
!!      >     is insert versus other rules
!!      > ??? escape character like \\ .
!!      > ??? multi-character delimiters like \\n, \\t,
!!      > ??? regular expression separator
!!
!!##AUTHOR
!!    Milan Curcic, "milancurcic@hey.com"
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright 2020, Milan Curcic
  pure subroutine split_tokens(string, set, tokens, separator)
     ! Splits a string into tokens using characters in set as token delimiters.
     ! If present, separator contains the array of token delimiters.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    character(:), allocatable, intent(out) :: tokens(:)
    character, allocatable, intent(out), optional :: separator(:)

    integer, allocatable :: first(:), last(:)
    integer :: n

    call split2020(string, set, first, last)
    allocate(character(len=maxval(last - first) + 1) :: tokens(size(first)))

    do concurrent (n = 1:size(tokens))
      tokens(n) = string(first(n):last(n))
    enddo

    if (present(separator)) then
      allocate(separator(size(tokens) - 1))
      do concurrent (n = 1:size(tokens) - 1)
        separator(n) = string(first(n+1)-1:first(n+1)-1)
      enddo
    endif

  end subroutine split_tokens
!===================================================================================================================================
  pure subroutine split_first_last(string, set, first, last)
     ! Computes the first and last indices of tokens in input string, delimited
     ! by the characters in set, and stores them into first and last output
     ! arrays.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    integer, allocatable, intent(out) :: first(:)
    integer, allocatable, intent(out) :: last(:)

    character :: set_array(len(set))
    logical, dimension(len(string)) :: is_first, is_last, is_separator
    integer :: n, slen

    slen = len(string)

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    do concurrent (n = 1:slen)
      is_separator(n) = any(string(n:n) == set_array)
    enddo

    is_first = .false.
    is_last = .false.

    if (.not. is_separator(1)) is_first(1) = .true.

    do concurrent (n = 2:slen-1)
      if (.not. is_separator(n)) then
        if (is_separator(n - 1)) is_first(n) = .true.
        if (is_separator(n + 1)) is_last(n) = .true.
      else
        if (is_separator(n - 1)) then
          is_first(n) = .true.
          is_last(n-1) = .true.
        endif
      endif
    enddo

    if (.not. is_separator(slen)) is_last(slen) = .true.

    first = pack([(n, n = 1, slen)], is_first)
    last = pack([(n, n = 1, slen)], is_last)

  end subroutine split_first_last
!===================================================================================================================================
  pure subroutine split_pos(string, set, pos, back)
     ! If back is absent, computes the leftmost token delimiter in string whose
     ! position is > pos. If back is present and true, computes the rightmost
     ! token delimiter in string whose position is < pos. The result is stored
     ! in pos.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    integer, intent(in out) :: pos
    logical, intent(in), optional :: back

    logical :: backward
    character :: set_array(len(set))
    integer :: n, result_pos

    !TODO use optval when implemented in stdlib
    !backward = optval(back, .false.)
    backward = .false.
    if (present(back)) backward = back

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    if (backward) then
      result_pos = 0
      do n = pos - 1, 1, -1
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    else
      result_pos = len(string) + 1
      do n = pos + 1, len(string)
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    endif

    pos = result_pos

  end subroutine split_pos
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
  pure function string_tokens(string, set) result(tokens)
     ! Splits a string into tokens using characters in set as token delimiters.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    character(:), allocatable :: tokens(:)
    call split_tokens(string, set, tokens)
  end function string_tokens
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! Duplicate the M_journal module in condensed form for now so can be stand-alone on GITHUB
!                                                                     ll
!                                                                      l
!    j                                                                 l
!                                                                      l
!    j                                                                 l
!    j        oooooo    u      u   r rrrrrr   n nnnnn      aaaa        l
!    j       o      o   u      u   rr         nn     n         a       l
!    j       o      o   u      u   r          n      n    aaaaaa       l
! j  j       o      o   u      u   r          n      n   a     a       l
!  jj         oooooo     uuuuuu u  r          n      n    aaaaa a      l
!
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! @(#) place-holder for journal module
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

!@(#) M_journal::where_write_message(3fp): basic message routine used for journal files

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save  :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable       :: prefix            ! the prefix string to add to output
logical,save                       :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)                :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   prefix=''
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
          !elseif(times == 0)then
          !   write(stdout,'(a)',advance=adv)prefix//trim(msg)
          !   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg == '')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=clip(msg),iostat=ios)
            if(ios == 0)then
               stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
             ! write(stdout,'(2a)',advance=adv)prefix,trim(msg)
             ! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=clip(msg),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=clip(msg),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()
call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message_all(where, g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,nospace)

!$(#) M_journal::where_write_message_all(3f): writes a message to a string composed of any standard scalar types

character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
logical,intent(in),optional   :: nospace
 !call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,nospace))
end subroutine where_write_message_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

!$(#) M_journal::write_message_only(3fp): calls JOURNAL('sc',message)

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function str_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:), allocatable :: str_scalar
character(len=4096)           :: line
integer                       :: ibegin
integer                       :: increment
character(len=:),allocatable  :: sep_local
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   ibegin=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   str_scalar=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int16));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int32));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int64));    write(line(ibegin:),'(i0)') generic
      type is (real(kind=real32));      write(line(ibegin:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real128));     write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real256));     write(line(ibegin:),'(1pg0)') generic
      type is (logical);                write(line(ibegin:),'(l1)') generic
      type is (character(len=*));       write(line(ibegin:),'(a)') trim(generic)
      type is (complex);                write(line(ibegin:),'("(",1pg0,",",1pg0,")")') generic
   end select
   ibegin=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function str_scalar
!===================================================================================================================================
function str_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: str_one
character(len=4096)           :: line
integer                       :: ibegin
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   ibegin=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   str_one=trim(line)
contains

subroutine print_generic(generic)
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(ibegin:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(ibegin:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(ibegin:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real128));     write(line(ibegin:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real256));     write(line(ibegin:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(ibegin:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(ibegin:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(ibegin:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   line=trim(line)//"]"//sep_local
   ibegin=len_trim(line)+increment
end subroutine print_generic

end function str_one
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     matching_delimiter(3f) - [M_strings:QUOTES] find position of matching delimiter
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   impure elemental subroutine matching_delimiter(str,ipos,imatch)
!!
!!    character(len=*),intent(in)  :: str
!!    integer,intent(in)           :: ipos
!!    integer,intent(out)          :: imatch
!!
!!##DESCRIPTION
!!    Sets imatch to the position in string of the delimiter matching the
!!    delimiter in position ipos. Allowable delimiters are (), [], {}, <>.
!!
!!##OPTIONS
!!    str     input string to locate delimiter position in
!!    ipos    position of delimiter to find match for
!!    imatch  location of matching delimiter. If no match is found, zero (0)
!!            is returned.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_matching_delimiter
!!       use M_strings, only : matching_delimiter
!!       implicit none
!!       character(len=128)  :: str
!!       integer             :: imatch
!!
!!       str=' a [[[[b] and ] then ] finally ]'
!!       write(*,*)'string=',str
!!       call matching_delimiter(str,1,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,4,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,5,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,6,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,7,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,32,imatch)
!!       write(*,*)'location=',imatch
!!
!!    end program demo_matching_delimiter
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
impure elemental subroutine matching_delimiter(str,ipos,imatch)

! Sets imatch to the position in string of the delimiter matching the delimiter
! in position ipos. Allowable delimiters are (), [], {}, <>.

! pedigree?

character(len=*),intent(in) :: str
integer,intent(in) :: ipos
integer,intent(out) :: imatch

character :: delim1,delim2,ch
integer :: lenstr
integer :: idelim2
integer :: ibegin, iend
integer :: inc
integer :: isum
integer :: i

imatch=0
lenstr=len_trim(str)
delim1=str(ipos:ipos)
select case(delim1)
   case('(')
      idelim2=iachar(delim1)+1
      ibegin=ipos+1
      iend=lenstr
      inc=1
   case(')')
      idelim2=iachar(delim1)-1
      ibegin=ipos-1
      iend=1
      inc=-1
   case('[','{','<')
      idelim2=iachar(delim1)+2
      ibegin=ipos+1
      iend=lenstr
      inc=1
   case(']','}','>')
      idelim2=iachar(delim1)-2
      ibegin=ipos-1
      iend=1
      inc=-1
   case default
      write(stderr,*) '*matching_delimiter*',delim1,' is not a valid delimiter'
      return
end select
if(ibegin < 1 .or. ibegin > lenstr) then
   write(stderr,*) '*matching_delimiter*',delim1,' has no matching delimiter'
   return
endif
delim2=achar(idelim2) ! matching delimiter

isum=1
do i=ibegin,iend,inc
   ch=str(i:i)
   if(ch /= delim1 .and. ch /= delim2) cycle
   if(ch == delim1) isum=isum+1
   if(ch == delim2) isum=isum-1
   if(isum == 0) exit
enddo
if(isum /= 0) then
   write(stderr,*) '*matching_delimiter*',delim1,' has no matching delimiter'
   return
endif
imatch=i

end subroutine matching_delimiter
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_common_substring(3f) - [M_strings:COMPARE] function that
!!    returns the longest common substring of two strings.
!!##SYNOPSIS
!!
!!    function longest_common_substring(a,b) result(match)
!!
!!     character(len=*),intent(in)  :: a, b
!!     character(len=:),allocatable :: match
!!##DESCRIPTION
!!    function that returns the longest common substring of two strings.
!!
!!    Note that substrings are consecutive characters within a string.
!!    This distinguishes them from subsequences, which is any sequence of
!!    characters within a string, even if there are extraneous characters in
!!    between them.
!!
!!    Hence, the longest common subsequence between "thisisatest" and
!!    "testing123testing" is "tsitest", whereas the longest common substring
!!    is just "test".
!!##OPTIONS
!!    a,b  strings to search for the longest common substring.
!!##RETURNS
!!    longest_common_substring  the longest common substring found
!!##EXAMPLE
!!
!!  Sample program
!!
!!    program demo_longest_common_substring
!!    use M_strings, only : longest_common_substring
!!    implicit none
!!      call compare('testing123testingthing','thisis',             'thi')
!!      call compare('testing',             'sting',              'sting')
!!      call compare('thisisatest_stinger','testing123testingthing','sting')
!!      call compare('thisisatest_stinger', 'thisis',            'thisis')
!!      call compare('thisisatest',         'testing123testing',   'test')
!!      call compare('thisisatest',      'thisisatest',     'thisisatest')
!!    contains
!!
!!    subroutine compare(a,b,answer)
!!    character(len=*),intent(in) :: a, b, answer
!!    character(len=:),allocatable :: match
!!    character(len=*),parameter :: g='(*(g0))'
!!       match=longest_common_substring(a,b)
!!       write(*,g) 'comparing "',a,'" and "',b,'"'
!!       write(*,g) merge('(PASSED) "','(FAILED) "',answer == match), &
!!       & match,'"; expected "',answer,'"'
!!    end subroutine compare
!!
!!    end program demo_longest_common_substring
!!
!!   expected output
!!
!!    comparing "testing123testingthing" and "thisis"
!!    (PASSED) "thi"; expected "thi"
!!    comparing "testing" and "sting"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "testing123testingthing"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "thisis"
!!    (PASSED) "thisis"; expected "thisis"
!!    comparing "thisisatest" and "testing123testing"
!!    (PASSED) "test"; expected "test"
!!    comparing "thisisatest" and "thisisatest"
!!    (PASSED) "thisisatest"; expected "thisisatest"
function longest_common_substring(a,b) result(match)
character(len=*),intent(in)  :: a, b
character(len=:),allocatable :: match
character(len=:),allocatable :: a2, b2
integer :: left, foundat, len_a, i
   if(len(a) < len(b))then ! to reduce required comparisions look for shortest string in longest string
      a2=a
      b2=b
   else
      a2=b
      b2=a
   endif

   match=''

   do i=1,len(a2)-1
      len_a=len(a2)
      do left=1,len_a
         foundat=index(b2,a2(left:))
         if(foundat /= 0.and.len(match) < len_a-left+1)then
            if(len(a2(left:)) > len(match))then
               match=a2(left:)
               exit
            endif
         endif
      enddo

      if(len(a2) < len(match))exit
      a2=a2(:len(a2)-1)

   enddo

end function longest_common_substring
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

pure elemental function atoi (string) result(val)    ! Convert STRING to an integer value
integer(kind=int32) :: val
character(len=*), intent(in) :: string
character(len=1)            :: c
integer                     :: i
integer                     :: j
integer                     :: ilen
logical                     :: neg

   val = 0
   neg=.false.
   i=0
   c=' '

   ilen=len(string)
   do i=1, ilen                               ! Pass over any leading spaces
      c = string(i:i)
      if (c  /=  ' ') exit
   enddo

   if (c  ==  '-') then                       ! check for +- as first digit
      neg = .true.
      i = i + 1
   elseif (c  ==  '+') then
      neg = .false.
      i = i + 1
   endif

   do j=i,ilen                                ! Continue as long as its a digit ...
      c = string(j:j)
      if (lge(c, '0') .and. lle(c, '9')) then
         val = 10*val + ichar(c)-48           ! Shift number over and add new digit
      else
         exit
      endif
   enddo

   if (neg) val = -val                        ! Negate the result if necessary

end function atoi

pure elemental function atol (string) result(val)    ! Convert STRING to an integer value
integer(kind=int64) :: val
character(len=*), intent(in) :: string
character(len=1)            :: c
integer                     :: i
integer                     :: j
integer                     :: ilen
logical                     :: neg

   val = 0
   neg=.false.
   i=0
   c=' '

   ilen=len(string)
   do i=1, ilen                               ! Pass over any leading spaces
      c = string(i:i)
      if (c  /=  ' ') exit
   enddo

   if (c  ==  '-') then                       ! check for +- as first digit
      neg = .true.
      i = i + 1
   elseif (c  ==  '+') then
      neg = .false.
      i = i + 1
   endif

   do j=i,ilen                                ! Continue as long as its a digit ...
      c = string(j:j)
      if (lge(c, '0') .and. lle(c, '9')) then
         val = 10*val + ichar(c)-48           ! Shift number over and add new digit
      else
         exit
      endif
   enddo

   if (neg) val = -val                        ! Negate the result if necessary

end function atol
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    aton(3f) - [M_strings:TYPE] function returns argument as a numeric
!!    value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function aton(str,val[,msg])
!!
!!     character(len=*),intent(in)       :: str
!!     type(TYPE(kind=KIND)),intent(out) :: val
!!     character(len=:),allocatable,intent(out) :: msg
!!
!!##DESCRIPTION
!!    This function converts a string to a numeric value.
!!
!!##OPTIONS
!!
!!     str      holds string assumed to represent a numeric value
!!     val      returned value. May be REAL or INTEGER.
!!     msg      message describing error when ATON returns .false.
!!
!!##RETURNS
!!     aton     .true. if the conversion was successful, .false. otherwise
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!      program demo_aton
!!
!!       use M_strings, only: aton
!!       implicit none
!!       character(len=14),allocatable :: strings(:)
!!       doubleprecision               :: dv
!!       integer                       :: iv
!!       real                          :: rv
!!       integer                       :: i
!!
!!       ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!       strings=[&
!!       &' 10.345       ',&
!!       &'+10           ',&
!!       &'    -3        ',&
!!       &'    -4.94e-2  ',&
!!       &'0.1           ',&
!!       &'12345.678910d0',&
!!       &'              ',& ! Note: will return zero without an error message
!!       &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!       &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!       do i=1,size(strings)
!!          write(*,'(a)',advance='no')'STRING:',strings(i)
!!          if(aton(strings(i),iv)) write(*,'(g0)',advance='no')':INTEGER ',iv
!!          if(aton(strings(i),rv)) write(*,'(g0)',advance='no')':INTEGER ',rv
!!          if(aton(strings(i),dv)) write(*,'(g0)',advance='no')':INTEGER ',dv
!!       enddo
!!
!!       end program demo_aton
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
logical function ator_real32(str,val,msg)
use iso_fortran_env, only: wp => real32, ip => int64, int8
! Convert ASCII-text to DP and return .TRUE. if OK
character(len=*),intent(in) :: str
real(kind=wp) :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: upper_e=iachar('E'), lower_e=iachar('e'), upper_d=iachar('D'), lower_d=iachar('d')
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-'), decimal=iachar('.')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: sval(3)
integer                       :: digit_count(3)
integer(kind=int8)            :: value(3,len(str))
real(kind=wp)                 :: whole, fractional
integer                       :: power
integer                       :: cnt(6)
integer(kind=int8)            :: a, part
integer                       :: i, ipos, ios, too_many_digit_count

   value=0.0_wp
   cnt=0
   digit_count=0
   ipos=0
   ator_real32 = .false.
   sval = [1,0,1]
   part = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         digit_count(part) = digit_count(part) + 1
         if(digit_count(part) < 19)then
            value(part,digit_count(part)) = a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
      case(decimal)                              ! if more than once should report error
         if(part > 2)cnt(5)=99999               ! decimal in exponent
         part = 2                                ! starting fractional value
         cnt(1)=cnt(1)+1
      case(upper_e,lower_e,upper_d,lower_d)      ! if more than once should report error
         part = 3
         cnt(2)=cnt(2)+1                         ! if more than one encountered an error
         ipos=0
      case(minus_sign)                           ! sign in non-standard position or duplicated should report error
         sval(part) = -1
         if(ipos /= 1)cnt(6)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(space)                                ! should possibly not ignore all internal spaces
         ipos=ipos-1
      case default
         value(part,:) = 0.0_wp
         cnt(5)=99999                            ! unknown character
         !return
      end select
   enddo
   ! is no value after E an error?
   whole=0.0_wp
   do i = digit_count(1),1,-1
      whole=whole+value(1,i)*10**(digit_count(1)-i)
   enddo

   power=0
   do i = digit_count(3),1,-1
      power=power+value(3,i)*10**(digit_count(3)-i)
   enddo

   fractional=0.0_wp
   do i = digit_count(2),1,-1
      fractional=fractional+real(value(2,i),kind=wp)/10.0_wp**i
   enddo

   associate ( sgn=>sval(1), sexp=>sval(3) )
   val = sign(whole + fractional,real(sgn,kind=wp))* (10.0_wp**(power*sexp+too_many_digit_count))
   end associate
   if(all(cnt <= 1).and.ipos /= 0)then
      ator_real32 = .true.
   else
      read(str,fmt=*,iostat=ios) val ! use internal read for INF, NAN for now
      if(ios == 0)then
         ator_real32 = .true.
         if(present(msg)) msg=''
      else
         if(present(msg))then
            if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(5) /= 0)then
               msg='decimal in exponent in "'//trim(str)//'"'
            elseif(cnt(1) >= 2)then
               msg='multiple decimals in "'//trim(str)//'"'
            elseif(cnt(2) >= 2)then
               msg='more than one exponent prefix (e,d,E,D) in "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
         endif
         ator_real32 = .false.
      endif
   endif
end function ator_real32
logical function ator_real64(str,val,msg)
use iso_fortran_env, only: wp => real64, ip => int64, int8
! Convert ASCII-text to DP and return .TRUE. if OK
character(len=*),intent(in) :: str
real(kind=wp) :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: upper_e=iachar('E'), lower_e=iachar('e'), upper_d=iachar('D'), lower_d=iachar('d')
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-'), decimal=iachar('.')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: sval(3)
integer                       :: digit_count(3)
integer(kind=int8)            :: value(3,len(str))
real(kind=wp)                 :: whole, fractional
integer                       :: power
integer                       :: cnt(6)
integer(kind=int8)            :: a, part
integer                       :: i, ipos, ios, too_many_digit_count

   value=0.0_wp
   cnt=0
   digit_count=0
   ipos=0
   ator_real64 = .false.
   sval = [1,0,1]
   part = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         digit_count(part) = digit_count(part) + 1
         if(digit_count(part) < 19)then
            value(part,digit_count(part)) = a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
      case(decimal)                              ! if more than once should report error
         if(part > 2)cnt(5)=99999               ! decimal in exponent
         part = 2                                ! starting fractional value
         cnt(1)=cnt(1)+1
      case(upper_e,lower_e,upper_d,lower_d)      ! if more than once should report error
         part = 3
         cnt(2)=cnt(2)+1                         ! if more than one encountered an error
         ipos=0
      case(minus_sign)                           ! sign in non-standard position or duplicated should report error
         sval(part) = -1
         if(ipos /= 1)cnt(6)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(space)                                ! should possibly not ignore all internal spaces
         ipos=ipos-1
      case default
         value(part,:) = 0.0_wp
         cnt(5)=99999                            ! unknown character
         !return
      end select
   enddo
   ! is no value after E an error?
   whole=0.0_wp
   do i = digit_count(1),1,-1
      whole=whole+value(1,i)*10**(digit_count(1)-i)
   enddo

   power=0
   do i = digit_count(3),1,-1
      power=power+value(3,i)*10**(digit_count(3)-i)
   enddo

   fractional=0.0_wp
   do i = digit_count(2),1,-1
      fractional=fractional+real(value(2,i),kind=wp)/10.0_wp**i
   enddo

   associate ( sgn=>sval(1), sexp=>sval(3) )
   val = sign(whole + fractional,real(sgn,kind=wp))* (10.0_wp**(power*sexp+too_many_digit_count))
   end associate
   if(all(cnt <= 1).and.ipos /= 0)then
      ator_real64 = .true.
   else
      read(str,fmt=*,iostat=ios) val ! use internal read for INF, NAN for now
      if(ios == 0)then
         ator_real64 = .true.
         if(present(msg)) msg=''
      else
         if(present(msg))then
            if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(5) /= 0)then
               msg='decimal in exponent in "'//trim(str)//'"'
            elseif(cnt(1) >= 2)then
               msg='multiple decimals in "'//trim(str)//'"'
            elseif(cnt(2) >= 2)then
               msg='more than one exponent prefix (e,d,E,D) in "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
         endif
         ator_real64 = .false.
      endif
   endif
end function ator_real64
logical function atoi_int8(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)   :: str
integer(kind=int8)         :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: value, sval, digit_count
integer                       :: cnt(6)
integer(kind=int8)            :: a
integer                       :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int8 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int8 = .false.
   endif
end function atoi_int8
logical function atoi_int16(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)   :: str
integer(kind=int16)         :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: value, sval, digit_count
integer                       :: cnt(6)
integer(kind=int8)            :: a
integer                       :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int16 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int16 = .false.
   endif
end function atoi_int16
logical function atoi_int32(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)   :: str
integer(kind=int32)         :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: value, sval, digit_count
integer                       :: cnt(6)
integer(kind=int8)            :: a
integer                       :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int32 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int32 = .false.
   endif
end function atoi_int32
logical function atoi_int64(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)   :: str
integer(kind=int64)         :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: value, sval, digit_count
integer                       :: cnt(6)
integer(kind=int8)            :: a
integer                       :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int64 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int64 = .false.
   endif
end function atoi_int64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_strings
 
 
!>>>>> build/dependencies/M_io/src/M_io.F90
!===================================================================================================================================
MODULE M_io
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit
#ifdef __NVCOMPILER
#define NOREAL128
#else
#undef NOREAL128
#endif
implicit none
private
integer,parameter,private:: sp=kind(1.0), dp=kind(1.0d0)
public uniq
public print_inquire
public notopen
public filename_generator
public number_of_lines
public get_next_char
public dirname
public basename
public splitpath
public joinpath
public fileopen
public filebyte, slurp
public fileread, gulp, swallow
public filewrite
public fileclose
public filedelete
public get_tmp
public read_line
public getline
public read_table
public rd
public separator
public lookfor
public which
public get_env
public is_hidden_file
public getname

! ident_1="@(#) M_io rd(3f) ask for string or number from standard input with user-definable prompt"
interface rd
   module procedure rd_character
   module procedure rd_integer
   module procedure rd_real
   module procedure rd_doubleprecision
   module procedure rd_logical
end interface

! ident_2="@(#) M_io read_table(3f) read file containing a table of numeric values"
interface read_table
   module procedure read_table_i
   module procedure read_table_r
   module procedure read_table_d
end interface

interface filedelete
   module procedure filedelete_filename
   module procedure filedelete_lun
end interface

integer,save,private       :: my_stdout=stdout
logical,save               :: debug=.false.
integer,save               :: last_int=0

interface string_to_value
   module procedure a2d, a2i
end interface

interface v2s
   module procedure i2s
end interface

interface journal
   !!module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   !!module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

interface str
   module procedure msg_scalar, msg_one
end interface str
!-----------------------------------
! old names
interface swallow;  module procedure fileread;  end interface
interface gulp;     module procedure fileread;  end interface
interface slurp;    module procedure filebyte;  end interface
!-----------------------------------
character(len=*),parameter,private :: gen='(*(g0,1x))'

CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      uniq(3f) - [M_io:QUERY] append a number to the end of filename to make
!!                 a unique name if name exists
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!      Usage
!!
!!       character(len=:),allocatable function uniq(name,istart,verbose,create)
!!       character(len=*),intent(in) :: name
!!       integer,intent(in),optional :: istart
!!       logical,intent(in),optional :: verbose
!!       logical,intent(in),optional :: create
!!
!!##DESCRIPTION
!!    Given a filename test if it is in use or exists. If it is, or if it
!!    ends in a period add a number to the end of the name and
!!    test if the new name exists. If necessary, increment the number and
!!    try again up to the value 9999999. By default an empty file is created
!!    if an unused name is found.
!!
!!
!!##OPTIONS
!!    name     base input name used to create output filename
!!             If name ends in "." a numeric suffix is always added.
!!    istart   number to start with as a suffix. Default is 1. Must be a
!!             positive integer less than 9999999.
!!    verbose  writes extra messages to stdout. Defaults to .false.
!!    create   create file if a new unused name is successfully
!!             found. Defaults to .true. .
!!
!!##RETURNS
!!    uniq     A unique filename that is the same as the NAME input parameter
!!             except with a number appended at the end if needed. If could
!!             not find a unique name a blank is returned.
!!
!!##EXAMPLE
!!
!!    Sample program
!!
!!       program demo_uniq
!!       use M_io, only : uniq
!!       implicit none
!!       character(len=4096) :: myname
!!       integer             :: i
!!          myname=uniq('does_not_exist')
!!          write(*,*)'name stays the same   :',trim(myname)
!!          open(unit=10,file='does_exist')
!!          myname=uniq('does_exist')
!!          write(*,*)'name has suffix added :',trim(myname)
!!          do i=1,10
!!             myname=uniq('does_exist')
!!             write(*,*) 'FILENAME:',trim(myname)
!!             open(unit=20+i,file=myname)
!!          enddo
!!       end program demo_uniq
!!
!!    Expected output
!!
!!     name stays the same does_not_exist
!!     name has suffix added does_exist0001
!!     FILENAME:does_exist0002
!!     FILENAME:does_exist0003
!!     FILENAME:does_exist0004
!!     FILENAME:does_exist0005
!!     FILENAME:does_exist0006
!!     FILENAME:does_exist0007
!!     FILENAME:does_exist0008
!!     FILENAME:does_exist0009
!!     FILENAME:does_exist0010
!!     FILENAME:does_exist0011
!!
!!##AUTHOR
!!    John S. Urban, 1993
!!##LICENSE
!! Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
function uniq(name,istart,verbose,create)
implicit none

! ident_3="@(#) M_io uniq(3f) append a number to the end of filename to make a unique name if name exists"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: name
character(len=:),allocatable :: uniq
integer,intent(in),optional  :: istart
logical,intent(in),optional  :: verbose
logical,intent(in),optional  :: create
!-----------------------------------------------------------------------------------------------------------------------------------
logical                     :: around
integer,save                :: icount=1           ! counter to generate suffix from
character(len=4096),save    :: lastname=' '       ! name called with last time the routine was called
integer                     :: ilen
integer                     :: itimes
integer                     :: iscr
integer                     :: ios
logical                     :: verbose_local
logical                     :: create_local
!-----------------------------------------------------------------------------------------------------------------------------------
   uniq=trim(name)                                   ! the input name will be returned if it passes all the tests
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lastname /= name)then                          ! if a different input name than last time called reset icount
      lastname=name                                  ! a new name to keep for subsequent calls
      icount=1                                       ! icount is used to make a suffix to add to make the file unique
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(create))then
      create_local=create
   else
      create_local=.true.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(istart))then
      icount=istart                                  ! icount is used to make a suffix to add to make the file unique
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len_trim(name)                               ! find last non-blank character in file name
!-----------------------------------------------------------------------------------------------------------------------------------
   if(ilen /= 0)then                                 ! a blank input name so name will just be a suffix
      if(name(ilen:ilen) /= '.')then                 ! always append a number to a file ending in .
         inquire(file=name(:ilen),exist=around)      ! check filename as-is
         if(.not.around)then                         ! file name does not exist, can use it as-is
            uniq=trim(name)
            if(create_local)then
               open(newunit=iscr,file=uniq,iostat=ios,status='new')
               close(unit=iscr,iostat=ios)
            endif
            return
         endif
      endif
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   itimes=0                                           ! count number of times tried to get a uniq name
   deallocate(uniq)
   allocate(character(len=ilen+8) :: uniq)            ! make it useable with an internal WRITE(3f) with room for a numeric suffix
   uniq(:)=name
   INFINITE: do                                       ! top of loop trying for a unique name
      if(itimes >= 9999999)then                       ! if too many tries to be reasonable give up
         call journal('sc','*uniq* unable to find a unique filename. Too many tries')
         uniq=''
         return
      endif
      if(icount > 9999999) icount=1                  ! reset ICOUNT when it hits arbitrary maximum value
      if(icount <= 9999)then
         write(uniq(ilen+1:),'(i4.4)')icount          ! create name by adding a numeric string to end
      else
         write(uniq(ilen+1:),'(i7.7)')icount          ! create name by adding a numeric string to end
      endif
      icount=icount+1                                 ! increment counter used to come up with suffix
      inquire(file=uniq,exist=around)                 ! see if this filename already exists
      if(.not.around)then                             ! found an unused name
         if(verbose_local)then
            call journal('c','*uniq* name='//trim(uniq)) ! write out message reporting name used
         endif
         if(create_local)then
            open(newunit=iscr,file=uniq,iostat=ios,status='new')
            close(unit=iscr,iostat=ios)
         endif
         uniq=trim(uniq)
         return                                       ! return successfully
      endif
      itimes=itimes+1                                 ! haven't found a unique name, try again
   enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
end function uniq
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    print_inquire(3f) - [M_io:QUERY] Do INQUIRE on file by name/number and
!!                        print results
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   Definition:
!!
!!    subroutine print_inquire(lun)
!!      or
!!    subroutine print_inquire(name)
!!    integer,intent(in),optional          :: lun
!!    character(len=*),intent(in),optional :: name
!!
!!##DESCRIPTION
!!    Given either a Fortran file-unit-number or filename, call the
!!    INQUIRE(3f) intrinsic and print typical status information.
!!
!!##OPTIONS
!!    lun    if lun is not equal to -1 then query by number and ignore
!!           filename even if present
!!    name   if lun = -1  or is not present then query by this filename
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_print_inquire
!!    use M_io, only : print_inquire, fileopen
!!    implicit none
!!    character(len=4096)  :: filename
!!    character(len=20)    :: mode
!!    integer              :: ios
!!    character(len=256)   :: message
!!    integer              :: lun
!!       do
!!          write(*,'(a)',advance='no')'enter filename>'
!!          read(*,'(a)',iostat=ios)filename
!!          if(ios /= 0)exit
!!          write(*,'(a)',advance='no')'enter mode ([rwa][bt][+]>'
!!          read(*,'(a)',iostat=ios)mode
!!          if(ios /= 0)exit
!!          lun=fileopen(filename,mode,ios)
!!          if(ios == 0)then
!!             write(*,*)'OPENED'
!!          else
!!             write(*,*)'ERROR: IOS=',ios
!!          endif
!!          if(lun /= -1)then
!!             call print_inquire(lun,'')
!!             close(lun,iostat=ios,iomsg=message)
!!             if(ios /= 0)then
!!                write(*,'(a)')trim(message)
!!             endif
!!          endif
!!       enddo
!!    end program demo_print_inquire
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine print_inquire(lun_in,namein_in) ! Version: JSU-1997-12-31, 2020-01-11

! ident_4="@(#) M_io print_inquire(3f) Do INQUIRE on file by name/number and print results"

integer,intent(in),optional             :: lun_in        ! if unit >= 0 then query by unit number, else by name
character(len=*),intent(in),optional    :: namein_in
integer                        :: ios
character(len=256)             :: message
character(len=:),allocatable   :: namein
integer                        :: lun
!==============================================================================================
!  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
!  ACTION    =  READ        | WRITE         |  READWRITE
!  FORM      =  FORMATTED   |  UNFORMATTED
!  POSITION  =  ASIS        |  REWIND       |  APPEND
!  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
character(len=20)             :: access         ; namelist/inquire/access
character(len=20)             :: asynchronous   ; namelist/inquire/asynchronous
character(len=20)             :: blank          ; namelist/inquire/blank
character(len=20)             :: decimal        ; namelist/inquire/decimal
character(len=20)             :: delim          ; namelist/inquire/delim
character(len=20)             :: direct         ; namelist/inquire/direct
character(len=20)             :: encoding       ; namelist/inquire/encoding
logical                       :: exist          ; namelist/inquire/exist

character(len=20)             :: form           ; namelist/inquire/form
character(len=20)             :: formatted      ; namelist/inquire/formatted
character(len=20)             :: unformatted    ; namelist/inquire/unformatted

integer                       :: id             ; namelist/inquire/id
character(len=20)             :: name           ; namelist/inquire/name
logical                       :: named          ; namelist/inquire/named
integer                       :: nextrec        ; namelist/inquire/nextrec
integer                       :: number         ; namelist/inquire/number
logical                       :: opened         ; namelist/inquire/opened
character(len=20)             :: pad            ; namelist/inquire/pad
logical                       :: pending        ; namelist/inquire/pending
integer                       :: pos            ; namelist/inquire/pos
character(len=20)             :: position       ; namelist/inquire/position

character(len=20)             :: action         ; namelist/inquire/action
character(len=20)             :: read           ; namelist/inquire/read
character(len=20)             :: readwrite      ; namelist/inquire/readwrite
character(len=20)             :: write          ; namelist/inquire/write

integer                       :: recl           ; namelist/inquire/recl
character(len=20)             :: round          ; namelist/inquire/round
character(len=20)             :: sequential     ; namelist/inquire/sequential
character(len=20)             :: sign           ; namelist/inquire/sign
integer                       :: size           ; namelist/inquire/size
character(len=20)             :: stream         ; namelist/inquire/stream
!==============================================================================================
   namein=merge_str(namein_in,'',present(namein_in))
   lun=merge(lun_in,-1,present(lun_in))
   ! exist, opened, and named always become defined unless an error condition occurs.
   !!write(*,*)'LUN=',lun,' FILENAME=',namein
   !-----------------------------------------------------------------------------------------------------------------------------------
   name=''
   if(namein == ''.and.lun /= -1)then
         call journal('sc','*print_inquire* checking unit',lun)
         inquire(unit=lun,                                                                               &
     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
     &   position=position,                                                                              &
     &   name=name,                                                                                      &
     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
     &   sign=sign,                                                                                      &
     &   round=round,                                                                                    &
     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
     &   iostat=ios,err=999,iomsg=message)
    elseif(namein /= '')then
         call journal('sc','*print_inquire* checking file:'//namein)
         inquire(file=namein,                                                                            &
     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
     &   position=position,                                                                              &
     &   name=name,                                                                                      &
     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
     &   sign=sign,                                                                                      &
     &   round=round,                                                                                    &
     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
     &   iostat=ios,err=999,iomsg=message)
     if(name == '')name=namein
    else
       call journal('sc','*print_inquire* must specify either filename or unit number')
    endif
!-----------------------------------------------------------------------------------------------------------------------------------
   write(*,nml=inquire,delim='none')
   return
!-----------------------------------------------------------------------------------------------------------------------------------
999   continue
   call journal('sc','*print_inquire* bad inquire')
!  If an error condition occurs during execution of an INQUIRE  statement,
!  all of the inquiry identifiers except ios become undefined.
   call journal('sc','*print_inquire* inquire call failed,iostat=',ios,'message=',message)
end subroutine print_inquire
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    separator(3f) - [M_io:QUERY] try to determine pathname directory
!!                    separator character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function separator() result(sep)
!!
!!     character(len=1) :: sep
!!
!!##DESCRIPTION
!!
!!    Try to determine the separator character used to separate directory
!!    names from file basenames. It is assumed it is either a backslash or
!!    a slash character.
!!
!!    First, the environment variables PATH, HOME, PWD, and  SHELL  are
!!    examined for a backslash, then a slash.
!!
!!    Then, using the name the program was invoked with, then an INQUIRE(3f)
!!    of that name, then ".\NAME" and "./NAME" try to find an expected
!!    separator character.
!!
!!    Can be very system dependent. If the queries fail the default returned
!!    is "/".
!!
!!    The value is cached as a return value for subsequent calls.
!!
!!##EXAMPLE
!!
!!   sample usage
!!
!!    program demo_separator
!!    use M_io, only : separator
!!    implicit none
!!       write(*,*)'separator=',separator()
!!    end program demo_separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function separator() result(sep)

! use the pathname returned as arg0 to determine pathname separator
implicit none
integer                      :: ios
integer                      :: i
logical                      :: existing=.false.
character(len=1)             :: sep
!*!IFORT BUG:character(len=1),save        :: sep_cache=' '
integer,save                 :: isep=-1
character(len=4096)          :: name
character(len=:),allocatable :: envnames(:)

    ! NOTE:  A parallel code might theoretically use multiple OS
    !*!FORT BUG:if(sep_cache /= ' ')then  ! use cached value.
    !*!FORT BUG:    sep=sep_cache
    !*!FORT BUG:    return
    !*!FORT BUG:endif
    if(isep /= -1)then  ! use cached value.
        sep=char(isep)
        return
    endif
    FOUND: block
    ! simple, but does not work with ifort
    ! most MSWindows environments see to work with backslash even when
    ! using POSIX filenames to do not rely on '\.'.
    inquire(file='/.',exist=existing,iostat=ios,name=name)
    if(existing.and.ios == 0)then
        sep='/'
        exit FOUND
    endif
    ! check variables names common to many platforms that usually have a
    ! directory path in them although a ULS file can contain a backslash
    ! and vice-versa (eg. "touch A\\B\\C"). Removed HOMEPATH because it
    ! returned a name with backslash on CygWin, Mingw, WLS even when using
    ! POSIX filenames in the environment.
    envnames=[character(len=10) :: 'PATH', 'HOME']
    do i=1,size(envnames)
       if(index(get_env(envnames(i)),'\') /= 0)then
          sep='\'
          exit FOUND
       elseif(index(get_env(envnames(i)),'/') /= 0)then
          sep='/'
          exit FOUND
       endif
    enddo

    write(*,*)'<WARNING>unknown system directory path separator'
    sep='\'
    endblock FOUND
    !*!IFORT BUG:sep_cache=sep
    isep=ichar(sep)
end function separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    read_table(3f) - [M_io:READ] read file containing a table of numeric values
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine read_table(filename,array,ierr,comment)
!!
!!    character(len=*),intent(in)          :: filename
!!    TYPE,allocatable,intent(out)         :: array(:,:)
!!    integer,intent(out)                  :: ierr
!!    character(len=1,intent(in),optional  :: comment
!!
!!   where TYPE may be REAL, INTEGER, or DOUBLEPRECISION
!!
!!##DESCRIPTION
!!    Read a table from a file that is assumed to be columns of numbers,
!!    ignoring characters not in the set [0-9edED+-.] and requiring each
!!    row contain the same number of values.
!!
!!    The input file is assumed to be of a small enough size that it can
!!    be copied into memory.
!!
!!##OPTIONS
!!    filename   filename to read
!!    array      array to create. May be INTEGER, REAL, or DOUBLEPRECISION
!!    ierr       zero if no error occurred.
!!    comment    ignore lines which contain this as the first non-blank
!!               character. Ignore it and subsequent characters on any line.
!!##EXAMPLES
!!
!!    Sample program, assuming the input file "inputfile" exists:
!!
!!     program demo_read_table
!!     use M_io, only : read_table
!!     implicit none
!!     doubleprecision,allocatable :: array(:,:)
!!     integer :: i, ierr
!!
!!     ! create test file
!!     open(file='inputfile',unit=10,action='write')
!!     write(10,'(a)') [character(len=80):: &
!!      ' ___.___.___                           ', &
!!      '| 1 | 5 | 3 |                          ', &
!!      '|---+---+---|                          ', &
!!      '| 4 | 2 | 6 |                          ', &
!!      ' -----------                           ', &
!!      '    #-----#-----#------#               ', &
!!      '|   | 1   | 3e2 | 4    |               ', &
!!      '|   #-----#-----#------#               ', &
!!      '|   | 2.0 | -5  | +2.2 |               ', &
!!      '    #-----#-----#------#               ', &
!!      '                                       ', &
!!      '#___#___#___#                          ', &
!!      '| 1 | 5 | 3 |                          ', &
!!      '#---#---#---#                          ', &
!!      '| 4 | 2 | 6 |                          ', &
!!      '#---#---#---#                          ', &
!!      '                                       ', &
!!      '1;10;45                                ', &
!!      '10, ,, ,,20    45                      ', &
!!      '  2 20  15                             ', &
!!      ' big=20.345 medium=20  small=15        ', &
!!      '                                       ', &
!!      '30 30e3   0                            ', &
!!      '  4 300.444e-1 -10                     ', &
!!      '40 30.5555d0 -10                       ', &
!!      '  4 300.444E-1 -10                     ', &
!!      '40 30.5555D0 -10                       ', &
!!      '                                       ']
!!     close(unit=10)
!!
!!     ! read file as a table
!!     call read_table('inputfile',array,ierr)
!!
!!     ! print values
!!     write(*,*)'size=       ',size(array)
!!     write(*,*)'size(dim=1)=',size(array,dim=1)
!!     write(*,*)'size=(dim=2)',size(array,dim=2)
!!     do i=1,size(array,dim=1)
!!        write(*,*)array(i,:)
!!     enddo
!!
!!     ! remove sample file
!!     open(file='inputfile',unit=10)
!!     close(unit=10,status='delete')
!!
!!     end program demo_read_table
!!
!!   Results:
!!
!!     size=                 45
!!     size(dim=1)=          15
!!     size=(dim=2)           3
!!       1.000000000000000      5.000000000000000      3.000000000000000
!!       4.000000000000000      2.000000000000000      6.000000000000000
!!       1.000000000000000      300.0000000000000      4.000000000000000
!!       2.000000000000000     -5.000000000000000      2.200000000000000
!!       1.000000000000000      5.000000000000000      3.000000000000000
!!       4.000000000000000      2.000000000000000      6.000000000000000
!!       1.000000000000000      10.00000000000000      45.00000000000000
!!       10.00000000000000      20.00000000000000      45.00000000000000
!!       2.000000000000000      20.00000000000000      15.00000000000000
!!       20.34499999999999      20.00000000000000      15.00000000000000
!!       30.00000000000000      30000.00000000000      0.000000000000000
!!       4.000000000000000      30.04440000000000     -10.00000000000000
!!       40.00000000000000      30.55549999999999     -10.00000000000000
!!       4.000000000000000      30.04440000000000     -10.00000000000000
!!       40.00000000000000      30.55549999999999     -10.00000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine read_table_d(filename,darray,ierr,comment)
! note the array is allocated as text, and then doubleprecision, and then placed in the output array.
! for large files it would be worth it to just determine the file size and allocate and fill the output
! array

character(len=*),intent(in)             :: FILENAME
doubleprecision,allocatable,intent(out) :: darray(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
character(len=:),allocatable :: page(:) ! array to hold file in memory
integer                      :: irows,irowsmax
integer                      :: icols
integer                      :: i
doubleprecision,allocatable  :: dline(:)
   ierr=0
   ! allocate character array and copy file into it
   call fileread(FILENAME,page)
   if(.not.allocated(page))then
      write(*,*)'*demo_read_table* failed to load file '//FILENAME
      if(allocated(darray))deallocate(darray)
      allocate(darray(0,0))
      ierr=-1
   else
      call cleanse()
      if(allocated(darray))deallocate(darray)
      if(size(page,dim=1) == 0)then
         allocate(darray(0,0))
      else
         irowsmax=size(page,dim=1)
         icols=size(s2vs(page(1)))
         allocate(darray(irowsmax,icols))
         darray=0.0d0
         irows=0
         do i=1,irowsmax
            dline=s2vs(page(i))
            irows=irows+1
            if(size(dline) /= icols)then
               write(*,gen)page(i),'does not contain',icols,'values'
               ierr=ierr+1
               darray(irows,:min(size(dline),icols))=dline(min(size(dline),icols))
            else
               darray(irows,:)=dline
            endif
         enddo
         if(irows /= irowsmax)then
            darray=darray(:irows,:icols)
         endif
         deallocate(page)  ! release memory
      endif
   endif
contains
    subroutine cleanse()
    integer :: i,j,k
    integer :: ios
    integer :: ikeep
    character(len=:),allocatable :: words(:), line
    doubleprecision :: value
    ikeep=0
    do i=1,size(page,dim=1)
       ! do this more rigourously
       ! [+-]NNNNNN[.NNNN][ED][+-]NN
       line=''
       ! get rid of all characters not in a number and
       ! then split the remaining line and keep only
       ! tokens that can be read as a number
       do j=1,len(page)
          if(present(comment))then
             if(page(i)(j:j) == comment)then
                page(i)(j:)=' '
                exit
             endif
          endif
          select case(page(i)(j:j))
          case('e','E','d','D','+','-','.','0':'9')
          case default
             page(i)(j:j)=' '
          end select
       enddo
       call split(page(i),words)
       do k=1,size(words)
          read(words(k),*,iostat=ios)value
          if(ios == 0)then
             line=line//crop(words(k))//' '
          endif
       enddo
       if(line /= '')then
          ikeep=ikeep+1
          page(ikeep)(:)=line
       endif
    enddo
    page=page(:ikeep)
    end subroutine cleanse
end subroutine read_table_d
!===================================================================================================================================
subroutine read_table_i(filename,array,ierr,comment)
implicit none
character(len=*),intent(in)             :: FILENAME
integer,allocatable,intent(out)         :: array(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
doubleprecision,allocatable             :: darray(:,:)
call read_table_d(filename,darray,ierr,comment)
array=nint(darray)
end subroutine read_table_i
!===================================================================================================================================
subroutine read_table_r(filename,array,ierr,comment)
implicit none
character(len=*),intent(in)             :: FILENAME
real,allocatable,intent(out)            :: array(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
doubleprecision,allocatable             :: darray(:,:)
call read_table_d(filename,darray,ierr,comment)
array=real(darray)
end subroutine read_table_r
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileread(3f) - [M_io:READ] read a file into a string array
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine fileread(filename,pageout)
!!
!!    character(len=*),intent(in) :: filename
!!      or
!!    integer,intent(in)          :: io
!!
!!    character(len=:),allocatable,intent(out) :: pageout(:)
!!##DESCRIPTION
!!    Read an entire file into memory as a character array, one character
!!    variable per line.
!!
!!    NOTE:
!!
!!    Do not casually read an entire file into memory if you can process it
!!    per line or in smaller units; as large files can consume unreasonable
!!    amounts of memory.
!!
!!##OPTIONS
!!    filename   filename to read into memory, or LUN (Fortran Logical
!!               Unit Number).  If filename is a LUN, file must be opened
!!               with
!!
!!                  form='unformatted',access='stream'
!!
!!               as in
!!
!!                 open(unit=igetunit, file=filename,     &
!!                 & action="read", iomsg=message,        &
!!                 & form="unformatted", access="stream", &
!!                 & status='old',iostat=ios)
!!
!!    pageout    array of characters to hold file
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_fileread
!!    use M_io,      only : fileread
!!    implicit none
!!    character(len=4096)          :: FILENAME   ! file to read
!!    character(len=:),allocatable :: pageout(:) ! array to hold file in memory
!!    integer                      :: longest, lines, i
!!    character(len=*),parameter   :: gen='(*(g0,1x))'
!!       ! get a filename
!!       call get_command_argument(1, FILENAME)
!!       ! allocate character array and copy file into it
!!       call fileread(FILENAME,pageout)
!!       if(.not.allocated(pageout))then
!!          write(*,gen)'*demo_fileread* failed to load file',FILENAME
!!       else
!!          ! write file from last line to first line
!!          longest=len(pageout)
!!          lines=size(pageout)
!!          write(*,gen)'number of lines is',lines
!!          write(*,gen)'and length of lines is',longest
!!          write(*,'(a)')repeat('%',longest+2)
!!          write(*,'("%",a,"%")')(trim(pageout(i)),i=lines,1,-1)
!!          write(*,'(a)')repeat('%',longest+2)
!!          deallocate(pageout)  ! release memory
!!       endif
!!    end program demo_fileread
!!
!!   Given
!!
!!    first line
!!    second line
!!    third line
!!
!!   Expected output
!!
!!    >  number of lines is 3
!!    >  and length of lines is 11
!!    > %%%%%%%%%%%%%
!!    > %third line %
!!    > %second line%
!!    > %first line %
!!    > %%%%%%%%%%%%%
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine fileread(FILENAME,pageout)
implicit none
class(*),intent(in)                      :: FILENAME   ! file to read
character(len=:),allocatable,intent(out) :: pageout(:) ! page to hold file in memory
character(len=1),allocatable             :: text(:)    ! array to hold file in memory

   call filebyte(FILENAME,text) ! allocate character array and copy file into it

   if(.not.allocated(text))then
      select type(FILENAME)
       type is (character(len=*)); write(*,*)'*fileread* failed to load file '//FILENAME
       type is (integer);          write(*,'(a,i0)')'*fileread* failed to load file unit ',FILENAME
      end select
   else  ! convert array of characters to array of lines
      pageout=page(text)
      deallocate(text)     ! release memory
   endif

contains
function page(array)  result (table)

! ident_5="@(#) page(3fp) function to copy char array to page of text"

character(len=1),intent(in)  :: array(:)
character(len=:),allocatable :: table(:)
integer                      :: i
integer                      :: linelength
integer                      :: length
integer                      :: lines
integer                      :: linecount
integer                      :: position
integer                      :: sz
!!character(len=1),parameter   :: nl=new_line('A')
character(len=1),parameter   :: nl = char(10)
character(len=1),parameter   :: cr = char(13)
   lines = 0
   linelength = 0
   length = 0
   sz=size(array)
   do i = 1,sz
      if( array(i) == nl )then
         linelength = max(linelength,length)
         lines = lines + 1
         length = 0
      else
         length = length + 1
      endif
   enddo
   if( sz > 0 )then
      if( array(sz) /= nl )then
         lines = lines+1
      endif
   endif

   if(allocated(table))deallocate(table)
   allocate(character(len=linelength) :: table(lines))
   table(:) = ' '

   linecount = 1
   position = 1
   do i = 1,sz
      if( array(i) == nl )then
         linecount=linecount+1
         position=1
      elseif( array(i) == cr )then
      elseif( linelength /= 0 )then
         table(linecount)(position:position) = array(i)
         position = position+1
      endif
   enddo
end function page
end subroutine fileread
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filebyte(3f) - [M_io:READ] read a file into a character array
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine filebyte(filename,text,length.lines)
!!
!!    character(len=*),intent(in) :: filename
!!     or
!!    integer,intent(in)          :: filenumber
!!
!!    character(len=1),allocatable,intent(out) :: text(:)
!!    integer,intent(out),optional :: length
!!    integer,intent(out),optional :: lines
!!##DESCRIPTION
!!    Read an entire file as a stream into memory as an array of single
!!    characters, retaining line end terminators.
!!
!!    NOTE:
!!
!!    Never casually read an entire file into memory if you can process it
!!    per line or in smaller units; as large files can consume unreasonable
!!    amounts of memory.
!!
!!##OPTIONS
!!       filename   filename to read into memory or LUN (Fortran Logical
!!                  Unit Number) If a LUN, file must be opened with
!!
!!                     form='unformatted',access='stream'
!!
!!                  as in
!!
!!                    open(unit=igetunit, file=filename,     &
!!                    & action="read", iomsg=message,        &
!!                    & form="unformatted", access="stream", &
!!                    & status='old',iostat=ios)
!!
!!       text       array of characters to hold file
!!       length     returns length of longest line read(Optional).
!!       lines      returns number of lines read(Optional).
!!
!!##EXAMPLES
!!
!!    Sample program, which  creates test input file "inputfile":
!!
!!     program demo_filebyte
!!     use M_io, only      : filebyte
!!     implicit none
!!     character(len=1),allocatable :: text(:) ! array to hold file in memory
!!     character(len=*),parameter :: FILENAME='inputfile' ! file to read
!!
!!     ! create test file
!!     open(file=FILENAME,unit=10,action='write')
!!     write(10,'(a)') new_line('A')//'esrever lliw'
!!     write(10,'(a)') 'margorp elpmas eht taht'
!!     write(10,'(a)') 'elif elpmas a si sihT'
!!     close(unit=10)
!!
!!     call filebyte(FILENAME,text) ! allocate character array and copy file into it
!!
!!     if(.not.allocated(text))then
!!        write(*,*)'*rever* failed to load file '//FILENAME
!!     else
!!        ! write file reversed to stdout
!!        write(*,'(*(a:))',advance='no')text(size(text):1:-1)
!!        deallocate(text)  ! release memory
!!     endif
!!
!!     end program demo_filebyte
!!
!!    Expected output:
!!
!!     >This is a sample file
!!     >that the sample program
!!     >will reverse
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine filebyte(filename,text,length,lines)
implicit none

! ident_6="@(#) M_io filebyte(3f) allocate text array and read file filename into it"

class(*),intent(in)                      :: filename    ! filename to shlep
character(len=1),allocatable,intent(out) :: text(:)     ! array to hold file
integer,intent(out),optional             :: length      ! length of longest line
integer,intent(out),optional             :: lines       ! number of lines
integer :: nchars=0             ! holds size of file
integer :: igetunit             ! use newunit=igetunit in f08
integer :: ios=0                ! used for I/O error status
integer :: length_local
integer :: lines_local
integer :: i
integer :: icount
character(len=256)  :: message
character(len=4096) :: label
character(len=:),allocatable :: line
   length_local=0
   lines_local=0
   message=''
   select type(FILENAME)
    type is (character(len=*))
       if(filename /= '-') then
          open(newunit=igetunit, file=trim(filename), action="read", iomsg=message,&
           &form="unformatted", access="stream",status='old',iostat=ios)
          label=filename
       else ! copy stdin to a scratch file
          call copystdin()
       endif
    type is (integer)
       if(filename /= stdin) then
          rewind(unit=filename,iostat=ios,iomsg=message)
          igetunit=filename
       else ! copy stdin to a scratch file
          call copystdin()
       endif
       write(label,'("unit ",i0)')filename
   end select
   if(ios == 0)then  ! if file was successfully opened
      inquire(unit=igetunit, size=nchars)
      if(nchars <= 0)then
         call stderr_local( '*filebyte* empty file '//trim(label) )
         return
      endif
      ! read file into text array
      if(allocated(text))deallocate(text) ! make sure text array not allocated
      allocate ( text(nchars) )           ! make enough storage to hold file
      read(igetunit,iostat=ios,iomsg=message) text      ! load input file -> text array
      if(ios /= 0)then
         call stderr_local( '*filebyte* bad read of '//trim(label)//':'//trim(message) )
      endif
   else
      call stderr_local('*filebyte* '//message)
      allocate ( text(0) )           ! make enough storage to hold file
   endif

   close(iostat=ios,unit=igetunit)            ! close if opened successfully or not

   if(present(lines).or.present(length))then  ! get length of longest line and number of lines
      icount=0
      do i=1,nchars
         if(text(i) == NEW_LINE('A'))then
            lines_local=lines_local+1
            length_local=max(length_local,icount)
            icount=0
         endif
         icount=icount+1
      enddo
      if(nchars /= 0)then
         if(text(nchars) /= NEW_LINE('A'))then
            lines_local=lines_local+1
            length_local=max(length_local,icount)
         endif
      endif
      if(present(lines))lines=lines_local
      if(present(length))length=length_local
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine copystdin()
integer :: iostat
   open(newunit=igetunit, iomsg=message,&
   &form="unformatted", access="stream",status='scratch',iostat=iostat)
   open(unit=stdin,pad='yes')
   INFINITE: do while (getline(line,iostat=iostat)==0)
      write(igetunit)line//new_line('a')
   enddo INFINITE
   rewind(igetunit,iostat=iostat,iomsg=message)
end subroutine copystdin
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine stderr_local(message)
character(len=*) :: message
   write(stderr,'(a)')trim(message)    ! write message to standard error
end subroutine stderr_local
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine filebyte
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    number_of_lines(3f) - [M_io:QUERY] read an open sequential file to get
!!                          number of lines
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function number_of_lines(lun) result(nlines)
!!
!!    integer,intent(in)          :: lun
!!    integer                     :: nlines
!!
!!##DESCRIPTION
!!    Rewind an open sequential file and read through it to count the number
!!    of lines. The file is rewound on exit. If it is not readable -1 is returned.
!!
!!##OPTIONS
!!    lun       logical unit number of open sequential file to count lines in.
!!
!!##RETURNS
!!    nlines    number of lines read. If it is not readable -1 is returned.
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_number_of_lines
!!    use M_io,      only : number_of_lines, fileopen
!!    implicit none
!!    integer :: ios
!!    integer :: lun
!!       lun=fileopen('test.txt','r',ios)
!!       if(ios == 0)then
!!          write(*,*) number_of_lines(lun)
!!       else
!!          write(*,*)'ERROR: IOS=',ios
!!       endif
!!    end program demo_number_of_lines
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function number_of_lines(lun) result(nlines)
!@(#) determine number or lines in file given a LUN to the open file
integer,intent(in) :: lun

integer            :: ios
integer            :: nlines
character(len=256) :: iomsg

   if(lun /= stdin)rewind(lun,iostat=ios,iomsg=iomsg)
   nlines = 0

   do
   read(lun, '(A)', end=99, iostat=ios,iomsg=iomsg)
      if (ios /= 0) then
         write(stderr,gen)'*number_of_lines*:',trim(iomsg)
         nlines=-1
         exit
      endif
      nlines = nlines + 1
   enddo

99 continue

   if(lun /= stdin)rewind(lun,iostat=ios,iomsg=iomsg)

end function number_of_lines
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notopen(3f) - [M_io:QUERY] Find a FUN/LUN (Fortran-unit-number) that is not in use
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    Usage
!!
!!       integer function notopen(start,end,err)
!!       integer,optional,intent(in)  :: start
!!       integer,optional,intent(in)  :: end
!!       integer,optional,intent(out) :: err
!!##DESCRIPTION
!!    A free FORTRAN unit number is needed to OPEN a file. NOTOPEN() returns
!!    a FORTRAN unit number from START to END not currently associated with
!!    an I/O unit. START and END are expected to be positive integers where
!!    END  >=  START.
!!
!!    If NOTOPEN() returns -1, then no free FORTRAN unit could be found in
!!    the specified range.
!!
!!    Otherwise, NOTOPEN() returns an integer representing a free FORTRAN
!!    logical unit number. Note that NOTOPEN() assumes the following unit
!!    numbers defined by the Fortran 2008 ISO_FORTRAN_ENV module
!!
!!       ERROR_UNIT,INPUT_UNIT,OUTPUT_UNIT
!!
!!    are special, and will never return those values.
!!
!!##OPTIONS
!!       start  optional logical unit number to start scan at, defaults to 10.
!!       end    optional logical unit number to stop scan at, defaults to 99.
!!       err    optional error flag returned. ERR will be non-zero if
!!              no errors. If not present and an error occurs the program
!!              will stop instead of returning.
!!
!!##NOTES
!!
!!    Why are the default START and END limits from 10 to 99? the Fortran 77
!!    standard did not specify a specific limit on the upper range limit, but
!!    the LUN range of 1 to 99 was almost always supported in conventional
!!    programming environments. Additionally, units in the range 0-10 have
!!    often been the units used for pre-assigned files. Occasionally 100,
!!    101 and 102 are reserved (for files such as standard input, standard
!!    output, standard error, ...). Therefore, the defaults for START and
!!    END were selected to be 10 and 99. And most programs do not need
!!    more than 90 files simultaneously open, so the defaults work well in
!!    practice with many versions/vintages of Fortran.
!!
!!    Note that an environment may impose a limit on the number of
!!    simultaneously open files (which some compilers work around).
!!
!!    Beginning with f2008, you can probably use OPEN(NEWUNIT=...) instead
!!    of an open unit locator.
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!     program demo_notopen ! test the NOTOPEN(3f) function
!!     use m_io, only: notopen
!!     implicit none
!!     integer :: ii, ierr, igot
!!
!!     write(*,*)'check for preassigned files from unit 0 to unit 1000'
!!     write(*,*)'(5 and 6 always return -1)'
!!
!!     do ii=0,1000
!!        if(notopen(ii,ii,ierr)  /=  ii)then
!!           write(*,*)'INUSE:',ii, notopen(ii,ii,ierr)
!!        endif
!!     enddo
!!
!!     ! open all files from UNIT=10 to UNIT=30 so have used units
!!     do ii=10,30,1
!!       open(unit=ii,status="scratch")
!!     enddo
!!     ! close UNIT=25
!!     close(25)
!!
!!     ! find open file in range 10 to 30
!!     write(*,*)'Should get 25 for this ..',notopen(10,30,ierr)
!!
!!     close(18)
!!     do ii=10,32
!!       igot=notopen(ii,ii,ierr)
!!       write(*,*)'For unit ',ii,' I got ',igot,' with ERR=',ierr
!!     enddo
!!
!!     end program demo_notopen
!!
!!    Expected output(can vary with each programming environment):
!!
!!       check for preassigned files from unit 0 to unit 1000
!!       (5 and 6 always return -1)
!!       INUSE:    0    -1
!!       INUSE:    5    -1
!!       INUSE:    6    -1
!!       Should get 25 for this .. 25
!!       For  unit  10  I  got  -1  with  ERR=  -1
!!       For  unit  11  I  got  -1  with  ERR=  -1
!!       For  unit  12  I  got  -1  with  ERR=  -1
!!       For  unit  13  I  got  -1  with  ERR=  -1
!!       For  unit  14  I  got  -1  with  ERR=  -1
!!       For  unit  15  I  got  -1  with  ERR=  -1
!!       For  unit  16  I  got  -1  with  ERR=  -1
!!       For  unit  17  I  got  -1  with  ERR=  -1
!!       For  unit  18  I  got  18  with  ERR=   0
!!       For  unit  19  I  got  -1  with  ERR=  -1
!!       For  unit  20  I  got  -1  with  ERR=  -1
!!       For  unit  21  I  got  -1  with  ERR=  -1
!!       For  unit  22  I  got  -1  with  ERR=  -1
!!       For  unit  23  I  got  -1  with  ERR=  -1
!!       For  unit  24  I  got  -1  with  ERR=  -1
!!       For  unit  25  I  got  25  with  ERR=   0
!!       For  unit  26  I  got  -1  with  ERR=  -1
!!       For  unit  27  I  got  -1  with  ERR=  -1
!!       For  unit  28  I  got  -1  with  ERR=  -1
!!       For  unit  29  I  got  -1  with  ERR=  -1
!!       For  unit  30  I  got  -1  with  ERR=  -1
!!       For  unit  31  I  got  31  with  ERR=   0
!!       For  unit  32  I  got  32  with  ERR=   0
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
integer function notopen(start,end,err)
implicit none

! ident_7="@(#) M_io notopen(3f) find free FORTRAN unit number to OPEN() a file"

integer,optional,intent(in)    :: start                           ! unit number to start looking at
integer,optional,intent(in)    :: end                             ! last unit number to look at
integer,optional,intent(out)   :: err                             ! error flag returned
integer                        :: istart
integer                        :: iend
integer                        :: ierr

integer         :: i10                                            ! counter from start to end
integer         :: ios                                            ! iostatus from INQUIRE
logical         :: lopen                                          ! returned from INQUIRE
logical         :: lexist                                         ! returned from INQUIRE
!-----------------------------------------------------------------------------------------------------------------------------------
   !! IEND=MERGE( END, 99, PRESENT(END)) do not use merge, as TSOURCE must be evaluated before the call
   if(present(start))then; istart=start; else; istart=10; endif
   if(present(end  ))then; iend  =end  ; else; iend  =99; endif
   ierr=0
   notopen=(-1)                                                   ! result if no units are available
!-----------------------------------------------------------------------------------------------------------------------------------
   do i10=istart,iend                                             ! check units over selected range
      select case (i10)                                           ! always skip these predefined units
      case(stderr,stdin,stdout)
          cycle
      end select
      inquire( unit=i10, opened=lopen, exist=lexist, iostat=ios )
      if( ios == 0 )then                                          ! no error on inquire
         if(.not. lopen .and. lexist)then                         ! if unit number not in use, return it
            notopen = i10
            exit                                                  ! only need to find one, so return
         endif
      else
         write(stderr,*)'*notopen*:error on unit ',i10,'=',ios
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   if (notopen  <  0 )then                                       ! no valid unit was found in given range
      ierr=-1
   else                                                           ! valid value being returned
      ierr=0
   endif
   if(present(err))then                                           ! if error flag is present set it
      err=ierr
   elseif(ierr /= 0)then                                          ! if error occurred and error flag not present stop program
      stop 1
   endif
end function notopen
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dirname(3f) - [M_io:PATHNAMES] strip last component from filename
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dirname(FILENAME) result (DIRECTORY)
!!
!!      character(len=*),intent(in)  :: FILENAME
!!      character(len=:),allocatable :: DIRECTORY
!!
!!##DESCRIPTION
!!    Output FILENAME with its last non-slash component and trailing slashes
!!    removed. If FILENAME contains no slash or backslash character, output
!!    '.' (meaning the current directory).
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that FILENAME does not contain trailing spaces.
!!
!!##OPTIONS
!!      FILENAME   pathname to remove the last leaf from
!!
!!##RETURNS
!!      DIRECTORY  directory name for pathname
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dirname
!!    use M_io, only : dirname
!!    implicit none
!!    character(len=:),allocatable :: filename
!!    integer                      :: filename_length
!!    integer                      :: i
!!    ! get pathname from command line arguments
!!    do i = 1 , command_argument_count()
!!       call get_command_argument (i , length=filename_length)
!!       if(allocated(filename))deallocate(filename)
!!       allocate(character(len=filename_length) :: filename)
!!       call get_command_argument (i , value=filename)
!!       write(*,'(a)')dirname(filename)
!!    enddo
!!    end program demo_dirname
!!
!!   Sample program executions:
!!
!!      demo_dirname /usr/bin/          -> "/usr"
!!      demo_dirname dir1/str dir2/str  -> "dir1" followed by "dir2"
!!      demo_dirname stdio.h            -> "."
!!
!!##SEE ALSO
!!    dirname(3c), basename(3c), readlink(3c), realpath(3c)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!! PRODUCT:        CLI library utilities and examples
!! PROGRAM:        dirname(3f)
!! DESCRIPTION:    strip last component from filename
!!##VERSION:        1.0.0
!!##DATE:           2015-06-26
!! AUTHOR:         John S. Urban
!! REPORTING BUGS: http://www.urbanjost.altervista.org/
!! HOME PAGE:      http://www.urbanjost.altervista.org/index.html
function dirname(filename) result (directory)
implicit none

! ident_8="@(#) M_io dirname(3f) strip last component from filename"

character(len=*),intent(in)      :: filename
character(len=:),allocatable     :: directory
integer                          :: iend
character(len=1)                 :: sep
!-----------------------------------------------------------------------------------------------------------------------------------
   sep=separator()
   directory=trim(filename)
   call removetail()                         ! trim trailing slashes even if duplicates
   iend=index(directory,sep,back=.true.)     ! find last slash if any
   if(iend == 0)then                         ! filename is a leaf
      directory='.'                          ! special case
   else
      directory=directory(:iend-1)           ! remove leaf
      call removetail()                      ! trim off trailing slashes in case duplicates
   endif
   directory=trim(directory)                 ! clean up return value
contains
   subroutine removetail()              ! replace trailing slashes with spaces even if duplicates
   integer :: right
   do right=len(directory),1,-1
      if(directory(right:right) == sep.or.directory(right:right) == ' ')then
         directory(right:right)=' '
      else
         exit
      endif
   enddo
   end subroutine removetail

end function dirname
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    basename(3f) - [M_io:PATHNAMES] return last component from filename
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function basename(FILENAME,SUFFIX) result (LEAF)
!!
!!      character(len=:),allocatable :: FILENAME
!!      character(len=*),intent(in),optional :: SUFFIX
!!      character(len=*),intent(in) :: LEAF
!!
!!##DESCRIPTION
!!    Output LEAF of filename with directory paths removed.
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that filename does not contain trailing spaces.
!!
!!##OPTIONS
!!      FILENAME   pathname to extract the last leaf from
!!      SUFFIX     suffix to remove. If not present
!!                 the rightmost ".string" string is removed.
!!                 If present the LEAF is returned with any matching
!!                 suffix removed.
!!
!!##RETURNS
!!      LEAF  returned leaf name
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_basename
!!    use M_io, only : basename
!!    implicit none
!!    character(len=:),allocatable :: fn
!!    integer                      :: filename_length
!!    integer                      :: i
!!    ! get pathname from command line arguments
!!    do i = 1, command_argument_count()
!!       call get_command_argument (i, length=filename_length)
!!       if(allocated(fn))deallocate(fn)
!!       allocate(character(len=filename_length) :: fn)
!!       call get_command_argument (i, value=fn)
!!       ! leaf with any suffix removed
!!       ! leaf with suffix retained
!!       ! with suffix unless it is ".f90"
!!       write(*,'(*(a,1x))') basename(fn), basename(fn,''), basename(fn,'.f90')
!!    enddo
!!    end program demo_basename
!!
!!   Sample program executions:
!!
!!     $demo_basename /usr/bin/
!!     bin bin bin
!!     $demo_basename dir1/fred.x dir2/.y
!!     fred fred.x fred.x
!!     .y .y .y
!!     $demo_basename stdio.h
!!     stdio stdio.h stdio.h
!!     $demo_basename /name.f90
!!     name name.f90 name
!!
!!##SEE ALSO
!!    basename(3c), basename(3c), readlink(3c), realpath(3c)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!! PRODUCT:        CLI library utilities and examples
!! PROGRAM:        basename(3f)
!! DESCRIPTION:    strip last component from filename
!!##VERSION:        1.0.0
!!##DATE:           2015-06-26
!! AUTHOR:         John S. Urban
!! REPORTING BUGS: http://www.urbanjost.altervista.org/
!! HOME PAGE:      http://www.urbanjost.altervista.org/index.html
function basename(filename,suffix) result (leaf)
implicit none

! ident_9="@(#) M_io basename(3f) strip last component from filename"

character(len=*),intent(in)          :: filename
character(len=*),intent(in),optional :: suffix
character(len=:),allocatable         :: leaf
integer                              :: iend
integer                              :: i
integer,parameter                    :: maxlen=4096
character(len=maxlen)                :: name
character(len=maxlen)                :: bname
character(len=maxlen)                :: extension
character(len=1)                 :: sep
   sep=separator()
   iend=len_trim(filename)
   do i=iend,1,-1
      if(filename(i:i) /= sep)exit
      iend=iend-1
   enddo
   call splitpath(filename(:iend),name=name,basename=bname,ext=extension)
   if(present(suffix))then
      leaf=merge(bname,name,suffix == extension)
   else
      leaf=bname
   endif
   if(leaf == '')leaf=name
   leaf=trim(leaf)
end function basename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileopen(3f) - [M_io] A simple open of a sequential file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function fileopen(filename,mode,ios) result(lun)
!!
!!    character(len=*),intent(in)           :: filename
!!    character(len=*),intent(in),optional  :: mode
!!    integer,intent(out),optional          :: ios
!!    integer                               :: lun
!!
!!##DESCRIPTION
!!    fileopen(3f) is a convenience routine that allows you to open a file
!!    for sequential reading and writing as a text file in a form commonly
!!    found in C and interpreted languages such as shells. See the OPEN(3f)
!!    statement for more demanding I/O specifications (asynchronous, direct,
!!    unformatted, ... ). The documentation for the flexible and powerful
!!    OPEN(3f) statement can be a bit overwhelming; this routine cuts it
!!    down to the just the simple basic functions typically available in
!!    a scripting language such as bash, tcsh, sh, ...
!!
!!    Specify the file's name as the string FILENAME with a shell-like prefix
!!    specifying the access mode, or alternatively specify a plain FILENAME
!!    and the kind of access you need to the file with the string MODE.
!!
!!    Three fundamental kinds of access are available: read, write,
!!    and append.
!!
!!##OPTION
!!   FILENAME  The filename to open. If the beginning of the filename is
!!
!!             <   open for read. File must exist
!!             >   open for write. Will overwrite current file
!!             >>  open for append. Will append to current file
!!
!!             If no prefix exists to specify a file access mode, it
!!             will depend on the values of the MODE argument (meaning
!!             the default will be "readwrite").
!!
!!             A blank filename causes a unit number for a scratch file
!!             to be returned.
!!
!!   MODE     [rwa][tb][+]
!!            An alternate way to specify the file access mode is to specify
!!            a MODE value. It should begin with one of the three characters
!!            "r", "w", or "a". It defaults to 'rw'. It is case-insensitive.
!!
!!
!!        READING PREFIX
!!        r,<   Open the file for reading; the operation will fail if the
!!              file does not exist, or if the host system does not permit
!!              you to read it.
!!
!!        WRITING PREFIXES
!!        w,>   Open a file for writing from the beginning of the file.
!!              If the file whose name you specified already existed,
!!              the call fails.
!!
!!        o     Open the file for writing from the beginning of the file:
!!              effectively, this always creates a new file. If the file
!!              whose name you specified already existed, its old contents
!!              are discarded.
!!
!!        a,<<  Initially open the file for appending data (ie. writing
!!              at the end of file).
!!
!!        SUFFIX
!!
!!        b   Append a "b" to any of the three modes above to specify that
!!            you are opening the file as a "binary file" (the default is
!!            to open the file as a sequential formatted text file. This
!!            switch changes to to an unformatted stream).
!!
!!                   open( ... access='stream';form='unformatted')
!!
!!        t   Append a "t" to any of the three modes (rwa) to specify a
!!            formatted stream
!!
!!                   open( ... access='stream';form='formatted')
!!
!!        +   Finally, you might need to both read and write from the same
!!            file. You can specify "rw" or you can append a `+' to any of
!!            the three primary modes ("rwa") to permit "readwrite" access
!!
!!        v   Additionally, "v" selects verbose mode, which prints the
!!            OPEN(3f) options explicitly selected
!!
!!        NOTES
!!
!!            If you want to append both `b' and `+', you can do it in
!!            either order: for example, "rb+" means the same thing as
!!            "r+b" when used as a mode string.)
!!
!!    IOS    The error code returned by the OPEN(3f) statement ultimately
!!           executed by this function. If not present the program stops on
!!           an error.
!!##RETURNS
!!        FILEOPEN(3f) returns a Fortran unit number which you can use
!!        for other file operations, unless the file you requested could
!!        not be opened; in that situation, the result is -1 (a reserved
!!        value that cannot be returned as a NEWUNIT value on an OPEN(3f))
!!        and IOS will be non-zero.
!!
!!##EXAMPLE
!!
!!  Common usage
!!
!!   READ
!!     R=fileopen('<in.txt')
!!     or
!!     R=fileopen('in.txt','r')
!!
!!   WRITE
!!     W=fileopen('>out.txt')
!!     or
!!     W=fileopen('out.txt','W')
!!
!!   READWRITE
!!     RW=fileopen('inout.txt')
!!
!!   APPEND
!!     A=fileopen('>>inout.txt')
!!     or
!!     A=fileopen('inout.txt','a')
!!
!!   Sample program
!!
!!       program demo_fileopen
!!       use M_io, only : fileopen, fileclose, print_inquire
!!       implicit none
!!       integer :: lun
!!       lun=fileopen('fred.txt')
!!       call print_inquire(lun)
!!       end program demo_fileopen
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function fileopen(filename,mode,ios) result(lun)
character(len=*),intent(in)           :: filename
character(len=*),intent(in),optional  :: mode
integer,intent(out),optional          :: ios
integer                               :: lun, i, ios_local,ifound,gts
character(len=:),allocatable          :: local_mode
character(len=256)                    :: message
character(len=:),allocatable          :: action, position, access, form, status, file
logical                               :: verbose
   local_mode=lower(merge_str(mode,'',present(mode)))
   file=trim(adjustl(filename))//'   '
   ifound=index(file,'>>')
   if(ifound /= 0)then
      file(ifound:ifound+1)='  '
      local_mode=local_mode//'a'
   endif
   ifound=index(file,'>')
   if(ifound /= 0)then
      file(ifound:ifound)=' '
      local_mode=local_mode//'w'
   endif
   ifound=index(file,'<')
   if(ifound /= 0)then
      file(ifound:ifound)=' '
      local_mode=local_mode//'r'
   endif
   file=adjustl(file)
   local_mode=merge_str('rw',local_mode,local_mode == '')
   file=trim(file)

   gts=0
   action=''
   position='asis'
   form='formatted'
   access='sequential'
   status='unknown'
   verbose=.false.
   do i=1,len(local_mode) ! create order independence
      select case(local_mode(i:i))
       case('r','<'); if(action /= 'readwrite'.and.action /= 'read')action='read'//action
                      if(status == 'unknown')status='old'
       case('w','>'); if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status=='unknown')status='new'
                      if(gts > 0)then
                         position='append'
                      endif
                      gts=gts+1
       case('o');     if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status=='unknown')then
                         status='replace'
                      endif
       case('a');     position='append'
                      if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status == 'old')status='unknown'
       case('b');     access='stream';form='unformatted'
       case('t');     access='stream';form='formatted'
       case('+');     action='readwrite'
                      status='unknown'
       case('v');     verbose=.true.
       case default
         write(*,'(*(g0))',advance='no')'*fileopen* unknown mode key ',local_mode(i:i)
         write(*,'(*(:,"[",g0,"=",g0,"]"))',advance='no') &
         & ' INPUTNAME=',trim(file), &
         & ' MODE=',trim(local_mode)
      end select
   enddo
   if(action == '')action='readwrite'

   if(verbose)then
      write(*,'(*(:,"[",g0,"=",g0,"]"))',advance='no') &
         & 'INPUTNAME=',trim(file), &
         & 'MODE=',trim(local_mode)
      write(*,'(a)',advance='no')'==>'
      write(*,'(*(:,"[",g0,"=",g0,"]"))') &
         & 'FILE=',trim(file), &
         & 'FORM=',trim(form), &
         & 'ACCESS=',trim(access), &
         & 'ACTION=',trim(action), &
         & 'POSITION=',trim(position), &
         & 'STATUS=',trim(status)
   endif
   if(file /= ' ')then
    open(file=file,newunit=lun,form=form,access=access,action=action,position=position,status=status,iostat=ios_local,iomsg=message)
   else
    open(newunit=lun,form=form,access=access,action=action,status='scratch',iostat=ios_local,iomsg=message)
   endif
   !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
   !  ACTION    =  READ|WRITE  |  READWRITE
   !  FORM      =  FORMATTED   |  UNFORMATTED
   !  POSITION  =  ASIS        |  REWIND       |  APPEND
   !  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
   if(ios_local /= 0)then
      call journal('sc','*fileopen* ',message)
      lun=-1
   endif
   if(present(ios))then        ! caller has asked for status so let caller process any error
      ios=ios_local
   elseif(ios_local /= 0)then  ! caller did not ask for status so stop program on error
      stop 1
   endif
end function fileopen
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileclose(3f) - [M_io] A simple close of a sequential file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     function fileclose(lun) result(ios)
!!
!!      integer,intent(in)       :: lun
!!      integer                  :: ios
!!##DESCRIPTION
!!   A convenience command for closing a file that leaves an
!!   error message in the current journal file if active.
!!##OPTION
!!   LUN unit number to close
!!##RETURNS
!!   IOS status value from CLOSE
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_fileclose
!!     use M_io, only : fileclose, fileopen
!!     implicit none
!!     integer :: lun
!!     integer :: ios, ierr
!!        lun=fileopen('<input.txt',ios=ierr)
!!        if(ierr /= 0)then
!!           write(*,*)'<ERROR> opening file'
!!        endif
!!        ios=fileclose(lun)
!!     end program demo_fileclose
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function fileclose(lun) result(ios)
integer,intent(in)       :: lun
integer                  :: ios
character(len=256)       :: message
   close(unit=lun,iostat=ios,iomsg=message)
   if(ios /= 0)then
      call journal('sc','*fileclose* ',message)
      stop
   endif
end function fileclose
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filewrite(3f) - [M_io:WRITE] A simple write of a CHARACTER array to a file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     function filewrite(filename,data,status,position) result(ierr)
!!
!!      character(len=*),intent(in) :: filename
!!      character(len=*),intent(in) :: data(:)
!!      character(len=*),intent(in),optional :: status
!!      character(len=*),intent(in),optional :: position
!!      integer                     :: ierr
!!##DESCRIPTION
!!   A convenience procedure for writing a CHARACTER array as
!!   a new file.
!!##OPTION
!!   FILENAME   file to create or write. If the name ends
!!              in ">" the default for STATUS changes to
!!              "REPLACE". If it ends in ">>" STATUS changes to
!!              "UNKNOWN" and the default POSITION changes to "APPEND".
!!   DATA       CHARACTER array to write to file
!!   STATUS     STATUS to use on OPEN(7f). Defaults to "NEW".
!!              Allowed values are  NEW|REPLACE|OLD|SCRATCH|UNKNOWN
!!   POSITION   POSITION to use on OPEN(7f). Defaults to "REWIND".
!!              Allowed values are  ASIS|REWIND|APPEND
!!##RETURNS
!!   IERR       status value. Zero indicates no error occurred
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_filewrite
!!     use M_io, only : filewrite
!!     implicit none
!!     integer :: ierr
!!     character(len=:),allocatable :: data(:)
!!        data=[ character(len=80) :: &
!!             &'This is the text to write  ', &
!!             &'into the file. It will be  ', &
!!             &'trimmed on the right side. ', &
!!             &' ', &
!!             &'     That is all Folks!    ', &
!!             &'']
!!        ierr=filewrite('_scratch.txt',data)
!!     end program demo_filewrite
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function filewrite(filename,filedata,status,position) result (ierr)
! write filedata to file filename
character(len=*),intent(in)           :: filename
character(len=*),intent(in)           :: filedata(:)
character(len=*),intent(in),optional  :: status
character(len=*),intent(in),optional  :: position
integer                               :: ierr
integer                               :: lun, i, ios, ilen
character(len=256)                    :: message
character(len=:),allocatable          :: file
character(len=:),allocatable          :: local_status
character(len=:),allocatable          :: local_position
character(len=:),allocatable          :: default_status
character(len=:),allocatable          :: default_position
   ierr=0
   default_status='NEW'
   default_position='REWIND'
   file=trim(adjustl(filename))//'  '
   ilen=max(len_trim(file),2)
   if(file(ilen-1:ilen) == '>>')then
      ilen=ilen-2
      file=file(:ilen)
      default_status='UNKNOWN'
      default_position='APPEND'
   elseif(file(ilen:ilen) == '>')then
      ilen=ilen-1
      file=file(:ilen)
      default_status='REPLACE'
   else
      file=trim(file)
   endif
   if(present(position))then; local_position=position; else; local_position=default_position; endif
   if(present(status))then;   local_status=status;     else; local_status=default_status;     endif
   if(file /= ' ')then
      open(file=file, &
      & newunit=lun, &
      & form='formatted', &         !  FORM      =  FORMATTED   |  UNFORMATTED
      & access='sequential', &      !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
      & action='write', &           !  ACTION    =  READ|WRITE  |  READWRITE
      & position=local_position, &  !  POSITION  =  ASIS        |  REWIND       |  APPEND
      & status=local_status, &      !  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
      & iostat=ios, &
      & iomsg=message)
   else
      lun=stdout
      ios=0
   endif
   if(ios /= 0)then
      write(stderr,'(*(a,1x))')'*filewrite* error:',file,trim(message)
      ierr=ios
   else
      do i=1,size(filedata)                                                    ! write file
         write(lun,'(a)',iostat=ios,iomsg=message)trim(filedata(i))
         if(ios /= 0)then
            write(stderr,'(*(a,1x))')'*filewrite* error:',file,trim(message)
            ierr=ios
            exit
         endif
      enddo
   endif
   close(unit=lun,iostat=ios,iomsg=message)                                 ! close file
   if(ios /= 0)then
      write(stderr,'(*(a,1x))')'*filewrite* error:',trim(message)
      ierr=ios
   endif
end function filewrite
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filedelete(3f) - [M_io] A simple close of an open file with STATUS='DELETE'
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function filedelete(lun) result(ios)
!!
!!     integer,intent(in)          :: lun
!!       or
!!     character(len=*),intent(in) :: filename
!!     integer                     :: ios
!!
!!##DESCRIPTION
!!   A convenience command for deleting an OPEN(3f) file that leaves an
!!   error message in the current journal file if active
!!##OPTION
!!   LUN  unit number of open file to delete or filename.
!!##RETURNS
!!   IOS  status returned by CLOSE().
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_filedelete
!!     use M_io, only : filedelete, fileopen
!!     implicit none
!!     integer :: lun
!!     integer :: ios
!!        lun=fileopen('<input.txt')
!!        ios=filedelete(lun)
!!     end program demo_filedelete
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function filedelete_lun(lun) result(iostat)
integer,intent(in)    :: lun
integer               :: iostat
character(len=256)    :: message
   close(unit=lun,iostat=iostat,status='delete',iomsg=message)
   if(iostat /= 0)then
      call journal('sc','*filedelete* ',message)
   endif
end function filedelete_lun
function filedelete_filename(filename) result(iostat)
character(len=*),intent(in) :: filename
integer                     :: number
integer                     :: iostat
character(len=256)          :: message
logical                     :: opened
logical                     :: exist
   inquire(file=filename,opened=opened,iostat=iostat,exist=exist,number=number)
   if(exist)then
      if(.not.opened)then
         open(newunit=number,iostat=iostat,file=filename)
      endif
      close(unit=number,iostat=iostat,status='delete',iomsg=message)
      if(iostat /= 0)then
         call journal('sc','*filedelete* ',message)
      endif
   endif
end function filedelete_filename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    joinpath(3f) - [M_io:PATHNAMES] join parts of a pathname together
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function joinpath(a1,a2,a3,a4,a5,a6,a7,a8,a9)  result(path)
!!
!!     character(len=*), intent(in)           :: a1, a2
!!     character(len=*), intent(in), optional :: a3, a4, a5, a6, a7, a8, a9
!!     character(len=:), allocatable          :: path
!!##DESCRIPTION
!!##OPTIONS
!!     a1,a2  the first two pathname sections to join. Required
!!     a3-a9  additional optional sections to join
!!##RETURNS
!!     pathname sections joined together with trailing spaces removed from
!!     the ends of sections and a separator (as returned by separator(3f)
!!     ) placed between them, and duplicate adjacent separators removed
!!     accept for one beginning the joined pathname.
!!##EXAMPLE
!!
!!   Sample program
!!
!!      program demo_joinpath
!!      use M_io, only : joinpath
!!      implicit none
!!         write(*,*)joinpath(&
!!         &'/share/user','/man/','man3','joinpath.3m_io'//'.gz' &
!!         &)
!!      end program demo_joinpath
!!
!! Results:
!!
!!      >  /share/user/man/man3/joinpath.3m_io.gz
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function joinpath(a1,a2,a3,a4,a5,a6,a7,a8,a9) result(path)
   ! Construct path by joining strings with os file separator
   !
   character(len=*), intent(in)           :: a1, a2
   character(len=*), intent(in), optional :: a3, a4, a5, a6, a7, a8, a9
   character(len=:), allocatable          :: path
   character(len=1)                       :: filesep

   filesep = separator()
   if(a1 /= '')then
      path = trim(a1) // filesep // trim(a2)
   else
      path = trim(a2)
   endif
   if (present(a3)) path = path // filesep // trim(a3)
   if (present(a4)) path = path // filesep // trim(a4)
   if (present(a5)) path = path // filesep // trim(a5)
   if (present(a6)) path = path // filesep // trim(a6)
   if (present(a7)) path = path // filesep // trim(a7)
   if (present(a8)) path = path // filesep // trim(a8)
   if (present(a9)) path = path // filesep // trim(a9)
   path=adjustl(path//'  ')
   call substitute(path,filesep//filesep,filesep,start=2) ! some systems allow names starting with '//' or '\\'
   path=trim(path)
end function joinpath
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     splitpath(3f) - [M_io:PATHNAMES] split a Unix pathname into components
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine splitpath(path,dir,name,basename,ext)
!!
!!    integer,parameter :: maxlen=4096
!!    character(len=maxlen),intent(in)  :: path
!!    character(len=maxlen),intent(out),optional :: dir
!!    character(len=maxlen),intent(out),optional :: name
!!    character(len=maxlen),intent(out),optional :: basename
!!    character(len=maxlen),intent(out),optional :: ext
!!
!!##DESCRIPTION
!!    splitpath(3f) splits given pathname assuming a forward slash separates
!!    filename components and that the right-most period in the last leaf
!!    of the pathname is considered the beginning of an extension. If
!!    an extension is found it is left present in NAME but removed from
!!    BASENAME.
!!
!!    This routine does not check the system for the existence or type of
!!    the filename components; it merely parses a string.
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that filename does not contain trailing spaces.
!!
!!##OPTIONS
!!    path      Path to be broken into components. It is assumed
!!
!!              o Forward slashes (/) separate pathname components.
!!              o the name '.' means "current directory"
!!              o the name '..' means "up one directory"
!!              o a pathname ending in a slash is a directory name
!!              o a slash starting the pathname represents the root
!!                directory.
!!              o trailing spaces are insignificant.
!!
!!    Using these rules helps to reduce incorrect parsing, but the
!!    routine is only intended for simple parsing of names of the form
!!    "[dir/]name[.extension].
!!
!!##RESULTS
!!    dir       Path of directories, including the trailing slash.
!!    name      Name of file leaf or, if no file is specified in path,
!!              name of the lowest directory.
!!    basename  NAME with any extension removed
!!    ext       File name extension, if any, including the leading period (.).
!!
!!    The path parameter can be a complete or partial file specification. The
!!    special name "." is assumed to mean the current directory, and the
!!    special name ".." is assumed to mean one directory above the current
!!    directory.
!!
!!##EXAMPLE
!!
!!   program demo_splitpath
!!
!!    use m_io, only : splitpath
!!    implicit none
!!    integer,parameter :: maxlen=4096
!!    character(len=maxlen),parameter   :: file(*)=[&
!!       & 'dirs/name.ext  ', &
!!       & 'xx/IO/zz/NN.FF ', &
!!       & 'xx/IO/zz/NN    ', &
!!       & '/xx/IO/zz/NN   ', &
!!       & '/xx/IO/zz/     ', &
!!       & '/xx/IO/zz.A/   ', &
!!       & '/xx/IO/zz/.    ', &
!!       & '               ', &
!!       & './             ', &
!!       & '/              ', &
!!       & '/..            ', &
!!       & './..           ', &
!!       & 'name.          ', &
!!       & '.name          ', &
!!       & '.name.         ', &
!!       & '.              ', &
!!       & '..             ', &
!!       & '...            ']
!!
!!    character(len=maxlen)  :: dir
!!    character(len=maxlen)  :: name
!!    character(len=maxlen)  :: basename
!!    character(len=maxlen)  :: ext
!!    integer                :: i
!!    integer                :: longest
!!    longest=maxval(len_trim(file)) ! find longest filename
!!
!!    do i=1,size(file)
!!       call splitpath(file(i), dir, name, basename, ext)
!!       write(*,'(*("| ",a:))')  &
!!       & file(i)(:longest),     &
!!       & dir(:longest),         &
!!       & name(:longest),        &
!!       & basename(:longest),    &
!!       & ext(:longest)
!!    enddo
!!   end program demo_splitpath
!!
!!   Output
!!
!!    | dirs/name.ext | dirs          | name.ext      | name          | .ext
!!    | xx/IO/zz/NN.FF| xx/IO/zz      | NN.FF         | NN            | .FF
!!    | xx/IO/zz/NN   | xx/IO/zz      | NN            | NN            |
!!    | /xx/IO/zz/NN  | /xx/IO/zz     | NN            | NN            |
!!    | /xx/IO/zz/    | /xx/IO/zz     |               |               |
!!    | /xx/IO/zz.A/  | /xx/IO/zz.A   |               |               |
!!    | /xx/IO/zz/.   | /xx/IO/zz/.   |               |               |
!!    |               | .             |               |               |
!!    | ./            | .             |               |               |
!!    | /             | /             |               |               |
!!    | /..           | /             |               |               |
!!    | ./..          | ./..          |               |               |
!!    | name.         |               | name.         | name          | .
!!    | .name         |               | .name         | .name         |
!!    | .name.        |               | .name.        | .name         | .
!!    | .             | .             |               |               |
!!    | ..            |               |               |               |
!!    | ...           |               | ...           | ..            | .
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine splitpath(path,dir,name,basename,ext)
implicit none

! ident_10="@(#) M_io splitpath(3f) split Unix pathname into components (dir name basename extension)"

!===================================================================================================================================
character(len=*),intent(in)           :: path
character(len=*),intent(out),optional :: dir
character(len=*),intent(out),optional :: name
character(len=*),intent(out),optional :: basename
character(len=*),intent(out),optional :: ext
integer,parameter                     :: maxlen=4096
character(len=maxlen)                 :: dir_local
character(len=maxlen)                 :: name_local
character(len=maxlen)                 :: basename_local
character(len=maxlen)                 :: ext_local
character(len=len(path)+1)            :: path_local
integer                               :: where
integer                               :: i
integer                               :: iend
character(len=1)                 :: sep
   sep=separator()
!===================================================================================================================================
   path_local=path                           ! initialize variables
   dir_local=''
   name_local=''
   basename_local=''
   ext_local=''
   iend=len_trim(path_local)
   LOCAL : block
!===================================================================================================================================
   if(iend == 0)then                         ! blank input path
      dir_local='.'
      exit LOCAL
   endif
!===================================================================================================================================
   if(path_local(iend:iend) == sep)then      ! assume entire name is a directory if it ends in a slash
      if(iend > 1)then
         dir_local=path_local(:iend-1)
      else                                   ! if just a slash it means root directory so leave it as slash
         dir_local=path_local
      endif
      exit LOCAL
   endif
!===================================================================================================================================
   TRIMSLASHES: do i=iend,1,-1               ! trim off trailing slashes even if duplicates
      if(path_local(i:i) == sep)then
         path_local(i:i)=' '
         iend=i-1
      else
         iend=i
         exit TRIMSLASHES
      endif
   enddo TRIMSLASHES

   if(iend == 0)then                         ! path composed entirely of slashes.
      dir_local=sep
      exit LOCAL
   endif
!===================================================================================================================================
   where=INDEX(path_local,sep,BACK=.true.)   ! find any right-most slash in remaining non-null name_local after trimming trailing slashes
   if(where <= 0)then                        ! no slash in path so everything left is name_local
      name_local=path_local(:iend)                 ! this is name_local unless '.' or '..'
   else                                      ! last slash found
      dir_local=path_local(:where-1)               ! split into directory
      name_local=path_local(where+1:iend)          ! this is name_local unless '.' or '..'
   endif
!===================================================================================================================================
   select case (name_local(1:3))                   ! special cases where name_local is a relative directory name_local '.' or '..'
   case('.  ')
      dir_local=path_local
      name_local=''
   case('.. ')
      if(dir_local == '')then
         if(path_local(1:1) == sep)then
            dir_local=sep
         endif
      else
         dir_local=path_local
      endif
      name_local=''
   case default
   end select
!===================================================================================================================================
   if(name_local == '.')then
      name_local=''
   endif
!===================================================================================================================================
   iend=len_trim(name_local)
   where=INDEX(name_local,'.',BACK=.true.)         ! find any extension
   if(where > 0.and.where /= 1)then         ! only consider a non-blank extension name_local
      ext_local=name_local(where:)
      basename_local=name_local(:where-1)
   else
      basename_local=name_local
   endif
!===================================================================================================================================
   endblock LOCAL
   if(present(dir))dir=dir_local
   if(present(name))name=name_local
   if(present(basename))basename=basename_local
   if(present(ext))ext=ext_local
end subroutine splitpath
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getline(3f) - [M_io:READ] read a line from specified LUN into allocatable
!!                  string up to line length limit
!!    (LICENSE:PD)
!!
!!##SYNTAX
!!   function getline(line,lun,iostat) result(ier)
!!
!!    character(len=:),allocatable,intent(out) :: line
!!    integer,intent(in),optional              :: lun
!!    integer,intent(out),optional             :: iostat
!!    integer                                  :: ier
!!
!!##DESCRIPTION
!!    Read a line of any length up to programming environment maximum
!!    line length. Requires Fortran 2003+.
!!
!!    It is primarily expected to be used when reading input which will
!!    then be parsed.
!!
!!    The input file must have a PAD attribute of YES for the function
!!    to work properly, which is typically true.
!!
!!    The simple use of a loop that repeatedly re-allocates a character
!!    variable in addition to reading the input file one buffer at a
!!    time could (depending on the programming environment used) be
!!    inefficient, as it could reallocate and allocate memory used for
!!    the output string with each buffer read.
!!
!!##OPTIONS
!!    LINE    line read
!!    LUN     optional LUN (Fortran logical I/O unit) number. Defaults
!!            to stdin.
!!    IOSTAT  status returned by READ(IOSTAT=IOS). If not zero, an error
!!            occurred or an end-of-file or end-of-record was encountered.
!!            This is the same value as returned by the function. See the
!!            example program for a usage case.
!!##RETURNS
!!    IER     zero unless an error occurred. If not zero, LINE returns the
!!            I/O error message.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_getline
!!    use,intrinsic :: iso_fortran_env, only : stdin=>input_unit
!!    use,intrinsic :: iso_fortran_env, only : iostat_end
!!    use M_io, only : getline
!!    implicit none
!!    integer :: iostat
!!    character(len=:),allocatable :: line
!!       open(unit=stdin,pad='yes')
!!       INFINITE: do while (getline(line,iostat=iostat)==0)
!!          write(*,'(a)')'['//line//']'
!!       enddo INFINITE
!!       if(iostat /= iostat_end)then
!!          write(*,*)'error reading input:',trim(line)
!!       endif
!!    end program demo_getline
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function getline(line,lun,iostat) result(ier)
implicit none

! ident_11="@(#) M_io getline(3f) read a line from specified LUN into allocatable string up to line length limit"

character(len=:),allocatable,intent(out) :: line
integer,intent(in),optional              :: lun
integer,intent(out),optional             :: iostat
integer                                  :: ier
character(len=4096)                      :: message

integer,parameter                        :: buflen=1024
character(len=:),allocatable             :: line_local
character(len=buflen)                    :: buffer
integer                                  :: isize
integer                                  :: lun_local

   line_local=''
   ier=0
   if(present(lun))then
      lun_local=lun
   else
      lun_local=stdin
   endif

   INFINITE: do                                                   ! read characters from line and append to result
      read(lun_local,pad='yes',iostat=ier,fmt='(a)',advance='no', &
      & size=isize,iomsg=message) buffer                          ! read next buffer (might use stream I/O for files
                                                                  ! other than stdin so system line limit is not limiting
      if(isize > 0)line_local=line_local//buffer(:isize)          ! append what was read to result
      if(is_iostat_eor(ier))then                                  ! if hit EOR reading is complete unless backslash ends the line
         ier=0                                                    ! hitting end of record is not an error for this routine
         exit INFINITE                                            ! end of reading line
     elseif(ier /= 0)then                                         ! end of file or error
        line=trim(message)
        exit INFINITE
     endif
   enddo INFINITE
   line=line_local                                                ! trim line
   if(present(iostat))iostat=ier
end function getline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     read_line(3f) - [M_io:READ] read a line from specified LUN into allocatable
!!                     string up to line length limit cleaning up input line
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function read_line(line,lun,ios) result(ier)
!!
!!    character(len=:),allocatable,intent(out) :: line
!!    integer,intent(in),optional              :: lun
!!    integer,optional                         :: ios
!!    integer                                  :: ier
!!
!!##DESCRIPTION
!!
!!    Read a line of any length up to the programming environment maximum
!!    line length. Requires Fortran 2003+.
!!
!!    It is primarily expected to be used when reading input which will
!!    then be parsed.
!!
!!    The input file must have a PAD attribute of YES for the function to
!!    work properly, which is typically true but can be set on an open file.
!!
!!    o Append lines that end in a backslash with next line
!!    o Expand tabs
!!    o Replace unprintable characters with spaces
!!    o Remove trailing carriage return characters and white space
!!
!!    The simple use of a loop that repeatedly re-allocates a character
!!    variable in addition to reading the input file one buffer at a time
!!    could (depending on the programming environment used) be inefficient,
!!    as it could reallocate and allocate memory used for the output string
!!    with each buffer read.
!!
!!##OPTIONS
!!    LINE   the line read from the file.
!!    LUN    The LUN (logical unit) to read from. Defaults to stdin.
!!    IOS    status returned by READ(IOSTAT=IOS). If not zero, an error
!!           occurred or an end-of-file or end-of-record was encountered.
!!           This is the same value as returned by the function. See the
!!           example program for a usage case.
!!##RETURNS
!!    IER    status returned by READ(IOSTAT=IER). If not zero, an error
!!           occurred or an end-of-file or end-of-record was encountered.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!   Checking the error message and counting lines:
!!
!!     program demo_read_line
!!     use,intrinsic :: iso_fortran_env, only : stdin  => input_unit
!!     use,intrinsic :: iso_fortran_env, only : stderr => error_unit
!!     use,intrinsic :: iso_fortran_env, only : iostat_end, iostat_eor
!!     use M_io, only : read_line
!!     implicit none
!!     character (len =: ), allocatable :: line
!!     integer                          :: stat
!!     integer                          :: icount=0
!!        open(unit=stdin,pad='yes')
!!        INFINITE: do while (read_line(line,ios=stat) == 0)
!!           icount=icount
!!           write (*, '(*(g0))') icount,' [',line,']'
!!        enddo INFINITE
!!        if ( .not.is_iostat_end(stat) ) then
!!           write (stderr, '(*(g0))') &
!!           & 'error: line ',icount,'==>',trim (line)
!!        endif
!!     end program demo_read_line
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function read_line(line,lun,ios) result(ier)
implicit none

! ident_12="@(#) M_io read_line(3f) read a line from specified LUN into allocatable string up to line length limit"

character(len=:),allocatable,intent(out) :: line
integer,intent(in),optional              :: lun
integer,optional                         :: ios
integer                                  :: ier

integer,parameter                        :: buflen=1024
character(len=:),allocatable             :: line_local
character(len=256)                       :: message
integer                                  :: biggest
character(len=buflen)                    :: buffer
integer                                  :: last
integer                                  :: isize
integer                                  :: lun_local

   line_local=''
   ier=0
   lun_local=merge(lun,stdin,present(lun))
   INFINITE: do                                                           ! read characters from line and append to result
      read(lun_local,pad='yes',iostat=ier,fmt='(a)',advance='no',size=isize,iomsg=message) buffer ! read next buffer (might use stream I/O for
                                                                          ! files other than stdin so system line limit
                                                                          ! is not limiting
      if(isize > 0)line_local=line_local//buffer(:isize)   ! append what was read to result
      if(is_iostat_eor(ier))then                            ! if hit EOR reading is complete unless backslash ends the line
         last=len(line_local)
         if(last /= 0)then
            if(line_local(last:last) == '\')then            ! if line ends in backslash it is assumed a continued line
               line_local=line_local(:last-1)               ! remove backslash
               cycle INFINITE                               ! continue on and read next line and append to result
            endif
         endif
         ier=0                                              ! hitting end of record is not an error for this routine
         exit INFINITE                                      ! end of reading line
     elseif(ier /= 0)then                                   ! end of file or error
        line_local=trim(message)
        exit INFINITE
     endif
   enddo INFINITE
   biggest=8*len(line_local)                                ! worst case is raw line is all tab characters
   if(allocated(line))deallocate(line)
   allocate(character(len=biggest) :: line)
   call notabs(line_local,line,last)                        ! expand tabs, trim carriage returns, remove unprintable characters
   line=noesc(line)
   line=trim(line(:last))                                   ! trim line
   if(present(ios))then
      ios=ier
   endif
end function read_line
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      get_tmp(3f) - [M_io:QUERY] Return the name of the scratch directory
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!     function get_tmp() result(tname)
!!
!!      character(len=:),allocatable :: tname
!!##DESCRIPTION
!!
!!    Return the name of the scratch directory set by the most common
!!    environment variables used to designate a scratch directory.
!!    $TMPDIR is the canonical environment variable in Unix and POSIX[1]
!!    to use to specify a temporary directory for scratch space. If $TMPDIR
!!    is not set, $TEMP, $TEMPDIR, and $TMP are examined in that order. If
!!    nothing is set "/tmp/" is returned. The returned value always ends in
!!    "/". No test is made that the directory exists or is writable.
!!
!!##EXAMPLE
!!
!!
!!   Sample:
!!
!!     program demo_get_tmp
!!     use M_io, only : get_tmp, uniq
!!     implicit none
!!     character(len=:),allocatable :: answer
!!        answer=get_tmp()
!!        write(*,*)'result is ',answer
!!        answer=get_tmp()//uniq('_scratch',create=.false.)
!!        write(*,*)'the file ',answer, &
!!        & ' was a good scratch file name, at least a moment ago'
!!     end program demo_get_tmp
!!
!!   Sample Results:
!!
!!     > result is /cygdrive/c/Users/JSU/AppData/Local/Temp/
!!     >
!!     > the file /cygdrive/c/Users/JSU/AppData/Local/Temp/_scratch
!!     > was a good scratch file name, at least a moment ago
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function get_tmp() result(tname)

! ident_13="@(#) M_io get_tmp(3f) Return the name of the scratch directory"

character(len=:),allocatable :: tname
integer                      :: lngth
character(len=10),parameter  :: names(4)=["TMPDIR    ","TEMP      ","TEMPDIR   ","TMP       "]
integer                      :: i
character(len=1)             :: sep
   sep=separator()
   tname=''
   do i=1,size(names)
      call get_environment_variable(name=names(i), length=lngth)
      if(lngth /= 0)then
         if(allocated(tname))deallocate(tname)
         allocate(character(len=lngth) :: tname)
         call get_environment_variable(name=names(i), value=tname)
         exit
      endif
   enddo
   if(lngth == 0)then
      tname='/tmp'
      lngth=len_trim(tname)
   endif
   if(scan(tname(lngth:lngth),'/\') == 0)then
      tname=tname//sep
   endif
end function get_tmp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! rd(3f) - [M_io:READ] ask for string from standard input with user-definable prompt
!! (LICENSE:PD)
!!
!!   function rd(prompt,default) result(out)
!!
!!    character(len=*),intent(in)              :: prompt
!!
!!   One of
!!
!!    character(len=*),intent(in)              :: default
!!    character(len=:),allocatable,intent(out) :: out
!!
!!    integer,intent(in)                       :: default
!!    integer,intent(out)                      :: out
!!
!!    real,intent(in)                          :: default
!!    real,intent(out)                         :: out
!!
!!    doubleprecision,intent(in)               :: default
!!    doubleprecision,intent(out)              :: out
!!
!!    logical,intent(in)                       :: default
!!    logical,intent(out)                      :: out
!!
!!
!!##DESCRIPTION
!!    Ask for string or value from standard input with user-definable prompt
!!    up to 20 times.
!!
!!    Do not use the function in an I/O statement as not all versions of
!!    Fortran support this form of recursion. Numeric values may be input
!!    in standard INTEGER, REAL, and DOUBLEPRECISION formats or as whole
!!    numbers in base 2 to 36 in the format BASE#VALUE.
!!
!!##OPTIONS
!!    prompt    Prompt string; displayed on same line as input is read from
!!    default   default answer on carriage-return. The type of the default
!!              determines the type of the output.
!!##RETURNS
!!    out       returned string or value. If an end-of-file or system error
!!              is encountered the string "EOF" is returned, or a "Nan"
!!              REAL numeric value, or huge(0), or .false. .
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_rd
!!    use M_io, only : rd
!!    implicit none
!!    character(len=:),allocatable :: mystring
!!    doubleprecision              :: d
!!    real                         :: r
!!    integer                      :: i
!!    logical                      :: l
!!
!!    INFINITE: do
!!       mystring=rd('Enter string or "STOP":',default='Today')
!!       if(mystring == 'STOP')stop
!!       i=rd('Enter integer:',default=huge(0))
!!       r=rd('Enter real:',default=huge(0.0))
!!       d=rd('Enter double:',default=huge(0.0d0))
!!       l=rd('Enter logical:',default=.false.)
!!
!!       write(*,*)'I=', i, 'R=', r, 'D=',d,  'MYSTRING=', mystring
!!       write(*,*)'L=', l
!!    enddo INFINITE
!!
!!    end program demo_rd
!!
!!##AUTHOR
!!    John S. Urban, 1993
!!##LICENSE
!!    Public Domain
function rd_logical(prompt,default) result(out)
! 1995 John S. Urban
!
implicit none

! ident_14="@(#) M_io rd_logical(3fp) ask for logical value from standard input with user-definable prompt"

character(len=*),intent(in)  :: prompt
logical,intent(in)           :: default
logical                      :: out

integer                      :: prompt_len
integer                      :: igot
integer                      :: ierr
integer                      :: icount
integer                      :: ios
character(:),allocatable     :: response
character(len=256)           :: iomsg
   out=.false.
   response=''
   prompt_len=len(prompt)
   do icount=1,20                                                 ! prevent infinite loop on error or end-of-file
      if(prompt_len > 0)write(*,'(a,'' '')',advance='no')prompt  ! write prompt
      ierr=getline(response,stdin)                                ! get back string
      igot=len(response)
      if(ierr /= 0)then
         cycle
      elseif(igot == 0.and.prompt_len > 0)then
         out=default
         exit
      elseif(igot <= 0)then
         call journal('*rd* blank string not allowed')
         cycle
      else
         response=response//' '
         select case(response(1:1))
         case('y','Y')
            out=.true.
         case('n','N')
            out=.false.
         case default
            read(response,*,iostat=ios,iomsg=iomsg)out
            if(ios /= 0)then
               write(*,*)trim(iomsg)
               cycle
            endif
         end select
         exit
      endif
   enddo
end function rd_logical
!===================================================================================================================================
function rd_character(prompt,default) result(strout)
! 1995 John S. Urban
!
implicit none

! ident_15="@(#) M_io rd_character(3fp) ask for string from standard input with user-definable prompt"

character(len=*),intent(in)  :: prompt
character(len=*),intent(in)  :: default
character(len=:),allocatable :: strout

integer                      :: len_default
integer                      :: igot
integer                      :: ierr
integer                      :: icount
!===================================================================================================================================
   len_default=len(prompt)
!===================================================================================================================================
   do icount=1,20                                                  ! prevent infinite loop on error or end-of-file
      if(len_default > 0)write(*,'(a,'' '')',advance='no')prompt  ! write prompt
      ierr=getline(strout,stdin)                                  ! get back string
      igot=len(strout)
      if(ierr /= 0)then
         strout='EOF'
         cycle
      elseif(igot == 0.and.len_default > 0)then
         strout=default
         exit
      elseif(igot <= 0)then
         call journal('*rd* blank string not allowed')
         cycle
      else
         exit
      endif
   enddo
end function rd_character
!===================================================================================================================================
function rd_doubleprecision(prompt,default,iostat) result(dvalue)
implicit none

! ident_16="@(#) M_io rd_doubleprecision(3fp) ask for number from standard input with user-definable prompt"

doubleprecision              :: dvalue
integer                      :: ivalue
character(len=*),intent(in)  :: prompt
doubleprecision,intent(in)   :: default
integer,intent(out),optional :: iostat
character(len=:),allocatable :: strout
character(len=:),allocatable :: message
integer                      :: itest

   iostat=0
   dvalue=default
   strout=adjustl(rd_character(prompt,'NaN'))

   ! 1 for an integer [-+]NNNNN
   ! 2 for a whole number [-+]NNNNN.
   ! 3 for a real value [-+]NNNNN.MMMM
   ! 4 for a exponential value [-+]NNNNN.MMMM[-+]LLLL [-+]NNNNN.MMMM[ed][-+]LLLL
   ! values less than 1 represent an error
   if(strout == 'NaN')then
      dvalue=default
   elseif(index(strout,'#') /= 0)then
      if( decodebase(strout,0,ivalue))then
         dvalue=ivalue
      else
         iostat=-1
         write(*,*)'ERROR> could not convert ',strout
      endif
   else
      itest=isnumber(strout,message)
      if(itest > 0)then
         dvalue=s2v(strout,ierr=iostat)
      else
         iostat=-2
         write(*,*)' ERROR> for ',strout,' ',itest,':',trim(message)
      endif
   endif
end function rd_doubleprecision
!===================================================================================================================================
function rd_real(prompt,default,iostat) result(rvalue)
implicit none

! ident_17="@(#) M_io rd_real(3fp) ask for number from standard input with user-definable prompt"

real                         :: rvalue
real(kind=dp)                :: dvalue
character(len=*),intent(in)  :: prompt
real,intent(in)              :: default
integer,intent(out),optional :: iostat
   !*! what about Nan, Inf, -Inf? Likely place for compiler bugs
   dvalue=rd_doubleprecision(prompt,dble(default),iostat)
   if(dvalue /= dvalue)then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] is indefinite'
      rvalue=huge(0.0)
   else
      rvalue=real(dvalue)
   endif
end function rd_real
!===================================================================================================================================
function rd_integer(prompt,default,iostat) result(ivalue)
implicit none

! ident_18="@(#) M_io rd_integer(3fp) ask for number from standard input with user-definable prompt"

integer                      :: ivalue
real(kind=dp)                :: dvalue
character(len=*),intent(in)  :: prompt
integer,intent(in)           :: default
integer,intent(out),optional :: iostat
   dvalue=rd_doubleprecision(prompt,dble(default),iostat)
   !*! what about Nan, Inf, -Inf?
   if(dvalue /= dvalue)then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] is indefinite'
      ivalue=huge(0)
   elseif(dvalue > huge(0))then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] greater than ', huge(0)
      ivalue=huge(0)
   elseif(dvalue < 1-huge(0))then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] less than ', 1-huge(0)
      ivalue=1-huge(0)
   else
      ivalue=nint(dvalue)
   endif
end function rd_integer
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getname(3f) - [M_io:QUERY] get name of the current executable
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getname() result(name)
!!
!!     character(len=:),allocatable         :: getname
!!
!!##DESCRIPTION
!!    getname(3f) returns the name of the current executable using
!!    get_command_argument(3f) and inquire(3f).
!!
!!##EXAMPLE
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getname
!!      use M_io, only : getname
!!      implicit none
!!         write(*,'(*(a))')'Running ',getname()
!!      end program demo_getname
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getname() result(name)
! get the pathname of arg0
implicit none
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: ios
character(len=4096)          :: long_name
character(len=:),allocatable :: name
   arg0_length=0
   name=''
   long_name=''
   call get_command_argument(0,length=arg0_length,status=ios)
   if(ios == 0)then
      if(allocated(arg0))deallocate(arg0)
      allocate(character(len=arg0_length) :: arg0)
      call get_command_argument(0,arg0,status=ios)
      if(ios == 0)then
         inquire(file=arg0,iostat=ios,name=long_name)
         if(ios == 0)then
            name=trim(long_name)
         else
            name=arg0
         endif
      else
         arg0=''
      endif
   else
      arg0=''
   endif
end function getname
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     which(3f) - [M_io:SCANNAMES] given a command name find the pathname
!!                 by searching the directories in the environment variable
!!                 $PATH
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function which(command) result(pathname)
!!
!!    character(len=*),intent(in)  :: command
!!    character(len=:),allocatable :: pathname
!!
!!##DESCRIPTION
!!    Given a command name find the first file with that name in the directories
!!    specified by the environment variable $PATH.
!!
!!##OPTIONS
!!    COMMAND   the command to search for
!!
!!##RETURNS
!!    PATHNAME  the first pathname found in the current user path. Returns blank
!!              if the command is not found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_which
!!     use M_io, only : which
!!     implicit none
!!        write(*,*)'ls is ',which('ls')
!!        write(*,*)'dir is ',which('dir')
!!        write(*,*)'install is ',which('install')
!!     end program demo_which
!!
!!##SEE ALSO
!!    M_system:system_dir(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function which(command) result(pathname)
character(len=*),intent(in)     :: command
character(len=:),allocatable    :: pathname, checkon, paths(:), exts(:)
integer                         :: i, j
   pathname=''
   call split(get_env('PATH'),paths,delimiters=merge(';',':',separator() == '\'))
   SEARCH: do i=1,size(paths)
      checkon=trim(joinpath(trim(paths(i)),command))
      select case(separator())
      case('/')
         if(exists(checkon))then
            pathname=checkon
            exit SEARCH
         endif
      case('\')
         if(exists(checkon))then
            pathname=checkon
            exit SEARCH
         endif
         if(exists(checkon//'.bat'))then
            pathname=checkon//'.bat'
            exit SEARCH
         endif
         if(exists(checkon//'.exe'))then
            pathname=checkon//'.exe'
            exit SEARCH
         endif
         call split(get_env('PATHEXT'),exts,delimiters=';')
         do j=1,size(exts)
            if(exists(checkon//'.'//trim(exts(j))))then
               pathname=checkon//'.'//trim(exts(j))
               exit SEARCH
            endif
         enddo
      end select
   enddo SEARCH
contains
logical function exists(filename) result(r)
character(len=*), intent(in) :: filename
    inquire(file=filename, exist=r)
end function exists
end function which
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     lookfor(3f) - [M_io:SCANNAMES] look for a filename in a number
!!                   of directories specified by an environment variable
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function lookfor(basename,env) result(pathname)
!!
!!    character(len=:),intent(in)  :: basename
!!    character(len=:),intent(in)  :: env
!!    character(len=:),allocatable :: pathname
!!
!!##DESCRIPTION
!!    Given a base filename find the first file with that name in the directories
!!    specified by the environment variable ENV
!!
!!##OPTIONS
!!    BASENAME   the file to search for
!!    ENV        environment variable name. Separator between directory names is
!!               assumed to be a colon on ULS (Unix-Like Systems) and semi-colon on
!!               MS-Windows machines.
!!
!!##RETURNS
!!    PATHNAME  the first pathname found in the current user path. Returns blank
!!              if the file is not found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_lookfor
!!     use M_io, only : lookfor
!!     implicit none
!!     character(len=:),allocatable :: returned
!!        returned=lookfor('ls','PATH')
!!        write(*,*)'ls is ',returned
!!        returned=lookfor('dir.exe','PATH')
!!        write(*,*)'dir is ',returned
!!     end program demo_lookfor
!!
!!##SEE ALSO
!!    M_system:system_dir(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function lookfor(basename,env) result(pathname)
character(len=*),intent(in)     :: basename
character(len=*),intent(in)     :: env
character(len=:),allocatable    :: pathname, checkon, paths(:)
integer                         :: i
logical                         :: r
   pathname=''
   call split(get_env(env),paths,delimiters=merge(';',':',separator() == '\'))
   if(size(paths) == 0)then
      paths=['']
   endif
   do i=1,size(paths)
      checkon=trim(joinpath(trim(paths(i)),basename))
      inquire(file=checkon, exist=r)
      if(r)then
         pathname=checkon
         exit
      endif
   enddo
end function lookfor
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     get_env(3f) - [M_io:QUERY] a function returning the value of
!!                   an environment variable
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!    function get_env(NAME,DEFAULT) result(VALUE)
!!
!!     character(len=*),intent(in)          :: NAME
!!     character(len=*),intent(in),optional :: DEFAULT
!!     character(len=:),allocatable         :: VALUE
!!
!!
!!##DESCRIPTION
!!     Get the value of an environment variable or optionally return a
!!     default value if the returned value would be a blank string.
!!
!!     This is a duplicate of system_getenv(3m_system) used to avoid
!!     some interdependencies.
!!
!!##OPTIONS
!!    NAME     name of environment variable
!!    DEFAULT  value to return if environment variable is not set or set
!!             to an empty string
!!##RETURNS
!!    VALUE    the value of the environment variable or the default
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!       program demo_get_env
!!       use M_io, only : get_env
!!       character(len=:),allocatable :: HOME
!!          HOME=get_env('HOME','UNKNOWN')
!!          write(*,'(a)')HOME,get_env('PATH')
!!          write(*,'(a)')get_env('HOME'),get_env('PATH')
!!       end program demo_get_env
!!
!!##SEE ALSO
!!    get_environment_variable(3fortran), system_getenv(3m_system),
!!    set_environment_variable(3m_system), system_putenv(3m_system),
!!    system_clearenv(3m_system), system_initenv(3m_system),
!!    system_readenv(3m_system), system_unsetenv(3m_system)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function get_env(NAME, DEFAULT) result(VALUE)
implicit none
character(len=*), intent(in)           :: NAME
character(len=*), intent(in), optional :: DEFAULT
character(len=:), allocatable          :: VALUE
integer                                :: howbig
integer                                :: stat
   if (NAME /= '') then
      call get_environment_variable(NAME, length=howbig, status=stat, trim_name=.true.) ! get length required to hold value
      select case (stat)
      case (1); VALUE = '' ! NAME is not defined in the environment
      case (2); VALUE = '' ! This processor doesn't support environment variables. Boooh!
      case default
         allocate (character(len=max(howbig, 1)) :: VALUE)                         ! make string to hold value of sufficient size
         call get_environment_variable(NAME, VALUE, status=stat, trim_name=.true.) ! get value
         if (stat /= 0) VALUE = ''
      end select
   else
      VALUE = ''
   end if
   if (VALUE == '' .and. present(DEFAULT)) VALUE = DEFAULT
end function get_env
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   is_hidden_file(3f) - [M_io:QUERY]  determine if a pathname points to a
!!   hidden file, which is defined as a file basename starting with a period.
!!   (LICENSE:PD)
!!
!!##SYNTAX
!!     impure elemental function is_hidden_file(PATH) result(YESNO)
!!
!!      character(len=*),intent(in) :: PATH
!!      logical                     :: YESNO
!!
!!##DESCRIPTION
!!    Given a pathname determine if it is a hidden file. This is simply
!!    assumed to be a basename that does not begin with a period and is not
!!    a single or double period, assumed to represent the current directory
!!    and parent directory.
!!
!!##LIMITATIONS
!!    Pathnames are not expanded to a canonical form, so if the basename is
!!    '.' or '..' and those point to a hidden directory name the return
!!    value will still be .FALSE. . Filenames are assumed to not contain
!!    leading or trailing spaces.
!!
!!##OPTIONS
!!    PATH     pathname to classify. It need not exist.
!!
!!##RETURNS
!!    YESNO    true if pathname points to a hidden file, otherwise it
!!             is false.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!       program demo_is_hidden_file
!!       use M_io, only : is_hidden_file, basename
!!          call showit('.abc')
!!          call showit('./.')
!!          call showit('..')
!!          call showit('...')
!!          call showit('/abc/def/notes.txt')
!!          call showit('/abc/def/.hide')
!!       contains
!!       subroutine showit(path)
!!       character(len=*),intent(in) :: path
!!          write(*,*)is_hidden_file(path), &
!!           & ' ,path=',path
!!       end subroutine showit
!!       end program demo_is_hidden_file
!!
!!    Results:
!!
!!     >  T  ,path=.abc
!!     >  F  ,path=./.
!!     >  F  ,path=..
!!     >  T  ,path=...
!!     >  F  ,path=/abc/def/notes.txt
!!     >  T  ,path=/abc/def/.hide
!!
!!##SEE ALSO
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental function is_hidden_file(path) result(yesno)
character(*), intent(in) :: path
logical :: yesno
character(len=:), allocatable :: base

   base = basename(path,suffix=char(0))//'  '
   select case (base)
   case ('.', '..');  yesno = .false.
   case default;      yesno = merge(.true., .false., base(1:1) == '.')
   end select

end function is_hidden_file
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     get_next_char(3f) - [M_io:READ] read from a file one character at a time
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!    subroutine get_next_char(fd,c,ios)
!!
!!     integer,intent(in)    :: fd
!!     character,intent(out) :: c
!!     integer,intent(out)   :: ios
!!
!!
!!##DESCRIPTION
!!    This reads a file opened with stream access one character at a
!!    time, much like ""read(fd,iostat=ios) c" but with buffering, which
!!    I have found to be up to sixty times faster than such a plain read,
!!    although this varies depending on how or if the programming environment
!!    implements I/O buffering itself.
!!
!!    IT USES SAVED VARIABLES AND CAN ONLY BE USED ON ONE FILE AT A TIME
!!    IN THE CURRENT FORM. A user type including the saved values and the
!!    LUN could easily resolve this.
!!
!!##OPTIONS
!!    FD    A Fortran unit number of a file opened for stream access
!!    C     The next returned character if IOS=0
!!    IOS   The error status returned by the last read. It is zero (0) if
!!          no error occurred
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_get_next_char
!!    use,intrinsic :: iso_fortran_env, only : iostat_end
!!    use M_io, only : get_next_char
!!    implicit none
!!    character(len=4096) :: filename ! filename to read
!!    character(len=256)  :: message  ! returned error messages
!!    integer             :: fd       ! file descriptor for input file
!!    integer             :: ios,ios1 ! hold I/O error flag
!!    character           :: c1       ! current character read
!!       filename='test.in'
!!       open(unit=fd,file=trim(filename),access='stream',status='old',&
!!       & iostat=ios,action='read',form='unformatted',iomsg=message)
!!       if(ios /= 0)then
!!          write(*,*)&
!!          '*demo_get_next_char* ERROR: could not open '//&
!!          trim(filename)
!!          write(*,*)&
!!          '*demo_get_next_char* ERROR: '//trim(message)
!!          stop 5
!!       endif
!!       ! loop through read of file one character at a time
!!       ONE_CHAR_AT_A_TIME: do
!!          ! get next character from buffered read from file
!!          call get_next_char(fd,c1,ios1)
!!          if(ios1 == iostat_end)then
!!             ! reached end of file so stop
!!             stop
!!          elseif(ios1 /= 0 )then
!!             ! error on file read
!!             write(*,*)&
!!          '*demo_get_next_char* ERROR: before end of '//&
!!          trim(filename)
!!             stop 1
!!          endif
!!          ! do something with the characters
!!          write(*,'(a)',advance='no')c1
!!       enddo ONE_CHAR_AT_A_TIME
!!    end program demo_get_next_char
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine get_next_char(fd,c,ios)
! replace "read(fd,iostat=ios) c" because gfortran on CygWin sixty times slower with plain read (no system buffering?)
! quick buffering read
implicit none
integer,intent(in)          :: fd
character,intent(out)       :: c
integer,intent(out)         :: ios
integer,parameter           :: bufsize=1048576
character(len=1),save       :: buff(bufsize)
integer,save                :: point=0
integer,save                :: filepoint=1
integer,save                :: sz=bufsize

ios=0

do
select case(point)
case(0)                                            ! read a buffer
   read(fd,iostat=ios,pos=filepoint) buff(1:sz)
   if(is_iostat_end(ios))then                      ! this is the last buffer
      if(sz /= 1)then                              ! try again with a smaller buffer
         sz=sz/2
         sz=max(1,sz)
         cycle
      endif
   elseif(ios == 0)then                            ! no error occurred so successfully read a buffer
      c=buff(1)
      filepoint=filepoint+sz
      point=sz-1
   endif
case(1:)                                           ! getting a character from a previous buffer
   point=point-1
   c=buff(sz-point)
case default
   write(*,*)'*get_next_char* internal error '
   read(fd,iostat=ios) c
end select
! assume if IOS is not zero, not called again until new file is started
   if(ios /= 0)then
      filepoint=1
      point=0
      sz=bufsize
   endif
   exit
enddo
end subroutine get_next_char
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notopen(3f) - [M_io:FILENAME] generate a filename containing a number
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    Usage
!!
!!       function filename_generator(head,tail,num,lenlimit) result(filename)
!!       character(len=*),intent(in)  :: head
!!       character(len=*),intent(in)  :: tail
!!       integer,intent(in) :: num
!!       integer,intent(in) :: lenlimit
!!       character(len=:),allocatable :: filename
!!
!!##DESCRIPTION
!!
!!    Generate a filename containing a representation of the specified
!!    whole number.  This is useful for generating a series of filenames
!!    differing by a number such as "file1.txt", "file2.txt",
!!    ... .
!!
!!##OPTIONS
!!
!!    head      filename prefix.
!!    tail      filename suffix.
!!    num       number to represent as a string between HEAD and TAIL.
!!    lenlimit  number of digits up to which to zero-pad the string
!!              representing NUM.
!!
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!       program demo_filename_generator
!!       use,intrinsic::iso_fortran_env,only:int8,int16,int32,int64
!!       use M_io, only : filename_generator
!!       implicit none
!!
!!           ! no zero-fill
!!           write(*,*) filename_generator("file_",".dat",11)
!!           ! zero-fill till 3 digits
!!           write(*,*) filename_generator("file_",".dat",11,3)
!!           ! zero-fill till 9 digits
!!           write(*,*) filename_generator("file_",".dat",11,9)
!!           ! same as default (no zero-fill)
!!           write(*,*) filename_generator("file_",".dat",11,0)
!!
!!       end program demo_filename_generator
!!
!!    Results
!!
!!       > file_11.dat
!!       > file_011.dat
!!       > file_000000011.dat
!!       > file_11.dat
!!
!!##AUTHOR
!!    Zh, Niu; with modifications by John S. Urban
!!##LICENSE
!!    Public Domain

function filename_generator(head, tail, num, lenlimit) result(filename)
character(*),intent(in)      :: head
character(*),intent(in)      :: tail
integer,intent(in)           :: num
integer,intent(in),optional  :: lenlimit
character(len=:),allocatable :: filename

character(30)                :: fmt
integer                      :: local_lenlimit

   if ( present(lenlimit) ) then
      local_lenlimit = lenlimit
   else
      local_lenlimit = 0
   endif

   fmt = ""
   write(fmt, '("(a,i0.",i2.2,",a)")' ) local_lenlimit
   filename=repeat(' ', len(head) + len(tail) + max(19,local_lenlimit) )
   write(filename(:),fmt) trim(adjustl(head)), num, trim(adjustl(tail))
   filename=trim(filename)
end function filename_generator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! routines from other modules to make this one stand-alone
!     XX                    XX       X
!      X                     X                              X
!      X                     X                              X
!  XXXXX  XX  XX  XXXXXX     X     XXX     XXXXX   XXXX    XXXX    XXXXX   XXXXX
! X    X   X   X   X    X    X       X    X     X      X    X     X     X X     X
! X    X   X   X   X    X    X       X    X        XXXXX    X     XXXXXXX  XXX
! X    X   X   X   X    X    X       X    X       X    X    X     X           XX
! X    X   X  XX   X    X    X       X    X     X X    X    X  X  X     X X     X
!  XXXXXX   XX XX  XXXXX   XXXXX   XXXXX   XXXXX   XXXX X    XX    XXXXX   XXXXX
!                  X
!                 XXX
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lenset(line,length) result(strout)

!character(len=*),parameter::ident_36="@(#)M_strings::lenset(3f): return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine a2i(chars,valu,ierr)

!character(len=*),parameter::ident_41="@(#)M_strings::a2i(3fp): subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         write(*,*)'sc','*a2i*','- value too large',valu8,'>',huge(valu)
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

!character(len=*),parameter::ident_42="@(#)M_strings::a2d(3fp): subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=chars
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         write(*,*)'sc','*a2d* - cannot produce number from string ['//trim(chars)//']'
         if(msg /= '')then
            write(*,*)'*a2d* - ['//trim(msg)//']'
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

!character(len=*),parameter::ident_43="@(#)M_strings::s2v(3f): returns doubleprecision number from string"


character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(*,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
   int_s2v=int(s2v(chars))
end function int_s2v
!===================================================================================================================================
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
!===================================================================================================================================
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
!===================================================================================================================================
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
function s2vs(string,delim) result(darray)

!character(len=*),parameter::ident_55="@(#)M_strings::s2vs(3f): function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
logical function decodebase(string,basein,out_baseten)
implicit none

!character(len=*),parameter::ident_72="@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                  ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine trimzeros(string)

!character(len=*),parameter::ident_50="@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: exp          ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      exp=str(ipos:)                         ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.') == 0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i <= 1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(exp)
   else
      string=str
   endif
end subroutine trimzeros
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine substitute(targetline,old,new,ierr,start,end)

!character(len=*),parameter::ident_11="@(#)M_strings::substitute(3f): Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichar
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option !! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id <= 0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichar=len_new + original_input_length
      if(ichar > maxlengthout)then
         write(*,*)'*substitute* new line will be too long'
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichar=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind == ic-1.or.ind > ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichar-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichar:)=targetline(ic:ind-1)
         ichar=ichar+ladd
      endif
      if(ichar-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichar:)=new(:len_new)
         ichar=ichar+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      write(*,*)'*substitute* new line will be too long'
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichar+ladd > maxlengthout)then
         write(*,*)'*substitute* new line will be too long'
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichar:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! NAME
!    isnumber(3f) - [M_strings:NUMERIC] determine if a string represents a number
!    (LICENSE:PD)
!
! SYNOPSIS
!    function isnumber(str,msg)
!
!     character(len=*),intent(in)  :: str
!     character(len=:),intent(out),allocatable,optional  :: msg
!
! DESCRIPTION
!     ISNUMBER(3f) returns a value greater than zero if the string represents
!     a number, and a number less than or equal to zero if it is a bad number.
!     Blank characters are ignored.
!
! OPTIONS
!     str  the string to evaluate as to whether it represents a numeric value
!          or not
!     msg  An optional message describing the string
!
! RETURNS
!     isnumber  the following values are returned
!
!                1 for an integer             [-+]NNNNN
!                2 for a whole number         [-+]NNNNN.
!                3 for a real value           [-+]NNNNN.MMMM
!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!
!               values less than 1 represent an error
!
! EXAMPLES
!   As the example shows, you can use an internal READ(3f) along with the
!   IOSTAT= parameter to check (and read) a string as well.
!
!     program demo_isnumber
!     use M_strings, only : isnumber
!     implicit none
!     character(len=256) :: line
!     real               :: value
!     integer            :: ios
!     integer            :: answer
!     character(len=256) :: message
!     character(len=:),allocatable :: description
!        write(*,*)'Begin entering values, one per line'
!        do
!           read(*,'(a)',iostat=ios)line
!           !
!           ! try string as number using list-directed input
!           line=''
!           read(line,*,iostat=ios,iomsg=message) value
!           if(ios == 0)then
!              write(*,*)'VALUE=',value
!           elseif( is_iostat_end(ios) ) then
!              stop 'end of file'
!           else
!              write(*,*)'ERROR:',ios,trim(message)
!           endif
!           !
!           ! try string using isnumber(3f)
!           answer=isnumber(line,msg=description)
!           if(answer > 0)then
!              write(*,*) &
!              & ' for ',trim(line),' ',answer,':',description
!           else
!              write(*,*) &
!              & ' ERROR for ',trim(line),' ',answer,':',description
!           endif
!           !
!        enddo
!     end program demo_isnumber
!
!  Example run
!
!    > Begin entering values
!    > ERROR:          -1 End of file
!    >  ERROR for            -1 :null string
!    >10
!    > VALUE=   10.0000000
!    >  for 10            1 :integer
!    >20
!    > VALUE=   20.0000000
!    >  for 20            1 :integer
!    >20.
!    > VALUE=   20.0000000
!    >  for 20.            2 :whole number
!    >30.1
!    > VALUE=   30.1000004
!    >  for 30.1            3 :real number
!    >3e1
!    > VALUE=   30.0000000
!    >  for 3e1            4 :value with exponent
!    >1-2
!    > VALUE=   9.99999978E-03
!    >  for 1-2            4 :value with exponent
!    >100.22d-4
!    > VALUE=   1.00220004E-02
!    >  for 100.22d-4            4 :value with exponent
!    >1--2
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1--2           -5 :bad number
!    >e
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for e           -6 :missing leading value before exponent
!    >e1
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for e1           -6 :missing leading value before exponent
!    >1e
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e           -3 :missing exponent
!    >1e+
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e+           -4 :missing exponent after sign
!    >1e+2.0
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e+2.0           -5 :bad number
!
! AUTHOR
!    John S. Urban
!
! LICENSE
!    Public Domain
function isNumber(string,msg,verbose)
implicit none

! ident_1="@(#)M_strings::isnumber(3f): Determines if a string is a number of not."

character(len=*),intent(in)    :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                      :: verbose
integer                      :: isnumber

integer             :: i,iend
character(len=1),allocatable :: z(:)
character(len=:),allocatable :: message
logical                      :: founddigit
logical                      :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=s2a(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend == 0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)) /= 0) i=i+1  ! skip optional leading sign
      if(i > iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i > iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i) == '.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i > iend)then                ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)) /= 0)then
         i=i+1
         if(i == 2)then
            isnumber=-6                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i > iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)) /= 0) i=i+1
      if(i > iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i <= iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental function isdigit(ch) result(res)

! ident_2="@(#)M_strings::isdigit(3f): Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! NAME
!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!    input string
!    (LICENSE:PD)
!
! SYNOPSIS
!    function nospace(str) - remove all whitespace from input string
!
!     character(len=*),intent(in)          :: str
!     character(len=:),allocatable         :: nospace
!
! DESCRIPTION
!    nospace(3f) removes space, tab, carriage return, new line, vertical
!    tab, formfeed and null characters (called "whitespace"). The output
!    is returned trimmed.
!
! EXAMPLES
!   Sample program:
!
!     program demo_nospace
!     use M_strings, only: nospace
!     implicit none
!     character(len=:),allocatable  :: s
!        s='  This     is      a     test  '
!        write(*,*) 'original input string is ....',s
!        write(*,*) 'processed output string is ...',nospace(s)
!        if(nospace(s) == 'Thisisatest')then
!           write(*,*)'nospace test passed'
!        else
!           write(*,*)'nospace test error'
!        endif
!     end program demo_nospace
!
!   Expected output
!
!     original input string is ....  This     is      a     test
!     processed output string is ...Thisisatest
!     nospace test passed
!
! AUTHOR
!    John S. Urban
!
! LICENSE
!    Public Domain
function nospace(line)

! ident_3="@(#)M_strings::nospace(3f): remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & ichar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_63="@(#)M_strings::isspace(3f): true if null,space,tab,return,new line,vertical tab, or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

!character(len=*),parameter::ident_7="&
!&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: ilen                   ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len(input_line)                                           ! ILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ilen)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (:0)                                                      ! command was totally blank
!-----------------------------------------------------------------------------------------------------------------------------------
   case default                                                   ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,ilen,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iterm(i30)=ilen                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))
               IF(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > ilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                       ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(ordr)))                              ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental pure function upper(str,begin,end) result (string)

!character(len=*),parameter::ident_21="@(#)M_strings::upper(3f): Changes a string to uppercase"

character(*), intent(In)      :: str                 ! inpout string to convert to all uppercase
integer, intent(in), optional :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
   string = str                                      ! initialize output string to input string

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
       select case (str(i:i))
       case ('a':'z')                                ! located miniscule letter
          string(i:i) = char(iachar(str(i:i))-32)    ! change miniscule letter to uppercase
       end select
   end do

end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental pure function lower(str,begin,end) result (string)

!character(len=*),parameter::ident_22="@(#)M_strings::lower(3f): Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
   string = str

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)     ! change letter to miniscule
      case default
      end select
   end do

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

!character(len=*),parameter::ident_24="@(#)M_strings::s2a(3fp): function to copy string(1:Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

!character(len=*),parameter::ident_47="@(#)M_strings::i2s(3fp): private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

!character(len=*),parameter::ident_40="@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         write(*,*)'*value_to_string* UNKNOWN TYPE'
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
      !! cannot currently do I/O from a function being called from I/O
      !!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

!character(len=*),parameter::ident_37="@(#)M_strings::merge_str(3f): pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in)     :: str1
character(len=*),intent(in)     :: str2
logical,intent(in)              :: expr
character(len=:),allocatable    :: strout
integer                         :: big
   big=max(len(str1),len(str2))
   strout=trim(merge(lenset(str1,big),lenset(str2,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine notabs(INSTR,OUTSTR,ILEN)

!character(len=*),parameter::ident_31="&
!&@(#)M_strings::notabs(3f): convert tabs to spaces while maintaining columns, remove CRLF chars"

CHARACTER(LEN=*),INTENT(IN)   :: instr        ! input line to scan for tab characters
CHARACTER(LEN=*),INTENT(OUT)  :: outstr       ! tab-expanded version of INSTR produced
INTEGER,INTENT(OUT)           :: ilen         ! column position of last character put into output string
                                              ! that is, ILEN holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
INTEGER,PARAMETER             :: tabsize=8    ! assume a tab stop is set every 8th column
INTEGER                       :: ipos         ! position in OUTSTR to put next character of INSTR
INTEGER                       :: lenin        ! length of input string trimmed of trailing spaces
INTEGER                       :: lenout       ! number of characters output string can hold
INTEGER                       :: istep        ! counter that advances thru input string INSTR one character at a time
CHARACTER(LEN=1)              :: c            ! character in input line being processed
INTEGER                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
   IPOS=1                                     ! where to put next character in output string OUTSTR
   lenin=LEN(instr)                           ! length of character variable INSTR
   lenin=LEN_TRIM(instr(1:lenin))             ! length of INSTR trimmed of trailing spaces
   lenout=LEN(outstr)                         ! number of characters output string OUTSTR can hold
   OUTSTR=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: DO istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=ICHAR(c)                        ! get ADE of the character
         expand_tabs : SELECT CASE (iade)     ! take different actions depending on which character was found
         CASE(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (MOD(ipos-1,tabsize)))
         CASE(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         CASE DEFAULT                         ! c is anything else other than a tab,newline,or return  insert it in output string
            IF(ipos > lenout)THEN
               write(*,*)"*notabs* output string overflow"
               EXIT
            ELSE
               outstr(ipos:ipos)=c
               ipos=ipos+1
            ENDIF
         END SELECT expand_tabs
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=MIN(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      ilen=LEN_TRIM(outstr(:ipos))            ! trim trailing spaces
!===================================================================================================================================
END SUBROUTINE notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental function noesc(INSTR)
! ident_48="@(#) M_strings noesc(3f) convert non-printable characters to a space"
character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic <= 31.or.ic == 127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)
! ident_2="@(#)M_journal::where_write_message(3fp): basic message routine used for journal files"
character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to my_stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O
character(len=4096)                :: mssge
   adv='yes'
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)trim(msg)
         endif
      case('S','s')
         write(my_stdout,'(a)',advance=adv)trim(msg)
         times=times+1
      case('E','e')
         write(stderr,'(a)',advance=adv)trim(msg)
         times=times+1
      case('+'); adv='no'
      case('>'); debug=.true.
      case('<'); debug=.false.
      case('N')                                                   ! new name for my_stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               my_stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            my_stdout=6
         endif
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)comment,trim(msg)
         elseif(times == 0)then
            !! write(my_stdout,'(2a)',advance=adv)trim(msg)
            !! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(my_stdout,'(3a)',advance=adv)'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(my_stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
end subroutine where_write_message

subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, sep)
implicit none
! ident_5="@(#)M_journal::where_write_message_all(3f): writes a message to a string composed of any standard scalar types"
character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
character(len=*),intent(in),optional :: sep
call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,sep))
end subroutine where_write_message_all

subroutine write_message_only(message)
! ident_6="@(#)M_journal::write_message_only(3fp): calls JOURNAL('sc',message)"
character(len=*),intent(in)          :: message
   call where_write_message('sc',trim(message))
end subroutine write_message_only

function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
! ident_2="@(#)M_io::msg_scalar(3fp): writes a message to a string composed of any standard scalar types"
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
         increment=len(sep)+1
         sep_local=sep
   else
      sep_local=' '
      increment=2
   endif
   istart=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   msg_scalar=trim(line)
contains

subroutine print_generic(generic)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
#endif
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function msg_scalar

function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none
! ident_3="@(#)M_io::msg_one(3fp): writes a message to a string composed of any standard one dimensional types"
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:),allocatable  :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      increment=len(sep)+1
      sep_local=sep
   else
      sep_local=' '
      increment=2
   endif
   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains

subroutine print_generic(generic)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
#endif
      !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   istart=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic

end function msg_one
!===================================================================================================================================
function crop(strin) result (strout)

! ident_19="@(#) M_strings crop(3f) trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(strin))
end function crop
!===================================================================================================================================
end module m_io
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
 
 
!>>>>> app/fpm-license.f90
program license
use, intrinsic :: iso_fortran_env, only: stderr=>ERROR_UNIT, stdout=>OUTPUT_UNIT, stdin=>INPUT_UNIT
use               M_strings,       only: lower, replace, stretch, transliterate
use               M_CLI2,          only: set_args, lget, sget, sgets, spdx_names => unnamed, specified
use               M_io,            only: fileread, get_env

! https://spdx.org/licenses/
! lists many of the common licenses, their abbreviations, and a canononical web page for the license.
character(len=:), allocatable   :: textblock(:)
character(len=:), allocatable   :: configblock(:)
character(len=:), allocatable   :: spdx(:)
character(len=:), allocatable   :: filename
character(len=:), allocatable   :: config
character(len=20)               :: cnum
character(len=8)                :: date
character(len=:), allocatable   :: help(:), version(:)
integer :: i
integer :: j
integer :: width
logical :: all
   call setup()
   call set_args(' --all F --fortran F --file " " --config "'//get_env("FPM_LICENSE_CONFIG")//'"', help, version)
   all = lget('all')
   filename=sget('file')

   config=sget('config')
   if(config.ne.'')then
      call fileread(config,configblock)
   else
      configblock=[character(len=0)::]
   endif
   call date_and_time(date)
   configblock=[character(len=max(12,len(configblock))):: configblock,&  ! add some predefined conversion strings
      '@YEAR@=>'//date(1:4),&
      '@MONTH@=>'//date(5:6),&
      '@DAY@=>'//date(7:8)] ! widen file is neccessary

   if(specified('file'))then
      if(filename.eq.'')then
         call fileread(stdin,textblock)
      else
         call fileread(filename,textblock)
      endif
         if (size(textblock) > 0)then
            textblock=[character(len=max(len(filename),len(textblock))):: filename,textblock]
            call replaceit()
            call codeit()
         endif
   elseif (all) then
      do i = 1, huge(i) - 1
         write (cnum, '(i0)') i
         textblock = show_one(cnum)
         if (textblock(1) == 'UNKNOWN') exit
         call replaceit()
         if(lget('fortran'))then
            call codeit()
         else
            !write(*,'(at)')textblock
            write (*, '(a)') (trim(textblock(j)), j=min(2, size(textblock)), size(textblock))
         endif
      end do
   elseif (size(spdx_names) /= 0) then
      do i = 1, size(spdx_names)
         write (cnum, '(i0)') i
         textblock = show_one(lower(spdx_names(i)))
         if (textblock(1) == 'UNKNOWN')then
            write(stderr,'(*(g0))')'*fpm-license*<ERROR> no match for SPDX license name ',trim(spdx_names(i))
            cycle
         endif
         call replaceit()
         if(lget('fortran'))then
            call codeit()
         else
            !write(*,'(at)')textblock
            write (*, '(a)') (trim(textblock(j)), j=min(2, size(textblock)), size(textblock))
         endif
      end do
   else
      spdx = [character(len=0) ::]
      do i = 1, huge(i) - 1
         write (cnum, '(i0)') i
         textblock = show_one(cnum, topic_only=.true.)
         if (textblock(1) == 'UNKNOWN') exit
         width = max(len(trim(textblock(1))), len(spdx))
         spdx = [character(len=width) :: spdx, textblock]
      end do
      write (*, '(4(a,1x))') (spdx(j), j=1, size(spdx))
   end if
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function show_one(name,topic_only) result (textblock)
character(len=*),intent(in)      :: name
logical,intent(in),optional      :: topic_only
character(len=256),allocatable   :: textblock(:)
integer                          :: i
select case(name)
case('1','0bsd')
textblock=[ CHARACTER(LEN=128) :: &
'0bsd',&
'    ',&
'BSD Zero Clause License',&
'                       ',&
'Copyright (c) @YEAR@ @FULLNAME@',&
'                               ',&
'Permission to use, copy, modify, and/or distribute this software for any',&
'purpose with or without fee is hereby granted.                          ',&
'                                                                        ',&
'THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH',&
'REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  ',&
'AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, ',&
'INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  ',&
'LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR',&
'OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR       ',&
'PERFORMANCE OF THIS SOFTWARE.                                                ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('2','afl-3.0')
textblock=[ CHARACTER(LEN=128) :: &
'afl-3.0',&
'       ',&
'Academic Free License ("AFL") v. 3.0',&
'                                    ',&
'This Academic Free License (the "License") applies to any original work of',&
'authorship (the "Original Work") whose owner (the "Licensor") has placed the',&
'following licensing notice adjacent to the copyright notice for the Original',&
'Work:                                                                       ',&
'                                                                            ',&
'  Licensed under the Academic Free License version 3.0                      ',&
'                                                                            ',&
'1) Grant of Copyright License. Licensor grants You a worldwide, royalty-free,',&
'non-exclusive, sublicensable license, for the duration of the copyright, to do',&
'the following:                                                                ',&
'                                                                              ',&
'  a) to reproduce the Original Work in copies, either alone or as part of a   ',&
'  collective work;                                                            ',&
'                                                                              ',&
'  b) to translate, adapt, alter, transform, modify, or arrange the Original   ',&
'  Work, thereby creating derivative works ("Derivative Works") based upon the ',&
'  Original Work;                                                              ',&
'                                                                              ',&
'  c) to distribute or communicate copies of the Original Work and Derivative  ',&
'  Works to the public, under any license of your choice that does not         ',&
'  contradict the terms and conditions, including Licensor''s reserved rights  ',&
'  and remedies, in this Academic Free License;                                ',&
'                                                                              ',&
'  d) to perform the Original Work publicly; and                               ',&
'                                                                              ',&
'  e) to display the Original Work publicly.                                   ',&
'                                                                              ',&
'2) Grant of Patent License. Licensor grants You a worldwide, royalty-free,    ',&
'non-exclusive, sublicensable license, under patent claims owned or controlled ',&
'by the Licensor that are embodied in the Original Work as furnished by the    ',&
'Licensor, for the duration of the patents, to make, use, sell, offer for sale,',&
'have made, and import the Original Work and Derivative Works.                 ',&
'                                                                              ',&
'3) Grant of Source Code License. The term "Source Code" means the preferred   ',&
'form of the Original Work for making modifications to it and all available    ',&
'documentation describing how to modify the Original Work. Licensor agrees to  ',&
'provide a machine-readable copy of the Source Code of the Original Work along ',&
'with each copy of the Original Work that Licensor distributes. Licensor       ',&
'reserves the right to satisfy this obligation by placing a machine-readable   ',&
'copy of the Source Code in an information repository reasonably calculated to ',&
'permit inexpensive and convenient access by You for as long as Licensor       ',&
'continues to distribute the Original Work.                                    ',&
'                                                                              ',&
'4) Exclusions From License Grant. Neither the names of Licensor, nor the names',&
'of any contributors to the Original Work, nor any of their trademarks or      ',&
'service marks, may be used to endorse or promote products derived from this   ',&
'Original Work without express prior permission of the Licensor. Except as     ',&
'expressly stated herein, nothing in this License grants any license to        ',&
'Licensor''s trademarks, copyrights, patents, trade secrets or any other       ',&
'intellectual property. No patent license is granted to make, use, sell, offer ',&
'for sale, have made, or import embodiments of any patent claims other than the',&
'licensed claims defined in Section 2. No license is granted to the trademarks ',&
'of Licensor even if such marks are included in the Original Work. Nothing in  ',&
'this License shall be interpreted to prohibit Licensor from licensing under   ',&
'terms different from this License any Original Work that Licensor otherwise   ',&
'would have a right to license.                                                ',&
'                                                                              ',&
'5) External Deployment. The term "External Deployment" means the use,         ',&
'distribution, or communication of the Original Work or Derivative Works in any',&
'way such that the Original Work or Derivative Works may be used by anyone     ',&
'other than You, whether those works are distributed or communicated to those  ',&
'persons or made available as an application intended for use over a network.  ',&
'As an express condition for the grants of license hereunder, You must treat   ',&
'any External Deployment by You of the Original Work or a Derivative Work as a ',&
'distribution under section 1(c).                                              ',&
'                                                                              ',&
'6) Attribution Rights. You must retain, in the Source Code of any Derivative  ',&
'Works that You create, all copyright, patent, or trademark notices from the   ',&
'Source Code of the Original Work, as well as any notices of licensing and any ',&
'descriptive text identified therein as an "Attribution Notice." You must cause',&
'the Source Code for any Derivative Works that You create to carry a prominent ',&
'Attribution Notice reasonably calculated to inform recipients that You have   ',&
'modified the Original Work.                                                   ',&
'                                                                              ',&
'7) Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that  ',&
'the copyright in and to the Original Work and the patent rights granted herein',&
'by Licensor are owned by the Licensor or are sublicensed to You under the     ',&
'terms of this License with the permission of the contributor(s) of those      ',&
'copyrights and patent rights. Except as expressly stated in the immediately   ',&
'preceding sentence, the Original Work is provided under this License on an "AS',&
'IS" BASIS and WITHOUT WARRANTY, either express or implied, including, without ',&
'limitation, the warranties of non-infringement, merchantability or fitness for',&
'a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK  ',&
'IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this',&
'License. No license to the Original Work is granted by this License except    ',&
'under this disclaimer.                                                        ',&
'                                                                              ',&
'8) Limitation of Liability. Under no circumstances and under no legal theory, ',&
'whether in tort (including negligence), contract, or otherwise, shall the     ',&
'Licensor be liable to anyone for any indirect, special, incidental, or        ',&
'consequential damages of any character arising as a result of this License or ',&
'the use of the Original Work including, without limitation, damages for loss  ',&
'of goodwill, work stoppage, computer failure or malfunction, or any and all   ',&
'other commercial damages or losses. This limitation of liability shall not    ',&
'apply to the extent applicable law prohibits such limitation.                 ',&
'                                                                              ',&
'9) Acceptance and Termination. If, at any time, You expressly assented to this',&
'License, that assent indicates your clear and irrevocable acceptance of this  ',&
'License and all of its terms and conditions. If You distribute or communicate ',&
'copies of the Original Work or a Derivative Work, You must make a reasonable  ',&
'effort under the circumstances to obtain the express assent of recipients to  ',&
'the terms of this License. This License conditions your rights to undertake   ',&
'the activities listed in Section 1, including your right to create Derivative ',&
'Works based upon the Original Work, and doing so without honoring these terms ',&
'and conditions is prohibited by copyright law and international treaty.       ',&
'Nothing in this License is intended to affect copyright exceptions and        ',&
'limitations (including "fair use" or "fair dealing"). This License shall      ',&
'terminate immediately and You may no longer exercise any of the rights granted',&
'to You by this License upon your failure to honor the conditions in Section   ',&
'1(c).                                                                         ',&
'                                                                              ',&
'10) Termination for Patent Action. This License shall terminate automatically ',&
'and You may no longer exercise any of the rights granted to You by this       ',&
'License as of the date You commence an action, including a cross-claim or     ',&
'counterclaim, against Licensor or any licensee alleging that the Original Work',&
'infringes a patent. This termination provision shall not apply for an action  ',&
'alleging patent infringement by combinations of the Original Work with other  ',&
'software or hardware.                                                         ',&
'                                                                              ',&
'11) Jurisdiction, Venue and Governing Law. Any action or suit relating to this',&
'License may be brought only in the courts of a jurisdiction wherein the       ',&
'Licensor resides or in which Licensor conducts its primary business, and under',&
'the laws of that jurisdiction excluding its conflict-of-law provisions. The   ',&
'application of the United Nations Convention on Contracts for the             ',&
'International Sale of Goods is expressly excluded. Any use of the Original    ',&
'Work outside the scope of this License or after its termination shall be      ',&
'subject to the requirements and penalties of copyright or patent law in the   ',&
'appropriate jurisdiction. This section shall survive the termination of this  ',&
'License.                                                                      ',&
'                                                                              ',&
'12) Attorneys'' Fees. In any action to enforce the terms of this License or   ',&
'seeking damages relating thereto, the prevailing party shall be entitled to   ',&
'recover its costs and expenses, including, without limitation, reasonable     ',&
'attorneys'' fees and costs incurred in connection with such action, including ',&
'any appeal of such action. This section shall survive the termination of this ',&
'License.                                                                      ',&
'                                                                              ',&
'13) Miscellaneous. If any provision of this License is held to be             ',&
'unenforceable, such provision shall be reformed only to the extent necessary  ',&
'to make it enforceable.                                                       ',&
'                                                                              ',&
'14) Definition of "You" in This License. "You" throughout this License,       ',&
'whether in upper or lower case, means an individual or a legal entity         ',&
'exercising rights under, and complying with all of the terms of, this License.',&
'For legal entities, "You" includes any entity that controls, is controlled by,',&
'or is under common control with you. For purposes of this definition,         ',&
'"control" means (i) the power, direct or indirect, to cause the direction or  ',&
'management of such entity, whether by contract or otherwise, or (ii) ownership',&
'of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ',&
'ownership of such entity.                                                     ',&
'                                                                              ',&
'15) Right to Use. You may use the Original Work in all ways not otherwise     ',&
'restricted or conditioned by this License or by law, and Licensor promises not',&
'to interfere with or be responsible for such uses by You.                     ',&
'                                                                              ',&
'16) Modification of This License. This License is Copyright  2005 Lawrence  ',&
'Rosen. Permission is granted to copy, distribute, or communicate this License ',&
'without modification. Nothing in this License permits You to modify this      ',&
'License as applied to the Original Work or to Derivative Works. However, You  ',&
'may modify the text of this License and copy, distribute or communicate your  ',&
'modified version (the "Modified License") and apply it to other original works',&
'of authorship subject to the following conditions: (i) You may not indicate in',&
'any way that your Modified License is the "Academic Free License" or "AFL" and',&
'you may not use those names in the name of your Modified License; (ii) You    ',&
'must replace the notice specified in the first paragraph above with the notice',&
'"Licensed under <insert your license name here>" or with a notice of your own ',&
'that is not confusingly similar to the notice in this License; and (iii) You  ',&
'may not claim that your original works are open source software unless your   ',&
'Modified License has been approved by Open Source Initiative (OSI) and You    ',&
'comply with its license review and certification process.                     ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('3','agpl-3.0')
textblock=[ CHARACTER(LEN=128) :: &
'agpl-3.0',&
'        ',&
'                    GNU AFFERO GENERAL PUBLIC LICENSE',&
'                       Version 3, 19 November 2007   ',&
'                                                     ',&
' Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>',&
' Everyone is permitted to copy and distribute verbatim copies        ',&
' of this license document, but changing it is not allowed.           ',&
'                                                                     ',&
'                            Preamble                                 ',&
'                                                                     ',&
'  The GNU Affero General Public License is a free, copyleft license for',&
'software and other kinds of works, specifically designed to ensure     ',&
'cooperation with the community in the case of network server software. ',&
'                                                                       ',&
'  The licenses for most software and other practical works are designed',&
'to take away your freedom to share and change the works.  By contrast, ',&
'our General Public Licenses are intended to guarantee your freedom to  ',&
'share and change all versions of a program--to make sure it remains free',&
'software for all its users.                                             ',&
'                                                                        ',&
'  When we speak of free software, we are referring to freedom, not      ',&
'price.  Our General Public Licenses are designed to make sure that you  ',&
'have the freedom to distribute copies of free software (and charge for  ',&
'them if you wish), that you receive source code or can get it if you    ',&
'want it, that you can change the software or use pieces of it in new    ',&
'free programs, and that you know you can do these things.               ',&
'                                                                        ',&
'  Developers that use our General Public Licenses protect your rights   ',&
'with two steps: (1) assert copyright on the software, and (2) offer     ',&
'you this License which gives you legal permission to copy, distribute   ',&
'and/or modify the software.                                             ',&
'                                                                        ',&
'  A secondary benefit of defending all users'' freedom is that          ',&
'improvements made in alternate versions of the program, if they         ',&
'receive widespread use, become available for other developers to        ',&
'incorporate.  Many developers of free software are heartened and        ',&
'encouraged by the resulting cooperation.  However, in the case of       ',&
'software used on network servers, this result may fail to come about.   ',&
'The GNU General Public License permits making a modified version and    ',&
'letting the public access it on a server without ever releasing its     ',&
'source code to the public.                                              ',&
'                                                                        ',&
'  The GNU Affero General Public License is designed specifically to     ',&
'ensure that, in such cases, the modified source code becomes available  ',&
'to the community.  It requires the operator of a network server to      ',&
'provide the source code of the modified version running there to the    ',&
'users of that server.  Therefore, public use of a modified version, on  ',&
'a publicly accessible server, gives the public access to the source     ',&
'code of the modified version.                                           ',&
'                                                                        ',&
'  An older license, called the Affero General Public License and        ',&
'published by Affero, was designed to accomplish similar goals.  This is ',&
'a different license, not a version of the Affero GPL, but Affero has    ',&
'released a new version of the Affero GPL which permits relicensing under',&
'this license.                                                           ',&
'                                                                        ',&
'  The precise terms and conditions for copying, distribution and        ',&
'modification follow.                                                    ',&
'                                                                        ',&
'                       TERMS AND CONDITIONS                             ',&
'                                                                        ',&
'  0. Definitions.                                                       ',&
'                                                                        ',&
'  "This License" refers to version 3 of the GNU Affero General Public License.',&
'                                                                              ',&
'  "Copyright" also means copyright-like laws that apply to other kinds of     ',&
'works, such as semiconductor masks.                                           ',&
'                                                                              ',&
'  "The Program" refers to any copyrightable work licensed under this          ',&
'License.  Each licensee is addressed as "you".  "Licensees" and               ',&
'"recipients" may be individuals or organizations.                             ',&
'                                                                              ',&
'  To "modify" a work means to copy from or adapt all or part of the work      ',&
'in a fashion requiring copyright permission, other than the making of an      ',&
'exact copy.  The resulting work is called a "modified version" of the         ',&
'earlier work or a work "based on" the earlier work.                           ',&
'                                                                              ',&
'  A "covered work" means either the unmodified Program or a work based        ',&
'on the Program.                                                               ',&
'                                                                              ',&
'  To "propagate" a work means to do anything with it that, without            ',&
'permission, would make you directly or secondarily liable for                 ',&
'infringement under applicable copyright law, except executing it on a         ',&
'computer or modifying a private copy.  Propagation includes copying,          ',&
'distribution (with or without modification), making available to the          ',&
'public, and in some countries other activities as well.                       ',&
'                                                                              ',&
'  To "convey" a work means any kind of propagation that enables other         ',&
'parties to make or receive copies.  Mere interaction with a user through      ',&
'a computer network, with no transfer of a copy, is not conveying.             ',&
'                                                                              ',&
'  An interactive user interface displays "Appropriate Legal Notices"          ',&
'to the extent that it includes a convenient and prominently visible           ',&
'feature that (1) displays an appropriate copyright notice, and (2)            ',&
'tells the user that there is no warranty for the work (except to the          ',&
'extent that warranties are provided), that licensees may convey the           ',&
'work under this License, and how to view a copy of this License.  If          ',&
'the interface presents a list of user commands or options, such as a          ',&
'menu, a prominent item in the list meets this criterion.                      ',&
'                                                                              ',&
'  1. Source Code.                                                             ',&
'                                                                              ',&
'  The "source code" for a work means the preferred form of the work           ',&
'for making modifications to it.  "Object code" means any non-source           ',&
'form of a work.                                                               ',&
'                                                                              ',&
'  A "Standard Interface" means an interface that either is an official        ',&
'standard defined by a recognized standards body, or, in the case of           ',&
'interfaces specified for a particular programming language, one that          ',&
'is widely used among developers working in that language.                     ',&
'                                                                              ',&
'  The "System Libraries" of an executable work include anything, other        ',&
'than the work as a whole, that (a) is included in the normal form of          ',&
'packaging a Major Component, but which is not part of that Major              ',&
'Component, and (b) serves only to enable use of the work with that            ',&
'Major Component, or to implement a Standard Interface for which an            ',&
'implementation is available to the public in source code form.  A             ',&
'"Major Component", in this context, means a major essential component         ',&
'(kernel, window system, and so on) of the specific operating system           ',&
'(if any) on which the executable work runs, or a compiler used to             ',&
'produce the work, or an object code interpreter used to run it.               ',&
'                                                                              ',&
'  The "Corresponding Source" for a work in object code form means all         ',&
'the source code needed to generate, install, and (for an executable           ',&
'work) run the object code and to modify the work, including scripts to        ',&
'control those activities.  However, it does not include the work''s           ',&
'System Libraries, or general-purpose tools or generally available free        ',&
'programs which are used unmodified in performing those activities but         ',&
'which are not part of the work.  For example, Corresponding Source            ',&
'includes interface definition files associated with source files for          ',&
'the work, and the source code for shared libraries and dynamically            ',&
'linked subprograms that the work is specifically designed to require,         ',&
'such as by intimate data communication or control flow between those          ',&
'subprograms and other parts of the work.                                      ',&
'                                                                              ',&
'  The Corresponding Source need not include anything that users               ',&
'can regenerate automatically from other parts of the Corresponding            ',&
'Source.                                                                       ',&
'                                                                              ',&
'  The Corresponding Source for a work in source code form is that             ',&
'same work.                                                                    ',&
'                                                                              ',&
'  2. Basic Permissions.                                                       ',&
'                                                                              ',&
'  All rights granted under this License are granted for the term of           ',&
'copyright on the Program, and are irrevocable provided the stated             ',&
'conditions are met.  This License explicitly affirms your unlimited           ',&
'permission to run the unmodified Program.  The output from running a          ',&
'covered work is covered by this License only if the output, given its         ',&
'content, constitutes a covered work.  This License acknowledges your          ',&
'rights of fair use or other equivalent, as provided by copyright law.         ',&
'                                                                              ',&
'  You may make, run and propagate covered works that you do not               ',&
'convey, without conditions so long as your license otherwise remains          ',&
'in force.  You may convey covered works to others for the sole purpose        ',&
'of having them make modifications exclusively for you, or provide you         ',&
'with facilities for running those works, provided that you comply with        ',&
'the terms of this License in conveying all material for which you do          ',&
'not control copyright.  Those thus making or running the covered works        ',&
'for you must do so exclusively on your behalf, under your direction           ',&
'and control, on terms that prohibit them from making any copies of            ',&
'your copyrighted material outside their relationship with you.                ',&
'                                                                              ',&
'  Conveying under any other circumstances is permitted solely under           ',&
'the conditions stated below.  Sublicensing is not allowed; section 10         ',&
'makes it unnecessary.                                                         ',&
'                                                                              ',&
'  3. Protecting Users'' Legal Rights From Anti-Circumvention Law.             ',&
'                                                                              ',&
'  No covered work shall be deemed part of an effective technological          ',&
'measure under any applicable law fulfilling obligations under article         ',&
'11 of the WIPO copyright treaty adopted on 20 December 1996, or               ',&
'similar laws prohibiting or restricting circumvention of such                 ',&
'measures.                                                                     ',&
'                                                                              ',&
'  When you convey a covered work, you waive any legal power to forbid         ',&
'circumvention of technological measures to the extent such circumvention      ',&
'is effected by exercising rights under this License with respect to           ',&
'the covered work, and you disclaim any intention to limit operation or        ',&
'modification of the work as a means of enforcing, against the work''s         ',&
'users, your or third parties'' legal rights to forbid circumvention of        ',&
'technological measures.                                                       ',&
'                                                                              ',&
'  4. Conveying Verbatim Copies.                                               ',&
'                                                                              ',&
'  You may convey verbatim copies of the Program''s source code as you         ',&
'receive it, in any medium, provided that you conspicuously and                ',&
'appropriately publish on each copy an appropriate copyright notice;           ',&
'keep intact all notices stating that this License and any                     ',&
'non-permissive terms added in accord with section 7 apply to the code;        ',&
'keep intact all notices of the absence of any warranty; and give all          ',&
'recipients a copy of this License along with the Program.                     ',&
'                                                                              ',&
'  You may charge any price or no price for each copy that you convey,         ',&
'and you may offer support or warranty protection for a fee.                   ',&
'                                                                              ',&
'  5. Conveying Modified Source Versions.                                      ',&
'                                                                              ',&
'  You may convey a work based on the Program, or the modifications to         ',&
'produce it from the Program, in the form of source code under the             ',&
'terms of section 4, provided that you also meet all of these conditions:      ',&
'                                                                              ',&
'    a) The work must carry prominent notices stating that you modified        ',&
'    it, and giving a relevant date.                                           ',&
'                                                                              ',&
'    b) The work must carry prominent notices stating that it is               ',&
'    released under this License and any conditions added under section        ',&
'    7.  This requirement modifies the requirement in section 4 to             ',&
'    "keep intact all notices".                                                ',&
'                                                                              ',&
'    c) You must license the entire work, as a whole, under this               ',&
'    License to anyone who comes into possession of a copy.  This              ',&
'    License will therefore apply, along with any applicable section 7         ',&
'    additional terms, to the whole of the work, and all its parts,            ',&
'    regardless of how they are packaged.  This License gives no               ',&
'    permission to license the work in any other way, but it does not          ',&
'    invalidate such permission if you have separately received it.            ',&
'                                                                              ',&
'    d) If the work has interactive user interfaces, each must display         ',&
'    Appropriate Legal Notices; however, if the Program has interactive        ',&
'    interfaces that do not display Appropriate Legal Notices, your            ',&
'    work need not make them do so.                                            ',&
'                                                                              ',&
'  A compilation of a covered work with other separate and independent         ',&
'works, which are not by their nature extensions of the covered work,          ',&
'and which are not combined with it such as to form a larger program,          ',&
'in or on a volume of a storage or distribution medium, is called an           ',&
'"aggregate" if the compilation and its resulting copyright are not            ',&
'used to limit the access or legal rights of the compilation''s users          ',&
'beyond what the individual works permit.  Inclusion of a covered work         ',&
'in an aggregate does not cause this License to apply to the other             ',&
'parts of the aggregate.                                                       ',&
'                                                                              ',&
'  6. Conveying Non-Source Forms.                                              ',&
'                                                                              ',&
'  You may convey a covered work in object code form under the terms           ',&
'of sections 4 and 5, provided that you also convey the                        ',&
'machine-readable Corresponding Source under the terms of this License,        ',&
'in one of these ways:                                                         ',&
'                                                                              ',&
'    a) Convey the object code in, or embodied in, a physical product          ',&
'    (including a physical distribution medium), accompanied by the            ',&
'    Corresponding Source fixed on a durable physical medium                   ',&
'    customarily used for software interchange.                                ',&
'                                                                              ',&
'    b) Convey the object code in, or embodied in, a physical product          ',&
'    (including a physical distribution medium), accompanied by a              ',&
'    written offer, valid for at least three years and valid for as            ',&
'    long as you offer spare parts or customer support for that product        ',&
'    model, to give anyone who possesses the object code either (1) a          ',&
'    copy of the Corresponding Source for all the software in the              ',&
'    product that is covered by this License, on a durable physical            ',&
'    medium customarily used for software interchange, for a price no          ',&
'    more than your reasonable cost of physically performing this              ',&
'    conveying of source, or (2) access to copy the                            ',&
'    Corresponding Source from a network server at no charge.                  ',&
'                                                                              ',&
'    c) Convey individual copies of the object code with a copy of the         ',&
'    written offer to provide the Corresponding Source.  This                  ',&
'    alternative is allowed only occasionally and noncommercially, and         ',&
'    only if you received the object code with such an offer, in accord        ',&
'    with subsection 6b.                                                       ',&
'                                                                              ',&
'    d) Convey the object code by offering access from a designated            ',&
'    place (gratis or for a charge), and offer equivalent access to the        ',&
'    Corresponding Source in the same way through the same place at no         ',&
'    further charge.  You need not require recipients to copy the              ',&
'    Corresponding Source along with the object code.  If the place to         ',&
'    copy the object code is a network server, the Corresponding Source        ',&
'    may be on a different server (operated by you or a third party)           ',&
'    that supports equivalent copying facilities, provided you maintain        ',&
'    clear directions next to the object code saying where to find the         ',&
'    Corresponding Source.  Regardless of what server hosts the                ',&
'    Corresponding Source, you remain obligated to ensure that it is           ',&
'    available for as long as needed to satisfy these requirements.            ',&
'                                                                              ',&
'    e) Convey the object code using peer-to-peer transmission, provided       ',&
'    you inform other peers where the object code and Corresponding            ',&
'    Source of the work are being offered to the general public at no          ',&
'    charge under subsection 6d.                                               ',&
'                                                                              ',&
'  A separable portion of the object code, whose source code is excluded       ',&
'from the Corresponding Source as a System Library, need not be                ',&
'included in conveying the object code work.                                   ',&
'                                                                              ',&
'  A "User Product" is either (1) a "consumer product", which means any        ',&
'tangible personal property which is normally used for personal, family,       ',&
'or household purposes, or (2) anything designed or sold for incorporation     ',&
'into a dwelling.  In determining whether a product is a consumer product,     ',&
'doubtful cases shall be resolved in favor of coverage.  For a particular      ',&
'product received by a particular user, "normally used" refers to a            ',&
'typical or common use of that class of product, regardless of the status      ',&
'of the particular user or of the way in which the particular user             ',&
'actually uses, or expects or is expected to use, the product.  A product      ',&
'is a consumer product regardless of whether the product has substantial       ',&
'commercial, industrial or non-consumer uses, unless such uses represent       ',&
'the only significant mode of use of the product.                              ',&
'                                                                              ',&
'  "Installation Information" for a User Product means any methods,            ',&
'procedures, authorization keys, or other information required to install      ',&
'and execute modified versions of a covered work in that User Product from     ',&
'a modified version of its Corresponding Source.  The information must         ',&
'suffice to ensure that the continued functioning of the modified object       ',&
'code is in no case prevented or interfered with solely because                ',&
'modification has been made.                                                   ',&
'                                                                              ',&
'  If you convey an object code work under this section in, or with, or        ',&
'specifically for use in, a User Product, and the conveying occurs as          ',&
'part of a transaction in which the right of possession and use of the         ',&
'User Product is transferred to the recipient in perpetuity or for a           ',&
'fixed term (regardless of how the transaction is characterized), the          ',&
'Corresponding Source conveyed under this section must be accompanied          ',&
'by the Installation Information.  But this requirement does not apply         ',&
'if neither you nor any third party retains the ability to install             ',&
'modified object code on the User Product (for example, the work has           ',&
'been installed in ROM).                                                       ',&
'                                                                              ',&
'  The requirement to provide Installation Information does not include a      ',&
'requirement to continue to provide support service, warranty, or updates      ',&
'for a work that has been modified or installed by the recipient, or for       ',&
'the User Product in which it has been modified or installed.  Access to a     ',&
'network may be denied when the modification itself materially and             ',&
'adversely affects the operation of the network or violates the rules and      ',&
'protocols for communication across the network.                               ',&
'                                                                              ',&
'  Corresponding Source conveyed, and Installation Information provided,       ',&
'in accord with this section must be in a format that is publicly              ',&
'documented (and with an implementation available to the public in             ',&
'source code form), and must require no special password or key for            ',&
'unpacking, reading or copying.                                                ',&
'                                                                              ',&
'  7. Additional Terms.                                                        ',&
'                                                                              ',&
'  "Additional permissions" are terms that supplement the terms of this        ',&
'License by making exceptions from one or more of its conditions.              ',&
'Additional permissions that are applicable to the entire Program shall        ',&
'be treated as though they were included in this License, to the extent        ',&
'that they are valid under applicable law.  If additional permissions          ',&
'apply only to part of the Program, that part may be used separately           ',&
'under those permissions, but the entire Program remains governed by           ',&
'this License without regard to the additional permissions.                    ',&
'                                                                              ',&
'  When you convey a copy of a covered work, you may at your option            ',&
'remove any additional permissions from that copy, or from any part of         ',&
'it.  (Additional permissions may be written to require their own              ',&
'removal in certain cases when you modify the work.)  You may place            ',&
'additional permissions on material, added by you to a covered work,           ',&
'for which you have or can give appropriate copyright permission.              ',&
'                                                                              ',&
'  Notwithstanding any other provision of this License, for material you       ',&
'add to a covered work, you may (if authorized by the copyright holders of     ',&
'that material) supplement the terms of this License with terms:               ',&
'                                                                              ',&
'    a) Disclaiming warranty or limiting liability differently from the        ',&
'    terms of sections 15 and 16 of this License; or                           ',&
'                                                                              ',&
'    b) Requiring preservation of specified reasonable legal notices or        ',&
'    author attributions in that material or in the Appropriate Legal          ',&
'    Notices displayed by works containing it; or                              ',&
'                                                                              ',&
'    c) Prohibiting misrepresentation of the origin of that material, or       ',&
'    requiring that modified versions of such material be marked in            ',&
'    reasonable ways as different from the original version; or                ',&
'                                                                              ',&
'    d) Limiting the use for publicity purposes of names of licensors or       ',&
'    authors of the material; or                                               ',&
'                                                                              ',&
'    e) Declining to grant rights under trademark law for use of some          ',&
'    trade names, trademarks, or service marks; or                             ',&
'                                                                              ',&
'    f) Requiring indemnification of licensors and authors of that             ',&
'    material by anyone who conveys the material (or modified versions of      ',&
'    it) with contractual assumptions of liability to the recipient, for       ',&
'    any liability that these contractual assumptions directly impose on       ',&
'    those licensors and authors.                                              ',&
'                                                                              ',&
'  All other non-permissive additional terms are considered "further           ',&
'restrictions" within the meaning of section 10.  If the Program as you        ',&
'received it, or any part of it, contains a notice stating that it is          ',&
'governed by this License along with a term that is a further                  ',&
'restriction, you may remove that term.  If a license document contains        ',&
'a further restriction but permits relicensing or conveying under this         ',&
'License, you may add to a covered work material governed by the terms         ',&
'of that license document, provided that the further restriction does          ',&
'not survive such relicensing or conveying.                                    ',&
'                                                                              ',&
'  If you add terms to a covered work in accord with this section, you         ',&
'must place, in the relevant source files, a statement of the                  ',&
'additional terms that apply to those files, or a notice indicating            ',&
'where to find the applicable terms.                                           ',&
'                                                                              ',&
'  Additional terms, permissive or non-permissive, may be stated in the        ',&
'form of a separately written license, or stated as exceptions;                ',&
'the above requirements apply either way.                                      ',&
'                                                                              ',&
'  8. Termination.                                                             ',&
'                                                                              ',&
'  You may not propagate or modify a covered work except as expressly          ',&
'provided under this License.  Any attempt otherwise to propagate or           ',&
'modify it is void, and will automatically terminate your rights under         ',&
'this License (including any patent licenses granted under the third           ',&
'paragraph of section 11).                                                     ',&
'                                                                              ',&
'  However, if you cease all violation of this License, then your              ',&
'license from a particular copyright holder is reinstated (a)                  ',&
'provisionally, unless and until the copyright holder explicitly and           ',&
'finally terminates your license, and (b) permanently, if the copyright        ',&
'holder fails to notify you of the violation by some reasonable means          ',&
'prior to 60 days after the cessation.                                         ',&
'                                                                              ',&
'  Moreover, your license from a particular copyright holder is                ',&
'reinstated permanently if the copyright holder notifies you of the            ',&
'violation by some reasonable means, this is the first time you have           ',&
'received notice of violation of this License (for any work) from that         ',&
'copyright holder, and you cure the violation prior to 30 days after           ',&
'your receipt of the notice.                                                   ',&
'                                                                              ',&
'  Termination of your rights under this section does not terminate the        ',&
'licenses of parties who have received copies or rights from you under         ',&
'this License.  If your rights have been terminated and not permanently        ',&
'reinstated, you do not qualify to receive new licenses for the same           ',&
'material under section 10.                                                    ',&
'                                                                              ',&
'  9. Acceptance Not Required for Having Copies.                               ',&
'                                                                              ',&
'  You are not required to accept this License in order to receive or          ',&
'run a copy of the Program.  Ancillary propagation of a covered work           ',&
'occurring solely as a consequence of using peer-to-peer transmission          ',&
'to receive a copy likewise does not require acceptance.  However,             ',&
'nothing other than this License grants you permission to propagate or         ',&
'modify any covered work.  These actions infringe copyright if you do          ',&
'not accept this License.  Therefore, by modifying or propagating a            ',&
'covered work, you indicate your acceptance of this License to do so.          ',&
'                                                                              ',&
'  10. Automatic Licensing of Downstream Recipients.                           ',&
'                                                                              ',&
'  Each time you convey a covered work, the recipient automatically            ',&
'receives a license from the original licensors, to run, modify and            ',&
'propagate that work, subject to this License.  You are not responsible        ',&
'for enforcing compliance by third parties with this License.                  ',&
'                                                                              ',&
'  An "entity transaction" is a transaction transferring control of an         ',&
'organization, or substantially all assets of one, or subdividing an           ',&
'organization, or merging organizations.  If propagation of a covered          ',&
'work results from an entity transaction, each party to that                   ',&
'transaction who receives a copy of the work also receives whatever            ',&
'licenses to the work the party''s predecessor in interest had or could        ',&
'give under the previous paragraph, plus a right to possession of the          ',&
'Corresponding Source of the work from the predecessor in interest, if         ',&
'the predecessor has it or can get it with reasonable efforts.                 ',&
'                                                                              ',&
'  You may not impose any further restrictions on the exercise of the          ',&
'rights granted or affirmed under this License.  For example, you may          ',&
'not impose a license fee, royalty, or other charge for exercise of            ',&
'rights granted under this License, and you may not initiate litigation        ',&
'(including a cross-claim or counterclaim in a lawsuit) alleging that          ',&
'any patent claim is infringed by making, using, selling, offering for         ',&
'sale, or importing the Program or any portion of it.                          ',&
'                                                                              ',&
'  11. Patents.                                                                ',&
'                                                                              ',&
'  A "contributor" is a copyright holder who authorizes use under this         ',&
'License of the Program or a work on which the Program is based.  The          ',&
'work thus licensed is called the contributor''s "contributor version".        ',&
'                                                                              ',&
'  A contributor''s "essential patent claims" are all patent claims            ',&
'owned or controlled by the contributor, whether already acquired or           ',&
'hereafter acquired, that would be infringed by some manner, permitted         ',&
'by this License, of making, using, or selling its contributor version,        ',&
'but do not include claims that would be infringed only as a                   ',&
'consequence of further modification of the contributor version.  For          ',&
'purposes of this definition, "control" includes the right to grant            ',&
'patent sublicenses in a manner consistent with the requirements of            ',&
'this License.                                                                 ',&
'                                                                              ',&
'  Each contributor grants you a non-exclusive, worldwide, royalty-free        ',&
'patent license under the contributor''s essential patent claims, to           ',&
'make, use, sell, offer for sale, import and otherwise run, modify and         ',&
'propagate the contents of its contributor version.                            ',&
'                                                                              ',&
'  In the following three paragraphs, a "patent license" is any express        ',&
'agreement or commitment, however denominated, not to enforce a patent         ',&
'(such as an express permission to practice a patent or covenant not to        ',&
'sue for patent infringement).  To "grant" such a patent license to a          ',&
'party means to make such an agreement or commitment not to enforce a          ',&
'patent against the party.                                                     ',&
'                                                                              ',&
'  If you convey a covered work, knowingly relying on a patent license,        ',&
'and the Corresponding Source of the work is not available for anyone          ',&
'to copy, free of charge and under the terms of this License, through a        ',&
'publicly available network server or other readily accessible means,          ',&
'then you must either (1) cause the Corresponding Source to be so              ',&
'available, or (2) arrange to deprive yourself of the benefit of the           ',&
'patent license for this particular work, or (3) arrange, in a manner          ',&
'consistent with the requirements of this License, to extend the patent        ',&
'license to downstream recipients.  "Knowingly relying" means you have         ',&
'actual knowledge that, but for the patent license, your conveying the         ',&
'covered work in a country, or your recipient''s use of the covered work       ',&
'in a country, would infringe one or more identifiable patents in that         ',&
'country that you have reason to believe are valid.                            ',&
'                                                                              ',&
'  If, pursuant to or in connection with a single transaction or               ',&
'arrangement, you convey, or propagate by procuring conveyance of, a           ',&
'covered work, and grant a patent license to some of the parties               ',&
'receiving the covered work authorizing them to use, propagate, modify         ',&
'or convey a specific copy of the covered work, then the patent license        ',&
'you grant is automatically extended to all recipients of the covered          ',&
'work and works based on it.                                                   ',&
'                                                                              ',&
'  A patent license is "discriminatory" if it does not include within          ',&
'the scope of its coverage, prohibits the exercise of, or is                   ',&
'conditioned on the non-exercise of one or more of the rights that are         ',&
'specifically granted under this License.  You may not convey a covered        ',&
'work if you are a party to an arrangement with a third party that is          ',&
'in the business of distributing software, under which you make payment        ',&
'to the third party based on the extent of your activity of conveying          ',&
'the work, and under which the third party grants, to any of the               ',&
'parties who would receive the covered work from you, a discriminatory         ',&
'patent license (a) in connection with copies of the covered work              ',&
'conveyed by you (or copies made from those copies), or (b) primarily          ',&
'for and in connection with specific products or compilations that             ',&
'contain the covered work, unless you entered into that arrangement,           ',&
'or that patent license was granted, prior to 28 March 2007.                   ',&
'                                                                              ',&
'  Nothing in this License shall be construed as excluding or limiting         ',&
'any implied license or other defenses to infringement that may                ',&
'otherwise be available to you under applicable patent law.                    ',&
'                                                                              ',&
'  12. No Surrender of Others'' Freedom.                                       ',&
'                                                                              ',&
'  If conditions are imposed on you (whether by court order, agreement or      ',&
'otherwise) that contradict the conditions of this License, they do not        ',&
'excuse you from the conditions of this License.  If you cannot convey a       ',&
'covered work so as to satisfy simultaneously your obligations under this      ',&
'License and any other pertinent obligations, then as a consequence you may    ',&
'not convey it at all.  For example, if you agree to terms that obligate you   ',&
'to collect a royalty for further conveying from those to whom you convey      ',&
'the Program, the only way you could satisfy both those terms and this         ',&
'License would be to refrain entirely from conveying the Program.              ',&
'                                                                              ',&
'  13. Remote Network Interaction; Use with the GNU General Public License.    ',&
'                                                                              ',&
'  Notwithstanding any other provision of this License, if you modify the      ',&
'Program, your modified version must prominently offer all users               ',&
'interacting with it remotely through a computer network (if your version      ',&
'supports such interaction) an opportunity to receive the Corresponding        ',&
'Source of your version by providing access to the Corresponding Source        ',&
'from a network server at no charge, through some standard or customary        ',&
'means of facilitating copying of software.  This Corresponding Source         ',&
'shall include the Corresponding Source for any work covered by version 3      ',&
'of the GNU General Public License that is incorporated pursuant to the        ',&
'following paragraph.                                                          ',&
'                                                                              ',&
'  Notwithstanding any other provision of this License, you have               ',&
'permission to link or combine any covered work with a work licensed           ',&
'under version 3 of the GNU General Public License into a single               ',&
'combined work, and to convey the resulting work.  The terms of this           ',&
'License will continue to apply to the part which is the covered work,         ',&
'but the work with which it is combined will remain governed by version        ',&
'3 of the GNU General Public License.                                          ',&
'                                                                              ',&
'  14. Revised Versions of this License.                                       ',&
'                                                                              ',&
'  The Free Software Foundation may publish revised and/or new versions of     ',&
'the GNU Affero General Public License from time to time.  Such new versions   ',&
'will be similar in spirit to the present version, but may differ in detail to ',&
'address new problems or concerns.                                             ',&
'                                                                              ',&
'  Each version is given a distinguishing version number.  If the              ',&
'Program specifies that a certain numbered version of the GNU Affero General   ',&
'Public License "or any later version" applies to it, you have the             ',&
'option of following the terms and conditions either of that numbered          ',&
'version or of any later version published by the Free Software                ',&
'Foundation.  If the Program does not specify a version number of the          ',&
'GNU Affero General Public License, you may choose any version ever published  ',&
'by the Free Software Foundation.                                              ',&
'                                                                              ',&
'  If the Program specifies that a proxy can decide which future               ',&
'versions of the GNU Affero General Public License can be used, that proxy''s  ',&
'public statement of acceptance of a version permanently authorizes you        ',&
'to choose that version for the Program.                                       ',&
'                                                                              ',&
'  Later license versions may give you additional or different                 ',&
'permissions.  However, no additional obligations are imposed on any           ',&
'author or copyright holder as a result of your choosing to follow a           ',&
'later version.                                                                ',&
'                                                                              ',&
'  15. Disclaimer of Warranty.                                                 ',&
'                                                                              ',&
'  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY            ',&
'APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT        ',&
'HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY     ',&
'OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,      ',&
'THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR        ',&
'PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM    ',&
'IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF      ',&
'ALL NECESSARY SERVICING, REPAIR OR CORRECTION.                                ',&
'                                                                              ',&
'  16. Limitation of Liability.                                                ',&
'                                                                              ',&
'  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING       ',&
'WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS     ',&
'THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY   ',&
'GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE      ',&
'USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF     ',&
'DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD    ',&
'PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),      ',&
'EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF     ',&
'SUCH DAMAGES.                                                                 ',&
'                                                                              ',&
'  17. Interpretation of Sections 15 and 16.                                   ',&
'                                                                              ',&
'  If the disclaimer of warranty and limitation of liability provided          ',&
'above cannot be given local legal effect according to their terms,            ',&
'reviewing courts shall apply local law that most closely approximates         ',&
'an absolute waiver of all civil liability in connection with the              ',&
'Program, unless a warranty or assumption of liability accompanies a           ',&
'copy of the Program in return for a fee.                                      ',&
'                                                                              ',&
'                     END OF TERMS AND CONDITIONS                              ',&
'                                                                              ',&
'            How to Apply These Terms to Your New Programs                     ',&
'                                                                              ',&
'  If you develop a new program, and you want it to be of the greatest         ',&
'possible use to the public, the best way to achieve this is to make it        ',&
'free software which everyone can redistribute and change under these terms.   ',&
'                                                                              ',&
'  To do so, attach the following notices to the program.  It is safest        ',&
'to attach them to the start of each source file to most effectively           ',&
'state the exclusion of warranty; and each file should have at least           ',&
'the "copyright" line and a pointer to where the full notice is found.         ',&
'                                                                              ',&
'    <one line to give the program''s name and a brief idea of what it does.>  ',&
'    Copyright (C) @YEAR@  @NAME_OF_AUTHOR@                                    ',&
'                                                                              ',&
'    This program is free software: you can redistribute it and/or modify      ',&
'    it under the terms of the GNU Affero General Public License as published  ',&
'    by the Free Software Foundation, either version 3 of the License, or      ',&
'    (at your option) any later version.                                       ',&
'                                                                              ',&
'    This program is distributed in the hope that it will be useful,           ',&
'    but WITHOUT ANY WARRANTY; without even the implied warranty of            ',&
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             ',&
'    GNU Affero General Public License for more details.                       ',&
'                                                                              ',&
'    You should have received a copy of the GNU Affero General Public License  ',&
'    along with this program.  If not, see <https://www.gnu.org/licenses/>.    ',&
'                                                                              ',&
'Also add information on how to contact you by electronic and paper mail.      ',&
'                                                                              ',&
'  If your software can interact with users remotely through a computer        ',&
'network, you should also make sure that it provides a way for users to        ',&
'get its source.  For example, if your program is a web application, its       ',&
'interface could display a "Source" link that leads users to an archive        ',&
'of the code.  There are many ways you could offer source, and different       ',&
'solutions will be better for different programs; see section 13 for the       ',&
'specific requirements.                                                        ',&
'                                                                              ',&
'  You should also get your employer (if you work as a programmer) or school,  ',&
'if any, to sign a "copyright disclaimer" for the program, if necessary.       ',&
'For more information on this, and how to apply and follow the GNU AGPL, see   ',&
'<https://www.gnu.org/licenses/>.                                              ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('4','apache-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'apache-2.0',&
'          ',&
'          ',&
'                                 Apache License',&
'                           Version 2.0, January 2004',&
'                        http://www.apache.org/licenses/',&
'                                                       ',&
'   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION',&
'                                                               ',&
'   1. Definitions.                                             ',&
'                                                               ',&
'      "License" shall mean the terms and conditions for use, reproduction,',&
'      and distribution as defined by Sections 1 through 9 of this document.',&
'                                                                           ',&
'      "Licensor" shall mean the copyright owner or entity authorized by    ',&
'      the copyright owner that is granting the License.                    ',&
'                                                                           ',&
'      "Legal Entity" shall mean the union of the acting entity and all     ',&
'      other entities that control, are controlled by, or are under common  ',&
'      control with that entity. For the purposes of this definition,       ',&
'      "control" means (i) the power, direct or indirect, to cause the      ',&
'      direction or management of such entity, whether by contract or       ',&
'      otherwise, or (ii) ownership of fifty percent (50%) or more of the   ',&
'      outstanding shares, or (iii) beneficial ownership of such entity.    ',&
'                                                                           ',&
'      "You" (or "Your") shall mean an individual or Legal Entity           ',&
'      exercising permissions granted by this License.                      ',&
'                                                                           ',&
'      "Source" form shall mean the preferred form for making modifications,',&
'      including but not limited to software source code, documentation     ',&
'      source, and configuration files.                                     ',&
'                                                                           ',&
'      "Object" form shall mean any form resulting from mechanical          ',&
'      transformation or translation of a Source form, including but        ',&
'      not limited to compiled object code, generated documentation,        ',&
'      and conversions to other media types.                                ',&
'                                                                           ',&
'      "Work" shall mean the work of authorship, whether in Source or       ',&
'      Object form, made available under the License, as indicated by a     ',&
'      copyright notice that is included in or attached to the work         ',&
'      (an example is provided in the Appendix below).                      ',&
'                                                                           ',&
'      "Derivative Works" shall mean any work, whether in Source or Object  ',&
'      form, that is based on (or derived from) the Work and for which the  ',&
'      editorial revisions, annotations, elaborations, or other modifications',&
'      represent, as a whole, an original work of authorship. For the purposes',&
'      of this License, Derivative Works shall not include works that remain  ',&
'      separable from, or merely link (or bind by name) to the interfaces of, ',&
'      the Work and Derivative Works thereof.                                 ',&
'                                                                             ',&
'      "Contribution" shall mean any work of authorship, including            ',&
'      the original version of the Work and any modifications or additions    ',&
'      to that Work or Derivative Works thereof, that is intentionally        ',&
'      submitted to Licensor for inclusion in the Work by the copyright owner ',&
'      or by an individual or Legal Entity authorized to submit on behalf of  ',&
'      the copyright owner. For the purposes of this definition, "submitted"  ',&
'      means any form of electronic, verbal, or written communication sent    ',&
'      to the Licensor or its representatives, including but not limited to   ',&
'      communication on electronic mailing lists, source code control systems,',&
'      and issue tracking systems that are managed by, or on behalf of, the   ',&
'      Licensor for the purpose of discussing and improving the Work, but     ',&
'      excluding communication that is conspicuously marked or otherwise      ',&
'      designated in writing by the copyright owner as "Not a Contribution."  ',&
'                                                                             ',&
'      "Contributor" shall mean Licensor and any individual or Legal Entity   ',&
'      on behalf of whom a Contribution has been received by Licensor and     ',&
'      subsequently incorporated within the Work.                             ',&
'                                                                             ',&
'   2. Grant of Copyright License. Subject to the terms and conditions of     ',&
'      this License, each Contributor hereby grants to You a perpetual,       ',&
'      worldwide, non-exclusive, no-charge, royalty-free, irrevocable         ',&
'      copyright license to reproduce, prepare Derivative Works of,           ',&
'      publicly display, publicly perform, sublicense, and distribute the     ',&
'      Work and such Derivative Works in Source or Object form.               ',&
'                                                                             ',&
'   3. Grant of Patent License. Subject to the terms and conditions of        ',&
'      this License, each Contributor hereby grants to You a perpetual,       ',&
'      worldwide, non-exclusive, no-charge, royalty-free, irrevocable         ',&
'      (except as stated in this section) patent license to make, have made,  ',&
'      use, offer to sell, sell, import, and otherwise transfer the Work,     ',&
'      where such license applies only to those patent claims licensable      ',&
'      by such Contributor that are necessarily infringed by their            ',&
'      Contribution(s) alone or by combination of their Contribution(s)       ',&
'      with the Work to which such Contribution(s) was submitted. If You      ',&
'      institute patent litigation against any entity (including a            ',&
'      cross-claim or counterclaim in a lawsuit) alleging that the Work       ',&
'      or a Contribution incorporated within the Work constitutes direct      ',&
'      or contributory patent infringement, then any patent licenses          ',&
'      granted to You under this License for that Work shall terminate        ',&
'      as of the date such litigation is filed.                               ',&
'                                                                             ',&
'   4. Redistribution. You may reproduce and distribute copies of the         ',&
'      Work or Derivative Works thereof in any medium, with or without        ',&
'      modifications, and in Source or Object form, provided that You         ',&
'      meet the following conditions:                                         ',&
'                                                                             ',&
'      (a) You must give any other recipients of the Work or                  ',&
'          Derivative Works a copy of this License; and                       ',&
'                                                                             ',&
'      (b) You must cause any modified files to carry prominent notices       ',&
'          stating that You changed the files; and                            ',&
'                                                                             ',&
'      (c) You must retain, in the Source form of any Derivative Works        ',&
'          that You distribute, all copyright, patent, trademark, and         ',&
'          attribution notices from the Source form of the Work,              ',&
'          excluding those notices that do not pertain to any part of         ',&
'          the Derivative Works; and                                          ',&
'                                                                             ',&
'      (d) If the Work includes a "NOTICE" text file as part of its           ',&
'          distribution, then any Derivative Works that You distribute must   ',&
'          include a readable copy of the attribution notices contained       ',&
'          within such NOTICE file, excluding those notices that do not       ',&
'          pertain to any part of the Derivative Works, in at least one       ',&
'          of the following places: within a NOTICE text file distributed     ',&
'          as part of the Derivative Works; within the Source form or         ',&
'          documentation, if provided along with the Derivative Works; or,    ',&
'          within a display generated by the Derivative Works, if and         ',&
'          wherever such third-party notices normally appear. The contents    ',&
'          of the NOTICE file are for informational purposes only and         ',&
'          do not modify the License. You may add Your own attribution        ',&
'          notices within Derivative Works that You distribute, alongside     ',&
'          or as an addendum to the NOTICE text from the Work, provided       ',&
'          that such additional attribution notices cannot be construed       ',&
'          as modifying the License.                                          ',&
'                                                                             ',&
'      You may add Your own copyright statement to Your modifications and     ',&
'      may provide additional or different license terms and conditions       ',&
'      for use, reproduction, or distribution of Your modifications, or       ',&
'      for any such Derivative Works as a whole, provided Your use,           ',&
'      reproduction, and distribution of the Work otherwise complies with     ',&
'      the conditions stated in this License.                                 ',&
'                                                                             ',&
'   5. Submission of Contributions. Unless You explicitly state otherwise,    ',&
'      any Contribution intentionally submitted for inclusion in the Work     ',&
'      by You to the Licensor shall be under the terms and conditions of      ',&
'      this License, without any additional terms or conditions.              ',&
'      Notwithstanding the above, nothing herein shall supersede or modify    ',&
'      the terms of any separate license agreement you may have executed      ',&
'      with Licensor regarding such Contributions.                            ',&
'                                                                             ',&
'   6. Trademarks. This License does not grant permission to use the trade    ',&
'      names, trademarks, service marks, or product names of the Licensor,    ',&
'      except as required for reasonable and customary use in describing the  ',&
'      origin of the Work and reproducing the content of the NOTICE file.     ',&
'                                                                             ',&
'   7. Disclaimer of Warranty. Unless required by applicable law or           ',&
'      agreed to in writing, Licensor provides the Work (and each             ',&
'      Contributor provides its Contributions) on an "AS IS" BASIS,           ',&
'      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        ',&
'      implied, including, without limitation, any warranties or conditions   ',&
'      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A          ',&
'      PARTICULAR PURPOSE. You are solely responsible for determining the     ',&
'      appropriateness of using or redistributing the Work and assume any     ',&
'      risks associated with Your exercise of permissions under this License. ',&
'                                                                             ',&
'   8. Limitation of Liability. In no event and under no legal theory,        ',&
'      whether in tort (including negligence), contract, or otherwise,        ',&
'      unless required by applicable law (such as deliberate and grossly      ',&
'      negligent acts) or agreed to in writing, shall any Contributor be      ',&
'      liable to You for damages, including any direct, indirect, special,    ',&
'      incidental, or consequential damages of any character arising as a     ',&
'      result of this License or out of the use or inability to use the       ',&
'      Work (including but not limited to damages for loss of goodwill,       ',&
'      work stoppage, computer failure or malfunction, or any and all         ',&
'      other commercial damages or losses), even if such Contributor          ',&
'      has been advised of the possibility of such damages.                   ',&
'                                                                             ',&
'   9. Accepting Warranty or Additional Liability. While redistributing       ',&
'      the Work or Derivative Works thereof, You may choose to offer,         ',&
'      and charge a fee for, acceptance of support, warranty, indemnity,      ',&
'      or other liability obligations and/or rights consistent with this      ',&
'      License. However, in accepting such obligations, You may act only      ',&
'      on Your own behalf and on Your sole responsibility, not on behalf      ',&
'      of any other Contributor, and only if You agree to indemnify,          ',&
'      defend, and hold each Contributor harmless for any liability           ',&
'      incurred by, or claims asserted against, such Contributor by reason    ',&
'      of your accepting any such warranty or additional liability.           ',&
'                                                                             ',&
'   END OF TERMS AND CONDITIONS                                               ',&
'                                                                             ',&
'   APPENDIX: How to apply the Apache License to your work.                   ',&
'                                                                             ',&
'      To apply the Apache License to your work, attach the following         ',&
'      boilerplate notice, with the fields enclosed by at signs "@"           ',&
'      replaced with your own identifying information. (Don''t include        ',&
'      the at signs!)  The text should be enclosed in the appropriate         ',&
'      comment syntax for the file format. We also recommend that a           ',&
'      file or class name and description of purpose be included on the       ',&
'      same "printed page" as the copyright notice for easier                 ',&
'      identification within third-party archives.                            ',&
'                                                                             ',&
'   Copyright @YEAR@ @name of copyright owner@                                ',&
'                                                                             ',&
'   Licensed under the Apache License, Version 2.0 (the "License");           ',&
'   you may not use this file except in compliance with the License.          ',&
'   You may obtain a copy of the License at                                   ',&
'                                                                             ',&
'       http://www.apache.org/licenses/LICENSE-2.0                            ',&
'                                                                             ',&
'   Unless required by applicable law or agreed to in writing, software       ',&
'   distributed under the License is distributed on an "AS IS" BASIS,         ',&
'   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  ',&
'   See the License for the specific language governing permissions and       ',&
'   limitations under the License.                                            ',&
'                                                                             ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('5','artistic-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'artistic-2.0',&
'            ',&
'                       The Artistic License 2.0',&
'                                               ',&
'            Copyright (c) 2000-2006, The Perl Foundation.',&
'                                                         ',&
'     Everyone is permitted to copy and distribute verbatim copies',&
'      of this license document, but changing it is not allowed.  ',&
'                                                                 ',&
'Preamble                                                         ',&
'                                                                 ',&
'This license establishes the terms under which a given free software',&
'Package may be copied, modified, distributed, and/or redistributed. ',&
'The intent is that the Copyright Holder maintains some artistic     ',&
'control over the development of that Package while still keeping the',&
'Package available as open source and free software.                 ',&
'                                                                    ',&
'You are always permitted to make arrangements wholly outside of this',&
'license directly with the Copyright Holder of a given Package.  If the',&
'terms of this license do not permit the full use that you propose to  ',&
'make of the Package, you should contact the Copyright Holder and seek ',&
'a different licensing arrangement.                                    ',&
'                                                                      ',&
'Definitions                                                           ',&
'                                                                      ',&
'    "Copyright Holder" means the individual(s) or organization(s)     ',&
'    named in the copyright notice for the entire Package.             ',&
'                                                                      ',&
'    "Contributor" means any party that has contributed code or other  ',&
'    material to the Package, in accordance with the Copyright Holder''s',&
'    procedures.                                                        ',&
'                                                                       ',&
'    "You" and "your" means any person who would like to copy,          ',&
'    distribute, or modify the Package.                                 ',&
'                                                                       ',&
'    "Package" means the collection of files distributed by the         ',&
'    Copyright Holder, and derivatives of that collection and/or of     ',&
'    those files. A given Package may consist of either the Standard    ',&
'    Version, or a Modified Version.                                    ',&
'                                                                       ',&
'    "Distribute" means providing a copy of the Package or making it    ',&
'    accessible to anyone else, or in the case of a company or          ',&
'    organization, to others outside of your company or organization.   ',&
'                                                                       ',&
'    "Distributor Fee" means any fee that you charge for Distributing   ',&
'    this Package or providing support for this Package to another      ',&
'    party.  It does not mean licensing fees.                           ',&
'                                                                       ',&
'    "Standard Version" refers to the Package if it has not been        ',&
'    modified, or has been modified only in ways explicitly requested   ',&
'    by the Copyright Holder.                                           ',&
'                                                                       ',&
'    "Modified Version" means the Package, if it has been changed, and  ',&
'    such changes were not explicitly requested by the Copyright        ',&
'    Holder.                                                            ',&
'                                                                       ',&
'    "Original License" means this Artistic License as Distributed with ',&
'    the Standard Version of the Package, in its current version or as  ',&
'    it may be modified by The Perl Foundation in the future.           ',&
'                                                                       ',&
'    "Source" form means the source code, documentation source, and     ',&
'    configuration files for the Package.                               ',&
'                                                                       ',&
'    "Compiled" form means the compiled bytecode, object code, binary,  ',&
'    or any other form resulting from mechanical transformation or      ',&
'    translation of the Source form.                                    ',&
'                                                                       ',&
'                                                                       ',&
'Permission for Use and Modification Without Distribution               ',&
'                                                                       ',&
'(1)  You are permitted to use the Standard Version and create and use  ',&
'Modified Versions for any purpose without restriction, provided that   ',&
'you do not Distribute the Modified Version.                            ',&
'                                                                       ',&
'                                                                       ',&
'Permissions for Redistribution of the Standard Version                 ',&
'                                                                       ',&
'(2)  You may Distribute verbatim copies of the Source form of the      ',&
'Standard Version of this Package in any medium without restriction,    ',&
'either gratis or for a Distributor Fee, provided that you duplicate    ',&
'all of the original copyright notices and associated disclaimers.  At  ',&
'your discretion, such verbatim copies may or may not include a         ',&
'Compiled form of the Package.                                          ',&
'                                                                       ',&
'(3)  You may apply any bug fixes, portability changes, and other       ',&
'modifications made available from the Copyright Holder.  The resulting ',&
'Package will still be considered the Standard Version, and as such     ',&
'will be subject to the Original License.                               ',&
'                                                                       ',&
'                                                                       ',&
'Distribution of Modified Versions of the Package as Source             ',&
'                                                                       ',&
'(4)  You may Distribute your Modified Version as Source (either gratis ',&
'or for a Distributor Fee, and with or without a Compiled form of the   ',&
'Modified Version) provided that you clearly document how it differs    ',&
'from the Standard Version, including, but not limited to, documenting  ',&
'any non-standard features, executables, or modules, and provided that  ',&
'you do at least ONE of the following:                                  ',&
'                                                                       ',&
'    (a)  make the Modified Version available to the Copyright Holder   ',&
'    of the Standard Version, under the Original License, so that the   ',&
'    Copyright Holder may include your modifications in the Standard    ',&
'    Version.                                                           ',&
'                                                                       ',&
'    (b)  ensure that installation of your Modified Version does not    ',&
'    prevent the user installing or running the Standard Version. In    ',&
'    addition, the Modified Version must bear a name that is different  ',&
'    from the name of the Standard Version.                             ',&
'                                                                       ',&
'    (c)  allow anyone who receives a copy of the Modified Version to   ',&
'    make the Source form of the Modified Version available to others   ',&
'    under                                                              ',&
'                                                                       ',&
'        (i)  the Original License or                                   ',&
'                                                                       ',&
'        (ii)  a license that permits the licensee to freely copy,      ',&
'        modify and redistribute the Modified Version using the same    ',&
'        licensing terms that apply to the copy that the licensee       ',&
'        received, and requires that the Source form of the Modified    ',&
'        Version, and of any works derived from it, be made freely      ',&
'        available in that license fees are prohibited but Distributor  ',&
'        Fees are allowed.                                              ',&
'                                                                       ',&
'                                                                       ',&
'Distribution of Compiled Forms of the Standard Version                 ',&
'or Modified Versions without the Source                                ',&
'                                                                       ',&
'(5)  You may Distribute Compiled forms of the Standard Version without ',&
'the Source, provided that you include complete instructions on how to  ',&
'get the Source of the Standard Version.  Such instructions must be     ',&
'valid at the time of your distribution.  If these instructions, at any ',&
'time while you are carrying out such distribution, become invalid, you ',&
'must provide new instructions on demand or cease further distribution. ',&
'If you provide valid instructions or cease distribution within thirty  ',&
'days after you become aware that the instructions are invalid, then    ',&
'you do not forfeit any of your rights under this license.              ',&
'                                                                       ',&
'(6)  You may Distribute a Modified Version in Compiled form without    ',&
'the Source, provided that you comply with Section 4 with respect to    ',&
'the Source of the Modified Version.                                    ',&
'                                                                       ',&
'                                                                       ',&
'Aggregating or Linking the Package                                     ',&
'                                                                       ',&
'(7)  You may aggregate the Package (either the Standard Version or     ',&
'Modified Version) with other packages and Distribute the resulting     ',&
'aggregation provided that you do not charge a licensing fee for the    ',&
'Package.  Distributor Fees are permitted, and licensing fees for other ',&
'components in the aggregation are permitted. The terms of this license ',&
'apply to the use and Distribution of the Standard or Modified Versions ',&
'as included in the aggregation.                                        ',&
'                                                                       ',&
'(8) You are permitted to link Modified and Standard Versions with      ',&
'other works, to embed the Package in a larger work of your own, or to  ',&
'build stand-alone binary or bytecode versions of applications that     ',&
'include the Package, and Distribute the result without restriction,    ',&
'provided the result does not expose a direct interface to the Package. ',&
'                                                                       ',&
'                                                                       ',&
'Items That are Not Considered Part of a Modified Version               ',&
'                                                                       ',&
'(9) Works (including, but not limited to, modules and scripts) that    ',&
'merely extend or make use of the Package, do not, by themselves, cause ',&
'the Package to be a Modified Version.  In addition, such works are not ',&
'considered parts of the Package itself, and are not subject to the     ',&
'terms of this license.                                                 ',&
'                                                                       ',&
'                                                                       ',&
'General Provisions                                                     ',&
'                                                                       ',&
'(10)  Any use, modification, and distribution of the Standard or       ',&
'Modified Versions is governed by this Artistic License. By using,      ',&
'modifying or distributing the Package, you accept this license. Do not ',&
'use, modify, or distribute the Package, if you do not accept this      ',&
'license.                                                               ',&
'                                                                       ',&
'(11)  If your Modified Version has been derived from a Modified        ',&
'Version made by someone other than you, you are nevertheless required  ',&
'to ensure that your Modified Version complies with the requirements of ',&
'this license.                                                          ',&
'                                                                       ',&
'(12)  This license does not grant you the right to use any trademark,  ',&
'service mark, tradename, or logo of the Copyright Holder.              ',&
'                                                                       ',&
'(13)  This license includes the non-exclusive, worldwide,              ',&
'free-of-charge patent license to make, have made, use, offer to sell,  ',&
'sell, import and otherwise transfer the Package with respect to any    ',&
'patent claims licensable by the Copyright Holder that are necessarily  ',&
'infringed by the Package. If you institute patent litigation           ',&
'(including a cross-claim or counterclaim) against any party alleging   ',&
'that the Package constitutes direct or contributory patent             ',&
'infringement, then this Artistic License to you shall terminate on the ',&
'date that such litigation is filed.                                    ',&
'                                                                       ',&
'(14)  Disclaimer of Warranty:                                          ',&
'THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS   ',&
'IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE IMPLIED        ',&
'WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR    ',&
'NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL  ',&
'LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL   ',&
'BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL       ',&
'DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THE PACKAGE, EVEN IF      ',&
'ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                             ',&
'                                                                       ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('6','blueoak-1.0.0')
textblock=[ CHARACTER(LEN=128) :: &
'blueoak-1.0.0',&
'             ',&
'# Blue Oak Model License',&
'                        ',&
'Version 1.0.0           ',&
'                        ',&
'## Purpose              ',&
'                        ',&
'This license gives everyone as much permission to work with',&
'this software as possible, while protecting contributors   ',&
'from liability.                                            ',&
'                                                           ',&
'## Acceptance                                              ',&
'                                                           ',&
'In order to receive this license, you must agree to its    ',&
'rules.  The rules of this license are both obligations     ',&
'under that agreement and conditions to your license.       ',&
'You must not do anything with this software that triggers  ',&
'a rule that you cannot or will not follow.                 ',&
'                                                           ',&
'## Copyright                                               ',&
'                                                           ',&
'Each contributor licenses you to do everything with this   ',&
'software that would otherwise infringe that contributor''s ',&
'copyright in it.                                           ',&
'                                                           ',&
'## Notices                                                 ',&
'                                                           ',&
'You must ensure that everyone who gets a copy of           ',&
'any part of this software from you, with or without        ',&
'changes, also gets the text of this license or a link to   ',&
'<https://blueoakcouncil.org/license/1.0.0>.                ',&
'                                                           ',&
'## Excuse                                                  ',&
'                                                           ',&
'If anyone notifies you in writing that you have not        ',&
'complied with [Notices](#notices), you can keep your       ',&
'license by taking all practical steps to comply within 30  ',&
'days after the notice.  If you do not do so, your license  ',&
'ends immediately.                                          ',&
'                                                           ',&
'## Patent                                                  ',&
'                                                           ',&
'Each contributor licenses you to do everything with this   ',&
'software that would otherwise infringe any patent claims   ',&
'they can license or become able to license.                ',&
'                                                           ',&
'## Reliability                                             ',&
'                                                           ',&
'No contributor can revoke this license.                    ',&
'                                                           ',&
'## No Liability                                            ',&
'                                                           ',&
'***As far as the law allows, this software comes as is,    ',&
'without any warranty or condition, and no contributor      ',&
'will be liable to anyone for any damages related to this   ',&
'software or this license, under any kind of legal claim.***',&
'                                                           ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('7','bsd-2-clause')
textblock=[ CHARACTER(LEN=128) :: &
'bsd-2-clause',&
'            ',&
'BSD 2-Clause License',&
'                    ',&
'Copyright (c) @YEAR@, @FULLNAME@',&
'                                ',&
'Redistribution and use in source and binary forms, with or without',&
'modification, are permitted provided that the following conditions are met:',&
'                                                                           ',&
'1. Redistributions of source code must retain the above copyright notice, this',&
'   list of conditions and the following disclaimer.                           ',&
'                                                                              ',&
'2. Redistributions in binary form must reproduce the above copyright notice,  ',&
'   this list of conditions and the following disclaimer in the documentation  ',&
'   and/or other materials provided with the distribution.                     ',&
'                                                                              ',&
'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   ',&
'AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE     ',&
'IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE',&
'DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  ',&
'FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    ',&
'DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR    ',&
'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER    ',&
'CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ',&
'OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ',&
'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('8','bsd-2-clause-patent')
textblock=[ CHARACTER(LEN=128) :: &
'bsd-2-clause-patent',&
'                   ',&
'Copyright (c) @YEAR@ @FULLNAME@',&
'                               ',&
'Redistribution and use in source and binary forms, with or without',&
'modification, are permitted provided that the following conditions are met:',&
'                                                                           ',&
'1. Redistributions of source code must retain the above copyright notice,  ',&
'this list of conditions and the following disclaimer.                      ',&
'                                                                           ',&
'2. Redistributions in binary form must reproduce the above copyright notice,',&
'this list of conditions and the following disclaimer in the documentation   ',&
'and/or other materials provided with the distribution.                      ',&
'                                                                            ',&
'Subject to the terms and conditions of this license, each copyright holder  ',&
'and contributor hereby grants to those receiving rights under this license  ',&
'a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable ',&
'(except for failure to satisfy the conditions of this license) patent license',&
'to make, have made, use, offer to sell, sell, import, and otherwise transfer ',&
'this software, where such license applies only to those patent claims, already',&
'acquired or hereafter acquired, licensable by such copyright holder or        ',&
'contributor that are necessarily infringed by:                                ',&
'                                                                              ',&
'(a) their Contribution(s) (the licensed copyrights of copyright holders and   ',&
'non-copyrightable additions of contributors, in source or binary form) alone; ',&
'or                                                                            ',&
'                                                                              ',&
'(b) combination of their Contribution(s) with the work of authorship to which ',&
'such Contribution(s) was added by such copyright holder or contributor, if,   ',&
'at the time the Contribution is added, such addition causes such combination  ',&
'to be necessarily infringed. The patent license shall not apply to any other  ',&
'combinations which include the Contribution.                                  ',&
'                                                                              ',&
'Except as expressly stated above, no rights or licenses from any copyright    ',&
'holder or contributor is granted under this license, whether expressly, by    ',&
'implication, estoppel or otherwise.                                           ',&
'                                                                              ',&
'DISCLAIMER                                                                    ',&
'                                                                              ',&
'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   ',&
'AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE     ',&
'IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE',&
'DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE ',&
'FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    ',&
'DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR    ',&
'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER    ',&
'CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ',&
'OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ',&
'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('9','bsd-3-clause-clear')
textblock=[ CHARACTER(LEN=128) :: &
'bsd-3-clause-clear',&
'                  ',&
'The Clear BSD License',&
'                     ',&
'Copyright (c) @YEAR@ @FULLNAME@',&
'All rights reserved.           ',&
'                               ',&
'Redistribution and use in source and binary forms, with or without',&
'modification, are permitted (subject to the limitations in the disclaimer',&
'below) provided that the following conditions are met:                   ',&
'                                                                         ',&
'     * Redistributions of source code must retain the above copyright notice,',&
'     this list of conditions and the following disclaimer.                   ',&
'                                                                             ',&
'     * Redistributions in binary form must reproduce the above copyright     ',&
'     notice, this list of conditions and the following disclaimer in the     ',&
'     documentation and/or other materials provided with the distribution.    ',&
'                                                                             ',&
'     * Neither the name of the copyright holder nor the names of its         ',&
'     contributors may be used to endorse or promote products derived from this',&
'     software without specific prior written permission.                      ',&
'                                                                              ',&
'NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY''S PATENT RIGHTS ARE GRANTED BY   ',&
'THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND          ',&
'CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT',&
'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A       ',&
'PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR  ',&
'CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,         ',&
'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,           ',&
'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR',&
'BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER ',&
'IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ',&
'ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE    ',&
'POSSIBILITY OF SUCH DAMAGE.                                                   ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('10','bsd-3-clause')
textblock=[ CHARACTER(LEN=128) :: &
'bsd-3-clause',&
'            ',&
'BSD 3-Clause License',&
'                    ',&
'Copyright (c) @YEAR@, @FULLNAME@',&
'                                ',&
'Redistribution and use in source and binary forms, with or without',&
'modification, are permitted provided that the following conditions are met:',&
'                                                                           ',&
'1. Redistributions of source code must retain the above copyright notice, this',&
'   list of conditions and the following disclaimer.                           ',&
'                                                                              ',&
'2. Redistributions in binary form must reproduce the above copyright notice,  ',&
'   this list of conditions and the following disclaimer in the documentation  ',&
'   and/or other materials provided with the distribution.                     ',&
'                                                                              ',&
'3. Neither the name of the copyright holder nor the names of its              ',&
'   contributors may be used to endorse or promote products derived from       ',&
'   this software without specific prior written permission.                   ',&
'                                                                              ',&
'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   ',&
'AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE     ',&
'IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE',&
'DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  ',&
'FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    ',&
'DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR    ',&
'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER    ',&
'CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ',&
'OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ',&
'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('11','bsd-4-clause')
textblock=[ CHARACTER(LEN=128) :: &
'bsd-4-clause',&
'            ',&
'BSD 4-Clause License',&
'                    ',&
'Copyright (c) @YEAR@, @FULLNAME@',&
'All rights reserved.            ',&
'                                ',&
'Redistribution and use in source and binary forms, with or without',&
'modification, are permitted provided that the following conditions are met:',&
'                                                                           ',&
'1. Redistributions of source code must retain the above copyright notice, this',&
'   list of conditions and the following disclaimer.                           ',&
'                                                                              ',&
'2. Redistributions in binary form must reproduce the above copyright notice,  ',&
'   this list of conditions and the following disclaimer in the documentation  ',&
'   and/or other materials provided with the distribution.                     ',&
'                                                                              ',&
'3. All advertising materials mentioning features or use of this software must ',&
'   display the following acknowledgement:                                     ',&
'     This product includes software developed by @PROJECT@.                   ',&
'                                                                              ',&
'4. Neither the name of the copyright holder nor the names of its              ',&
'   contributors may be used to endorse or promote products derived from       ',&
'   this software without specific prior written permission.                   ',&
'                                                                              ',&
'THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER "AS IS" AND ANY EXPRESS OR      ',&
'IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  ',&
'MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO    ',&
'EVENT SHALL COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  ',&
'SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  ',&
'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;   ',&
'OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,      ',&
'WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR       ',&
'OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF        ',&
'ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                    ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('12','bsl-1.0')
textblock=[ CHARACTER(LEN=128) :: &
'bsl-1.0',&
'       ',&
'Boost Software License - Version 1.0 - August 17th, 2003',&
'                                                        ',&
'Permission is hereby granted, free of charge, to any person or organization',&
'obtaining a copy of the software and accompanying documentation covered by ',&
'this license (the "Software") to use, reproduce, display, distribute,      ',&
'execute, and transmit the Software, and to prepare derivative works of the ',&
'Software, and to permit third-parties to whom the Software is furnished to ',&
'do so, all subject to the following:                                       ',&
'                                                                           ',&
'The copyright notices in the Software and this entire statement, including ',&
'the above license grant, this restriction and the following disclaimer,    ',&
'must be included in all copies of the Software, in whole or in part, and   ',&
'all derivative works of the Software, unless such copies or derivative     ',&
'works are solely in the form of machine-executable object code generated by',&
'a source language processor.                                               ',&
'                                                                           ',&
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ',&
'IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   ',&
'FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT  ',&
'SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE  ',&
'FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,',&
'ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER',&
'DEALINGS IN THE SOFTWARE.                                                  ',&
'                                                                           ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('13','cc0-1.0')
textblock=[ CHARACTER(LEN=128) :: &
'cc0-1.0',&
'       ',&
'Creative Commons Legal Code',&
'                           ',&
'CC0 1.0 Universal          ',&
'                           ',&
'    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE',&
'    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN   ',&
'    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS       ',&
'    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES',&
'    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS       ',&
'    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM',&
'    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED         ',&
'    HEREUNDER.                                                            ',&
'                                                                          ',&
'Statement of Purpose                                                      ',&
'                                                                          ',&
'The laws of most jurisdictions throughout the world automatically confer  ',&
'exclusive Copyright and Related Rights (defined below) upon the creator   ',&
'and subsequent owner(s) (each and all, an "owner") of an original work of ',&
'authorship and/or a database (each, a "Work").                            ',&
'                                                                          ',&
'Certain owners wish to permanently relinquish those rights to a Work for  ',&
'the purpose of contributing to a commons of creative, cultural and        ',&
'scientific works ("Commons") that the public can reliably and without fear',&
'of later claims of infringement build upon, modify, incorporate in other  ',&
'works, reuse and redistribute as freely as possible in any form whatsoever',&
'and for any purposes, including without limitation commercial purposes.   ',&
'These owners may contribute to the Commons to promote the ideal of a free ',&
'culture and the further production of creative, cultural and scientific   ',&
'works, or to gain reputation or greater distribution for their Work in    ',&
'part through the use and efforts of others.                               ',&
'                                                                          ',&
'For these and/or other purposes and motivations, and without any          ',&
'expectation of additional consideration or compensation, the person       ',&
'associating CC0 with a Work (the "Affirmer"), to the extent that he or she',&
'is an owner of Copyright and Related Rights in the Work, voluntarily      ',&
'elects to apply CC0 to the Work and publicly distribute the Work under its',&
'terms, with knowledge of his or her Copyright and Related Rights in the   ',&
'Work and the meaning and intended legal effect of CC0 on those rights.    ',&
'                                                                          ',&
'1. Copyright and Related Rights. A Work made available under CC0 may be   ',&
'protected by copyright and related or neighboring rights ("Copyright and  ',&
'Related Rights"). Copyright and Related Rights include, but are not       ',&
'limited to, the following:                                                ',&
'                                                                          ',&
'  i. the right to reproduce, adapt, distribute, perform, display,         ',&
'     communicate, and translate a Work;                                   ',&
' ii. moral rights retained by the original author(s) and/or performer(s); ',&
'iii. publicity and privacy rights pertaining to a person''s image or      ',&
'     likeness depicted in a Work;                                         ',&
' iv. rights protecting against unfair competition in regards to a Work,   ',&
'     subject to the limitations in paragraph 4(a), below;                 ',&
'  v. rights protecting the extraction, dissemination, use and reuse of data',&
'     in a Work;                                                            ',&
' vi. database rights (such as those arising under Directive 96/9/EC of the ',&
'     European Parliament and of the Council of 11 March 1996 on the legal  ',&
'     protection of databases, and under any national implementation        ',&
'     thereof, including any amended or successor version of such           ',&
'     directive); and                                                       ',&
'vii. other similar, equivalent or corresponding rights throughout the      ',&
'     world based on applicable law or treaty, and any national             ',&
'     implementations thereof.                                              ',&
'                                                                           ',&
'2. Waiver. To the greatest extent permitted by, but not in contravention   ',&
'of, applicable law, Affirmer hereby overtly, fully, permanently,           ',&
'irrevocably and unconditionally waives, abandons, and surrenders all of    ',&
'Affirmer''s Copyright and Related Rights and associated claims and causes  ',&
'of action, whether now known or unknown (including existing as well as     ',&
'future claims and causes of action), in the Work (i) in all territories    ',&
'worldwide, (ii) for the maximum duration provided by applicable law or     ',&
'treaty (including future time extensions), (iii) in any current or future  ',&
'medium and for any number of copies, and (iv) for any purpose whatsoever,  ',&
'including without limitation commercial, advertising or promotional        ',&
'purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each ',&
'member of the public at large and to the detriment of Affirmer''s heirs and',&
'successors, fully intending that such Waiver shall not be subject to       ',&
'revocation, rescission, cancellation, termination, or any other legal or   ',&
'equitable action to disrupt the quiet enjoyment of the Work by the public  ',&
'as contemplated by Affirmer''s express Statement of Purpose.               ',&
'                                                                           ',&
'3. Public License Fallback. Should any part of the Waiver for any reason   ',&
'be judged legally invalid or ineffective under applicable law, then the    ',&
'Waiver shall be preserved to the maximum extent permitted taking into      ',&
'account Affirmer''s express Statement of Purpose. In addition, to the      ',&
'extent the Waiver is so judged Affirmer hereby grants to each affected     ',&
'person a royalty-free, non transferable, non sublicensable, non exclusive, ',&
'irrevocable and unconditional license to exercise Affirmer''s Copyright and',&
'Related Rights in the Work (i) in all territories worldwide, (ii) for the  ',&
'maximum duration provided by applicable law or treaty (including future    ',&
'time extensions), (iii) in any current or future medium and for any number ',&
'of copies, and (iv) for any purpose whatsoever, including without          ',&
'limitation commercial, advertising or promotional purposes (the            ',&
'"License"). The License shall be deemed effective as of the date CC0 was   ',&
'applied by Affirmer to the Work. Should any part of the License for any    ',&
'reason be judged legally invalid or ineffective under applicable law, such ',&
'partial invalidity or ineffectiveness shall not invalidate the remainder   ',&
'of the License, and in such case Affirmer hereby affirms that he or she    ',&
'will not (i) exercise any of his or her remaining Copyright and Related    ',&
'Rights in the Work or (ii) assert any associated claims and causes of      ',&
'action with respect to the Work, in either case contrary to Affirmer''s    ',&
'express Statement of Purpose.                                              ',&
'                                                                           ',&
'4. Limitations and Disclaimers.                                            ',&
'                                                                           ',&
' a. No trademark or patent rights held by Affirmer are waived, abandoned,  ',&
'    surrendered, licensed or otherwise affected by this document.          ',&
' b. Affirmer offers the Work as-is and makes no representations or         ',&
'    warranties of any kind concerning the Work, express, implied,          ',&
'    statutory or otherwise, including without limitation warranties of     ',&
'    title, merchantability, fitness for a particular purpose, non          ',&
'    infringement, or the absence of latent or other defects, accuracy, or  ',&
'    the present or absence of errors, whether or not discoverable, all to  ',&
'    the greatest extent permissible under applicable law.                  ',&
' c. Affirmer disclaims responsibility for clearing rights of other persons ',&
'    that may apply to the Work or any use thereof, including without       ',&
'    limitation any person''s Copyright and Related Rights in the Work.     ',&
'    Further, Affirmer disclaims responsibility for obtaining any necessary ',&
'    consents, permissions or other rights required for any use of the      ',&
'    Work.                                                                  ',&
' d. Affirmer understands and acknowledges that Creative Commons is not a   ',&
'    party to this document and has no duty or obligation with respect to   ',&
'    this CC0 or use of the Work.                                           ',&
'                                                                           ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('14','cc-by-4.0')
textblock=[ CHARACTER(LEN=128) :: &
'cc-by-4.0',&
'         ',&
'Attribution 4.0 International',&
'                             ',&
'=======================================================================',&
'                                                                       ',&
'Creative Commons Corporation ("Creative Commons") is not a law firm and',&
'does not provide legal services or legal advice. Distribution of       ',&
'Creative Commons public licenses does not create a lawyer-client or    ',&
'other relationship. Creative Commons makes its licenses and related    ',&
'information available on an "as-is" basis. Creative Commons gives no   ',&
'warranties regarding its licenses, any material licensed under their   ',&
'terms and conditions, or any related information. Creative Commons     ',&
'disclaims all liability for damages resulting from their use to the    ',&
'fullest extent possible.                                               ',&
'                                                                       ',&
'Using Creative Commons Public Licenses                                 ',&
'                                                                       ',&
'Creative Commons public licenses provide a standard set of terms and   ',&
'conditions that creators and other rights holders may use to share     ',&
'original works of authorship and other material subject to copyright   ',&
'and certain other rights specified in the public license below. The    ',&
'following considerations are for informational purposes only, are not  ',&
'exhaustive, and do not form part of our licenses.                      ',&
'                                                                       ',&
'     Considerations for licensors: Our public licenses are             ',&
'     intended for use by those authorized to give the public           ',&
'     permission to use material in ways otherwise restricted by        ',&
'     copyright and certain other rights. Our licenses are              ',&
'     irrevocable. Licensors should read and understand the terms       ',&
'     and conditions of the license they choose before applying it.     ',&
'     Licensors should also secure all rights necessary before          ',&
'     applying our licenses so that the public can reuse the            ',&
'     material as expected. Licensors should clearly mark any           ',&
'     material not subject to the license. This includes other CC-      ',&
'     licensed material, or material used under an exception or         ',&
'     limitation to copyright. More considerations for licensors:       ',&
'     wiki.creativecommons.org/Considerations_for_licensors             ',&
'                                                                       ',&
'     Considerations for the public: By using one of our public         ',&
'     licenses, a licensor grants the public permission to use the      ',&
'     licensed material under specified terms and conditions. If        ',&
'     the licensor''s permission is not necessary for any reason--for   ',&
'     example, because of any applicable exception or limitation to     ',&
'     copyright--then that use is not regulated by the license. Our     ',&
'     licenses grant only permissions under copyright and certain       ',&
'     other rights that a licensor has authority to grant. Use of       ',&
'     the licensed material may still be restricted for other           ',&
'     reasons, including because others have copyright or other         ',&
'     rights in the material. A licensor may make special requests,     ',&
'     such as asking that all changes be marked or described.           ',&
'     Although not required by our licenses, you are encouraged to      ',&
'     respect those requests where reasonable. More considerations      ',&
'     for the public:                                                   ',&
'     wiki.creativecommons.org/Considerations_for_licensees             ',&
'                                                                       ',&
'=======================================================================',&
'                                                                       ',&
'Creative Commons Attribution 4.0 International Public License          ',&
'                                                                       ',&
'By exercising the Licensed Rights (defined below), You accept and agree',&
'to be bound by the terms and conditions of this Creative Commons       ',&
'Attribution 4.0 International Public License ("Public License"). To the',&
'extent this Public License may be interpreted as a contract, You are   ',&
'granted the Licensed Rights in consideration of Your acceptance of     ',&
'these terms and conditions, and the Licensor grants You such rights in ',&
'consideration of benefits the Licensor receives from making the        ',&
'Licensed Material available under these terms and conditions.          ',&
'                                                                       ',&
'                                                                       ',&
'Section 1 -- Definitions.                                              ',&
'                                                                       ',&
'  a. Adapted Material means material subject to Copyright and Similar  ',&
'     Rights that is derived from or based upon the Licensed Material   ',&
'     and in which the Licensed Material is translated, altered,        ',&
'     arranged, transformed, or otherwise modified in a manner requiring',&
'     permission under the Copyright and Similar Rights held by the     ',&
'     Licensor. For purposes of this Public License, where the Licensed ',&
'     Material is a musical work, performance, or sound recording,      ',&
'     Adapted Material is always produced where the Licensed Material is',&
'     synched in timed relation with a moving image.                    ',&
'                                                                       ',&
'  b. Adapter''s License means the license You apply to Your Copyright  ',&
'     and Similar Rights in Your contributions to Adapted Material in   ',&
'     accordance with the terms and conditions of this Public License.  ',&
'                                                                       ',&
'  c. Copyright and Similar Rights means copyright and/or similar rights',&
'     closely related to copyright including, without limitation,       ',&
'     performance, broadcast, sound recording, and Sui Generis Database ',&
'     Rights, without regard to how the rights are labeled or           ',&
'     categorized. For purposes of this Public License, the rights      ',&
'     specified in Section 2(b)(1)-(2) are not Copyright and Similar    ',&
'     Rights.                                                           ',&
'                                                                       ',&
'  d. Effective Technological Measures means those measures that, in the',&
'     absence of proper authority, may not be circumvented under laws   ',&
'     fulfilling obligations under Article 11 of the WIPO Copyright     ',&
'     Treaty adopted on December 20, 1996, and/or similar international ',&
'     agreements.                                                       ',&
'                                                                       ',&
'  e. Exceptions and Limitations means fair use, fair dealing, and/or   ',&
'     any other exception or limitation to Copyright and Similar Rights ',&
'     that applies to Your use of the Licensed Material.                ',&
'                                                                       ',&
'  f. Licensed Material means the artistic or literary work, database,  ',&
'     or other material to which the Licensor applied this Public       ',&
'     License.                                                          ',&
'                                                                       ',&
'  g. Licensed Rights means the rights granted to You subject to the    ',&
'     terms and conditions of this Public License, which are limited to ',&
'     all Copyright and Similar Rights that apply to Your use of the    ',&
'     Licensed Material and that the Licensor has authority to license. ',&
'                                                                       ',&
'  h. Licensor means the individual(s) or entity(ies) granting rights   ',&
'     under this Public License.                                        ',&
'                                                                       ',&
'  i. Share means to provide material to the public by any means or     ',&
'     process that requires permission under the Licensed Rights, such  ',&
'     as reproduction, public display, public performance, distribution,',&
'     dissemination, communication, or importation, and to make material',&
'     available to the public including in ways that members of the     ',&
'     public may access the material from a place and at a time         ',&
'     individually chosen by them.                                      ',&
'                                                                       ',&
'  j. Sui Generis Database Rights means rights other than copyright     ',&
'     resulting from Directive 96/9/EC of the European Parliament and of',&
'     the Council of 11 March 1996 on the legal protection of databases,',&
'     as amended and/or succeeded, as well as other essentially         ',&
'     equivalent rights anywhere in the world.                          ',&
'                                                                       ',&
'  k. You means the individual or entity exercising the Licensed Rights ',&
'     under this Public License. Your has a corresponding meaning.      ',&
'                                                                       ',&
'                                                                       ',&
'Section 2 -- Scope.                                                    ',&
'                                                                       ',&
'  a. License grant.                                                    ',&
'                                                                       ',&
'       1. Subject to the terms and conditions of this Public License,  ',&
'          the Licensor hereby grants You a worldwide, royalty-free,    ',&
'          non-sublicensable, non-exclusive, irrevocable license to     ',&
'          exercise the Licensed Rights in the Licensed Material to:    ',&
'                                                                       ',&
'            a. reproduce and Share the Licensed Material, in whole or  ',&
'               in part; and                                            ',&
'                                                                       ',&
'            b. produce, reproduce, and Share Adapted Material.         ',&
'                                                                       ',&
'       2. Exceptions and Limitations. For the avoidance of doubt, where',&
'          Exceptions and Limitations apply to Your use, this Public    ',&
'          License does not apply, and You do not need to comply with   ',&
'          its terms and conditions.                                    ',&
'                                                                       ',&
'       3. Term. The term of this Public License is specified in Section',&
'          6(a).                                                        ',&
'                                                                       ',&
'       4. Media and formats; technical modifications allowed. The      ',&
'          Licensor authorizes You to exercise the Licensed Rights in   ',&
'          all media and formats whether now known or hereafter created,',&
'          and to make technical modifications necessary to do so. The  ',&
'          Licensor waives and/or agrees not to assert any right or     ',&
'          authority to forbid You from making technical modifications  ',&
'          necessary to exercise the Licensed Rights, including         ',&
'          technical modifications necessary to circumvent Effective    ',&
'          Technological Measures. For purposes of this Public License, ',&
'          simply making modifications authorized by this Section 2(a)  ',&
'          (4) never produces Adapted Material.                         ',&
'                                                                       ',&
'       5. Downstream recipients.                                       ',&
'                                                                       ',&
'            a. Offer from the Licensor -- Licensed Material. Every     ',&
'               recipient of the Licensed Material automatically        ',&
'               receives an offer from the Licensor to exercise the     ',&
'               Licensed Rights under the terms and conditions of this  ',&
'               Public License.                                         ',&
'                                                                       ',&
'            b. No downstream restrictions. You may not offer or impose ',&
'               any additional or different terms or conditions on, or  ',&
'               apply any Effective Technological Measures to, the      ',&
'               Licensed Material if doing so restricts exercise of the ',&
'               Licensed Rights by any recipient of the Licensed        ',&
'               Material.                                               ',&
'                                                                       ',&
'       6. No endorsement. Nothing in this Public License constitutes or',&
'          may be construed as permission to assert or imply that You   ',&
'          are, or that Your use of the Licensed Material is, connected ',&
'          with, or sponsored, endorsed, or granted official status by, ',&
'          the Licensor or others designated to receive attribution as  ',&
'          provided in Section 3(a)(1)(A)(i).                           ',&
'                                                                       ',&
'  b. Other rights.                                                     ',&
'                                                                       ',&
'       1. Moral rights, such as the right of integrity, are not        ',&
'          licensed under this Public License, nor are publicity,       ',&
'          privacy, and/or other similar personality rights; however, to',&
'          the extent possible, the Licensor waives and/or agrees not to',&
'          assert any such rights held by the Licensor to the limited   ',&
'          extent necessary to allow You to exercise the Licensed       ',&
'          Rights, but not otherwise.                                   ',&
'                                                                       ',&
'       2. Patent and trademark rights are not licensed under this      ',&
'          Public License.                                              ',&
'                                                                       ',&
'       3. To the extent possible, the Licensor waives any right to     ',&
'          collect royalties from You for the exercise of the Licensed  ',&
'          Rights, whether directly or through a collecting society     ',&
'          under any voluntary or waivable statutory or compulsory      ',&
'          licensing scheme. In all other cases the Licensor expressly  ',&
'          reserves any right to collect such royalties.                ',&
'                                                                       ',&
'                                                                       ',&
'Section 3 -- License Conditions.                                       ',&
'                                                                       ',&
'Your exercise of the Licensed Rights is expressly made subject to the  ',&
'following conditions.                                                  ',&
'                                                                       ',&
'  a. Attribution.                                                      ',&
'                                                                       ',&
'       1. If You Share the Licensed Material (including in modified    ',&
'          form), You must:                                             ',&
'                                                                       ',&
'            a. retain the following if it is supplied by the Licensor  ',&
'               with the Licensed Material:                             ',&
'                                                                       ',&
'                 i. identification of the creator(s) of the Licensed   ',&
'                    Material and any others designated to receive      ',&
'                    attribution, in any reasonable manner requested by ',&
'                    the Licensor (including by pseudonym if            ',&
'                    designated);                                       ',&
'                                                                       ',&
'                ii. a copyright notice;                                ',&
'                                                                       ',&
'               iii. a notice that refers to this Public License;       ',&
'                                                                       ',&
'                iv. a notice that refers to the disclaimer of          ',&
'                    warranties;                                        ',&
'                                                                       ',&
'                 v. a URI or hyperlink to the Licensed Material to the ',&
'                    extent reasonably practicable;                     ',&
'                                                                       ',&
'            b. indicate if You modified the Licensed Material and      ',&
'               retain an indication of any previous modifications; and ',&
'                                                                       ',&
'            c. indicate the Licensed Material is licensed under this   ',&
'               Public License, and include the text of, or the URI or  ',&
'               hyperlink to, this Public License.                      ',&
'                                                                       ',&
'       2. You may satisfy the conditions in Section 3(a)(1) in any     ',&
'          reasonable manner based on the medium, means, and context in ',&
'          which You Share the Licensed Material. For example, it may be',&
'          reasonable to satisfy the conditions by providing a URI or   ',&
'          hyperlink to a resource that includes the required           ',&
'          information.                                                 ',&
'                                                                       ',&
'       3. If requested by the Licensor, You must remove any of the     ',&
'          information required by Section 3(a)(1)(A) to the extent     ',&
'          reasonably practicable.                                      ',&
'                                                                       ',&
'       4. If You Share Adapted Material You produce, the Adapter''s    ',&
'          License You apply must not prevent recipients of the Adapted ',&
'          Material from complying with this Public License.            ',&
'                                                                       ',&
'                                                                       ',&
'Section 4 -- Sui Generis Database Rights.                              ',&
'                                                                       ',&
'Where the Licensed Rights include Sui Generis Database Rights that     ',&
'apply to Your use of the Licensed Material:                            ',&
'                                                                       ',&
'  a. for the avoidance of doubt, Section 2(a)(1) grants You the right  ',&
'     to extract, reuse, reproduce, and Share all or a substantial      ',&
'     portion of the contents of the database;                          ',&
'                                                                       ',&
'  b. if You include all or a substantial portion of the database       ',&
'     contents in a database in which You have Sui Generis Database     ',&
'     Rights, then the database in which You have Sui Generis Database  ',&
'     Rights (but not its individual contents) is Adapted Material; and ',&
'                                                                       ',&
'  c. You must comply with the conditions in Section 3(a) if You Share  ',&
'     all or a substantial portion of the contents of the database.     ',&
'                                                                       ',&
'For the avoidance of doubt, this Section 4 supplements and does not    ',&
'replace Your obligations under this Public License where the Licensed  ',&
'Rights include other Copyright and Similar Rights.                     ',&
'                                                                       ',&
'                                                                       ',&
'Section 5 -- Disclaimer of Warranties and Limitation of Liability.     ',&
'                                                                       ',&
'  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE    ',&
'     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS  ',&
'     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF   ',&
'     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,       ',&
'     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,  ',&
'     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR    ',&
'     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,    ',&
'     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT    ',&
'     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT    ',&
'     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU. ',&
'                                                                       ',&
'  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE   ',&
'     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,        ',&
'     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,       ',&
'     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,  ',&
'     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR ',&
'     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN       ',&
'     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR    ',&
'     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR',&
'     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.                    ',&
'                                                                       ',&
'  c. The disclaimer of warranties and limitation of liability provided ',&
'     above shall be interpreted in a manner that, to the extent        ',&
'     possible, most closely approximates an absolute disclaimer and    ',&
'     waiver of all liability.                                          ',&
'                                                                       ',&
'                                                                       ',&
'Section 6 -- Term and Termination.                                     ',&
'                                                                       ',&
'  a. This Public License applies for the term of the Copyright and     ',&
'     Similar Rights licensed here. However, if You fail to comply with ',&
'     this Public License, then Your rights under this Public License   ',&
'     terminate automatically.                                          ',&
'                                                                       ',&
'  b. Where Your right to use the Licensed Material has terminated under',&
'     Section 6(a), it reinstates:                                      ',&
'                                                                       ',&
'       1. automatically as of the date the violation is cured, provided',&
'          it is cured within 30 days of Your discovery of the          ',&
'          violation; or                                                ',&
'                                                                       ',&
'       2. upon express reinstatement by the Licensor.                  ',&
'                                                                       ',&
'     For the avoidance of doubt, this Section 6(b) does not affect any ',&
'     right the Licensor may have to seek remedies for Your violations  ',&
'     of this Public License.                                           ',&
'                                                                       ',&
'  c. For the avoidance of doubt, the Licensor may also offer the       ',&
'     Licensed Material under separate terms or conditions or stop      ',&
'     distributing the Licensed Material at any time; however, doing so ',&
'     will not terminate this Public License.                           ',&
'                                                                       ',&
'  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public     ',&
'     License.                                                          ',&
'                                                                       ',&
'                                                                       ',&
'Section 7 -- Other Terms and Conditions.                               ',&
'                                                                       ',&
'  a. The Licensor shall not be bound by any additional or different    ',&
'     terms or conditions communicated by You unless expressly agreed.  ',&
'                                                                       ',&
'  b. Any arrangements, understandings, or agreements regarding the     ',&
'     Licensed Material not stated herein are separate from and         ',&
'     independent of the terms and conditions of this Public License.   ',&
'                                                                       ',&
'                                                                       ',&
'Section 8 -- Interpretation.                                           ',&
'                                                                       ',&
'  a. For the avoidance of doubt, this Public License does not, and     ',&
'     shall not be interpreted to, reduce, limit, restrict, or impose   ',&
'     conditions on any use of the Licensed Material that could lawfully',&
'     be made without permission under this Public License.             ',&
'                                                                       ',&
'  b. To the extent possible, if any provision of this Public License is',&
'     deemed unenforceable, it shall be automatically reformed to the   ',&
'     minimum extent necessary to make it enforceable. If the provision ',&
'     cannot be reformed, it shall be severed from this Public License  ',&
'     without affecting the enforceability of the remaining terms and   ',&
'     conditions.                                                       ',&
'                                                                       ',&
'  c. No term or condition of this Public License will be waived and no ',&
'     failure to comply consented to unless expressly agreed to by the  ',&
'     Licensor.                                                         ',&
'                                                                       ',&
'  d. Nothing in this Public License constitutes or may be interpreted  ',&
'     as a limitation upon, or waiver of, any privileges and immunities ',&
'     that apply to the Licensor or You, including from the legal       ',&
'     processes of any jurisdiction or authority.                       ',&
'                                                                       ',&
'                                                                       ',&
'=======================================================================',&
'                                                                       ',&
'Creative Commons is not a party to its public licenses.                ',&
'Notwithstanding, Creative Commons may elect to apply one of its public ',&
'licenses to material it publishes and in those instances will be       ',&
'considered the Licensor. The text of the Creative Commons public ',&
'licenses is dedicated to the public domain under the CC0 Public Domain ',&
'Dedication. Except for the limited purpose of indicating that material ',&
'is shared under a Creative Commons public license or as otherwise      ',&
'permitted by the Creative Commons policies published at                ',&
'creativecommons.org/policies, Creative Commons does not authorize the  ',&
'use of the trademark "Creative Commons" or any other trademark or logo ',&
'of Creative Commons without its prior written consent including,       ',&
'without limitation, in connection with any unauthorized modifications  ',&
'to any of its public licenses or any other arrangements,               ',&
'understandings, or agreements concerning use of licensed material. For ',&
'the avoidance of doubt, this paragraph does not form part of the public',&
'licenses.                                                              ',&
'                                                                       ',&
'Creative Commons may be contacted at creativecommons.org.              ',&
'                                                                       ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('15','cc-by-sa-4.0')
textblock=[ CHARACTER(LEN=128) :: &
'cc-by-sa-4.0',&
'            ',&
'Attribution-ShareAlike 4.0 International',&
'                                        ',&
'=======================================================================',&
'                                                                       ',&
'Creative Commons Corporation ("Creative Commons") is not a law firm and',&
'does not provide legal services or legal advice. Distribution of       ',&
'Creative Commons public licenses does not create a lawyer-client or    ',&
'other relationship. Creative Commons makes its licenses and related    ',&
'information available on an "as-is" basis. Creative Commons gives no   ',&
'warranties regarding its licenses, any material licensed under their   ',&
'terms and conditions, or any related information. Creative Commons     ',&
'disclaims all liability for damages resulting from their use to the    ',&
'fullest extent possible.                                               ',&
'                                                                       ',&
'Using Creative Commons Public Licenses                                 ',&
'                                                                       ',&
'Creative Commons public licenses provide a standard set of terms and   ',&
'conditions that creators and other rights holders may use to share     ',&
'original works of authorship and other material subject to copyright   ',&
'and certain other rights specified in the public license below. The    ',&
'following considerations are for informational purposes only, are not  ',&
'exhaustive, and do not form part of our licenses.                      ',&
'                                                                       ',&
'     Considerations for licensors: Our public licenses are             ',&
'     intended for use by those authorized to give the public           ',&
'     permission to use material in ways otherwise restricted by        ',&
'     copyright and certain other rights. Our licenses are              ',&
'     irrevocable. Licensors should read and understand the terms       ',&
'     and conditions of the license they choose before applying it.     ',&
'     Licensors should also secure all rights necessary before          ',&
'     applying our licenses so that the public can reuse the            ',&
'     material as expected. Licensors should clearly mark any           ',&
'     material not subject to the license. This includes other CC-      ',&
'     licensed material, or material used under an exception or         ',&
'     limitation to copyright. More considerations for licensors:       ',&
'     wiki.creativecommons.org/Considerations_for_licensors             ',&
'                                                                       ',&
'     Considerations for the public: By using one of our public         ',&
'     licenses, a licensor grants the public permission to use the      ',&
'     licensed material under specified terms and conditions. If        ',&
'     the licensor''s permission is not necessary for any reason--for   ',&
'     example, because of any applicable exception or limitation to     ',&
'     copyright--then that use is not regulated by the license. Our     ',&
'     licenses grant only permissions under copyright and certain       ',&
'     other rights that a licensor has authority to grant. Use of       ',&
'     the licensed material may still be restricted for other           ',&
'     reasons, including because others have copyright or other         ',&
'     rights in the material. A licensor may make special requests,     ',&
'     such as asking that all changes be marked or described.           ',&
'     Although not required by our licenses, you are encouraged to      ',&
'     respect those requests where reasonable. More considerations      ',&
'     for the public:                                                   ',&
'     wiki.creativecommons.org/Considerations_for_licensees             ',&
'                                                                       ',&
'=======================================================================',&
'                                                                       ',&
'Creative Commons Attribution-ShareAlike 4.0 International Public       ',&
'License                                                                ',&
'                                                                       ',&
'By exercising the Licensed Rights (defined below), You accept and agree',&
'to be bound by the terms and conditions of this Creative Commons       ',&
'Attribution-ShareAlike 4.0 International Public License ("Public       ',&
'License"). To the extent this Public License may be interpreted as a   ',&
'contract, You are granted the Licensed Rights in consideration of Your ',&
'acceptance of these terms and conditions, and the Licensor grants You  ',&
'such rights in consideration of benefits the Licensor receives from    ',&
'making the Licensed Material available under these terms and           ',&
'conditions.                                                            ',&
'                                                                       ',&
'                                                                       ',&
'Section 1 -- Definitions.                                              ',&
'                                                                       ',&
'  a. Adapted Material means material subject to Copyright and Similar  ',&
'     Rights that is derived from or based upon the Licensed Material   ',&
'     and in which the Licensed Material is translated, altered,        ',&
'     arranged, transformed, or otherwise modified in a manner requiring',&
'     permission under the Copyright and Similar Rights held by the     ',&
'     Licensor. For purposes of this Public License, where the Licensed ',&
'     Material is a musical work, performance, or sound recording,      ',&
'     Adapted Material is always produced where the Licensed Material is',&
'     synched in timed relation with a moving image.                    ',&
'                                                                       ',&
'  b. Adapter''s License means the license You apply to Your Copyright  ',&
'     and Similar Rights in Your contributions to Adapted Material in   ',&
'     accordance with the terms and conditions of this Public License.  ',&
'                                                                       ',&
'  c. BY-SA Compatible License means a license listed at                ',&
'     creativecommons.org/compatiblelicenses, approved by Creative      ',&
'     Commons as essentially the equivalent of this Public License.     ',&
'                                                                       ',&
'  d. Copyright and Similar Rights means copyright and/or similar rights',&
'     closely related to copyright including, without limitation,       ',&
'     performance, broadcast, sound recording, and Sui Generis Database ',&
'     Rights, without regard to how the rights are labeled or           ',&
'     categorized. For purposes of this Public License, the rights      ',&
'     specified in Section 2(b)(1)-(2) are not Copyright and Similar    ',&
'     Rights.                                                           ',&
'                                                                       ',&
'  e. Effective Technological Measures means those measures that, in the',&
'     absence of proper authority, may not be circumvented under laws   ',&
'     fulfilling obligations under Article 11 of the WIPO Copyright     ',&
'     Treaty adopted on December 20, 1996, and/or similar international ',&
'     agreements.                                                       ',&
'                                                                       ',&
'  f. Exceptions and Limitations means fair use, fair dealing, and/or   ',&
'     any other exception or limitation to Copyright and Similar Rights ',&
'     that applies to Your use of the Licensed Material.                ',&
'                                                                       ',&
'  g. License Elements means the license attributes listed in the name  ',&
'     of a Creative Commons Public License. The License Elements of this',&
'     Public License are Attribution and ShareAlike.                    ',&
'                                                                       ',&
'  h. Licensed Material means the artistic or literary work, database,  ',&
'     or other material to which the Licensor applied this Public       ',&
'     License.                                                          ',&
'                                                                       ',&
'  i. Licensed Rights means the rights granted to You subject to the    ',&
'     terms and conditions of this Public License, which are limited to ',&
'     all Copyright and Similar Rights that apply to Your use of the    ',&
'     Licensed Material and that the Licensor has authority to license. ',&
'                                                                       ',&
'  j. Licensor means the individual(s) or entity(ies) granting rights   ',&
'     under this Public License.                                        ',&
'                                                                       ',&
'  k. Share means to provide material to the public by any means or     ',&
'     process that requires permission under the Licensed Rights, such  ',&
'     as reproduction, public display, public performance, distribution,',&
'     dissemination, communication, or importation, and to make material',&
'     available to the public including in ways that members of the     ',&
'     public may access the material from a place and at a time         ',&
'     individually chosen by them.                                      ',&
'                                                                       ',&
'  l. Sui Generis Database Rights means rights other than copyright     ',&
'     resulting from Directive 96/9/EC of the European Parliament and of',&
'     the Council of 11 March 1996 on the legal protection of databases,',&
'     as amended and/or succeeded, as well as other essentially         ',&
'     equivalent rights anywhere in the world.                          ',&
'                                                                       ',&
'  m. You means the individual or entity exercising the Licensed Rights ',&
'     under this Public License. Your has a corresponding meaning.      ',&
'                                                                       ',&
'                                                                       ',&
'Section 2 -- Scope.                                                    ',&
'                                                                       ',&
'  a. License grant.                                                    ',&
'                                                                       ',&
'       1. Subject to the terms and conditions of this Public License,  ',&
'          the Licensor hereby grants You a worldwide, royalty-free,    ',&
'          non-sublicensable, non-exclusive, irrevocable license to     ',&
'          exercise the Licensed Rights in the Licensed Material to:    ',&
'                                                                       ',&
'            a. reproduce and Share the Licensed Material, in whole or  ',&
'               in part; and                                            ',&
'                                                                       ',&
'            b. produce, reproduce, and Share Adapted Material.         ',&
'                                                                       ',&
'       2. Exceptions and Limitations. For the avoidance of doubt, where',&
'          Exceptions and Limitations apply to Your use, this Public    ',&
'          License does not apply, and You do not need to comply with   ',&
'          its terms and conditions.                                    ',&
'                                                                       ',&
'       3. Term. The term of this Public License is specified in Section',&
'          6(a).                                                        ',&
'                                                                       ',&
'       4. Media and formats; technical modifications allowed. The      ',&
'          Licensor authorizes You to exercise the Licensed Rights in   ',&
'          all media and formats whether now known or hereafter created,',&
'          and to make technical modifications necessary to do so. The  ',&
'          Licensor waives and/or agrees not to assert any right or     ',&
'          authority to forbid You from making technical modifications  ',&
'          necessary to exercise the Licensed Rights, including         ',&
'          technical modifications necessary to circumvent Effective    ',&
'          Technological Measures. For purposes of this Public License, ',&
'          simply making modifications authorized by this Section 2(a)  ',&
'          (4) never produces Adapted Material.                         ',&
'                                                                       ',&
'       5. Downstream recipients.                                       ',&
'                                                                       ',&
'            a. Offer from the Licensor -- Licensed Material. Every     ',&
'               recipient of the Licensed Material automatically        ',&
'               receives an offer from the Licensor to exercise the     ',&
'               Licensed Rights under the terms and conditions of this  ',&
'               Public License.                                         ',&
'                                                                       ',&
'            b. Additional offer from the Licensor -- Adapted Material. ',&
'               Every recipient of Adapted Material from You            ',&
'               automatically receives an offer from the Licensor to    ',&
'               exercise the Licensed Rights in the Adapted Material    ',&
'               under the conditions of the Adapter''s License You apply.',&
'                                                                        ',&
'            c. No downstream restrictions. You may not offer or impose  ',&
'               any additional or different terms or conditions on, or   ',&
'               apply any Effective Technological Measures to, the       ',&
'               Licensed Material if doing so restricts exercise of the  ',&
'               Licensed Rights by any recipient of the Licensed         ',&
'               Material.                                                ',&
'                                                                        ',&
'       6. No endorsement. Nothing in this Public License constitutes or ',&
'          may be construed as permission to assert or imply that You    ',&
'          are, or that Your use of the Licensed Material is, connected  ',&
'          with, or sponsored, endorsed, or granted official status by,  ',&
'          the Licensor or others designated to receive attribution as   ',&
'          provided in Section 3(a)(1)(A)(i).                            ',&
'                                                                        ',&
'  b. Other rights.                                                      ',&
'                                                                        ',&
'       1. Moral rights, such as the right of integrity, are not         ',&
'          licensed under this Public License, nor are publicity,        ',&
'          privacy, and/or other similar personality rights; however, to ',&
'          the extent possible, the Licensor waives and/or agrees not to ',&
'          assert any such rights held by the Licensor to the limited    ',&
'          extent necessary to allow You to exercise the Licensed        ',&
'          Rights, but not otherwise.                                    ',&
'                                                                        ',&
'       2. Patent and trademark rights are not licensed under this       ',&
'          Public License.                                               ',&
'                                                                        ',&
'       3. To the extent possible, the Licensor waives any right to      ',&
'          collect royalties from You for the exercise of the Licensed   ',&
'          Rights, whether directly or through a collecting society      ',&
'          under any voluntary or waivable statutory or compulsory       ',&
'          licensing scheme. In all other cases the Licensor expressly   ',&
'          reserves any right to collect such royalties.                 ',&
'                                                                        ',&
'                                                                        ',&
'Section 3 -- License Conditions.                                        ',&
'                                                                        ',&
'Your exercise of the Licensed Rights is expressly made subject to the   ',&
'following conditions.                                                   ',&
'                                                                        ',&
'  a. Attribution.                                                       ',&
'                                                                        ',&
'       1. If You Share the Licensed Material (including in modified     ',&
'          form), You must:                                              ',&
'                                                                        ',&
'            a. retain the following if it is supplied by the Licensor   ',&
'               with the Licensed Material:                              ',&
'                                                                        ',&
'                 i. identification of the creator(s) of the Licensed    ',&
'                    Material and any others designated to receive       ',&
'                    attribution, in any reasonable manner requested by  ',&
'                    the Licensor (including by pseudonym if             ',&
'                    designated);                                        ',&
'                                                                        ',&
'                ii. a copyright notice;                                 ',&
'                                                                        ',&
'               iii. a notice that refers to this Public License;        ',&
'                                                                        ',&
'                iv. a notice that refers to the disclaimer of           ',&
'                    warranties;                                         ',&
'                                                                        ',&
'                 v. a URI or hyperlink to the Licensed Material to the  ',&
'                    extent reasonably practicable;                      ',&
'                                                                        ',&
'            b. indicate if You modified the Licensed Material and       ',&
'               retain an indication of any previous modifications; and  ',&
'                                                                        ',&
'            c. indicate the Licensed Material is licensed under this    ',&
'               Public License, and include the text of, or the URI or   ',&
'               hyperlink to, this Public License.                       ',&
'                                                                        ',&
'       2. You may satisfy the conditions in Section 3(a)(1) in any      ',&
'          reasonable manner based on the medium, means, and context in  ',&
'          which You Share the Licensed Material. For example, it may be ',&
'          reasonable to satisfy the conditions by providing a URI or    ',&
'          hyperlink to a resource that includes the required            ',&
'          information.                                                  ',&
'                                                                        ',&
'       3. If requested by the Licensor, You must remove any of the      ',&
'          information required by Section 3(a)(1)(A) to the extent      ',&
'          reasonably practicable.                                       ',&
'                                                                        ',&
'  b. ShareAlike.                                                        ',&
'                                                                        ',&
'     In addition to the conditions in Section 3(a), if You Share        ',&
'     Adapted Material You produce, the following conditions also apply. ',&
'                                                                        ',&
'       1. The Adapter''s License You apply must be a Creative Commons   ',&
'          license with the same License Elements, this version or       ',&
'          later, or a BY-SA Compatible License.                         ',&
'                                                                        ',&
'       2. You must include the text of, or the URI or hyperlink to, the ',&
'          Adapter''s License You apply. You may satisfy this condition  ',&
'          in any reasonable manner based on the medium, means, and      ',&
'          context in which You Share Adapted Material.                  ',&
'                                                                        ',&
'       3. You may not offer or impose any additional or different terms ',&
'          or conditions on, or apply any Effective Technological        ',&
'          Measures to, Adapted Material that restrict exercise of the   ',&
'          rights granted under the Adapter''s License You apply.        ',&
'                                                                        ',&
'                                                                        ',&
'Section 4 -- Sui Generis Database Rights.                               ',&
'                                                                        ',&
'Where the Licensed Rights include Sui Generis Database Rights that      ',&
'apply to Your use of the Licensed Material:                             ',&
'                                                                        ',&
'  a. for the avoidance of doubt, Section 2(a)(1) grants You the right   ',&
'     to extract, reuse, reproduce, and Share all or a substantial       ',&
'     portion of the contents of the database;                           ',&
'                                                                        ',&
'  b. if You include all or a substantial portion of the database        ',&
'     contents in a database in which You have Sui Generis Database      ',&
'     Rights, then the database in which You have Sui Generis Database   ',&
'     Rights (but not its individual contents) is Adapted Material,      ',&
'     including for purposes of Section 3(b); and                        ',&
'                                                                        ',&
'  c. You must comply with the conditions in Section 3(a) if You Share   ',&
'     all or a substantial portion of the contents of the database.      ',&
'                                                                        ',&
'For the avoidance of doubt, this Section 4 supplements and does not     ',&
'replace Your obligations under this Public License where the Licensed   ',&
'Rights include other Copyright and Similar Rights.                      ',&
'                                                                        ',&
'                                                                        ',&
'Section 5 -- Disclaimer of Warranties and Limitation of Liability.      ',&
'                                                                        ',&
'  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE     ',&
'     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS   ',&
'     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF    ',&
'     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,        ',&
'     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,   ',&
'     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR     ',&
'     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,     ',&
'     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT     ',&
'     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT     ',&
'     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.  ',&
'                                                                        ',&
'  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE    ',&
'     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,         ',&
'     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,        ',&
'     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,   ',&
'     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR  ',&
'     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN        ',&
'     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR     ',&
'     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR ',&
'     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.                     ',&
'                                                                        ',&
'  c. The disclaimer of warranties and limitation of liability provided  ',&
'     above shall be interpreted in a manner that, to the extent         ',&
'     possible, most closely approximates an absolute disclaimer and     ',&
'     waiver of all liability.                                           ',&
'                                                                        ',&
'                                                                        ',&
'Section 6 -- Term and Termination.                                      ',&
'                                                                        ',&
'  a. This Public License applies for the term of the Copyright and      ',&
'     Similar Rights licensed here. However, if You fail to comply with  ',&
'     this Public License, then Your rights under this Public License    ',&
'     terminate automatically.                                           ',&
'                                                                        ',&
'  b. Where Your right to use the Licensed Material has terminated under ',&
'     Section 6(a), it reinstates:                                       ',&
'                                                                        ',&
'       1. automatically as of the date the violation is cured, provided ',&
'          it is cured within 30 days of Your discovery of the           ',&
'          violation; or                                                 ',&
'                                                                        ',&
'       2. upon express reinstatement by the Licensor.                   ',&
'                                                                        ',&
'     For the avoidance of doubt, this Section 6(b) does not affect any  ',&
'     right the Licensor may have to seek remedies for Your violations   ',&
'     of this Public License.                                            ',&
'                                                                        ',&
'  c. For the avoidance of doubt, the Licensor may also offer the        ',&
'     Licensed Material under separate terms or conditions or stop       ',&
'     distributing the Licensed Material at any time; however, doing so  ',&
'     will not terminate this Public License.                            ',&
'                                                                        ',&
'  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public      ',&
'     License.                                                           ',&
'                                                                        ',&
'                                                                        ',&
'Section 7 -- Other Terms and Conditions.                                ',&
'                                                                        ',&
'  a. The Licensor shall not be bound by any additional or different     ',&
'     terms or conditions communicated by You unless expressly agreed.   ',&
'                                                                        ',&
'  b. Any arrangements, understandings, or agreements regarding the      ',&
'     Licensed Material not stated herein are separate from and          ',&
'     independent of the terms and conditions of this Public License.    ',&
'                                                                        ',&
'                                                                        ',&
'Section 8 -- Interpretation.                                            ',&
'                                                                        ',&
'  a. For the avoidance of doubt, this Public License does not, and      ',&
'     shall not be interpreted to, reduce, limit, restrict, or impose    ',&
'     conditions on any use of the Licensed Material that could lawfully ',&
'     be made without permission under this Public License.              ',&
'                                                                        ',&
'  b. To the extent possible, if any provision of this Public License is ',&
'     deemed unenforceable, it shall be automatically reformed to the    ',&
'     minimum extent necessary to make it enforceable. If the provision  ',&
'     cannot be reformed, it shall be severed from this Public License   ',&
'     without affecting the enforceability of the remaining terms and    ',&
'     conditions.                                                        ',&
'                                                                        ',&
'  c. No term or condition of this Public License will be waived and no  ',&
'     failure to comply consented to unless expressly agreed to by the   ',&
'     Licensor.                                                          ',&
'                                                                        ',&
'  d. Nothing in this Public License constitutes or may be interpreted   ',&
'     as a limitation upon, or waiver of, any privileges and immunities  ',&
'     that apply to the Licensor or You, including from the legal        ',&
'     processes of any jurisdiction or authority.                        ',&
'                                                                        ',&
'                                                                        ',&
'======================================================================= ',&
'                                                                        ',&
'Creative Commons is not a party to its public licenses.                 ',&
'Notwithstanding, Creative Commons may elect to apply one of its public  ',&
'licenses to material it publishes and in those instances will be        ',&
'considered the Licensor. The text of the Creative Commons public  ',&
'licenses is dedicated to the public domain under the CC0 Public Domain  ',&
'Dedication. Except for the limited purpose of indicating that material  ',&
'is shared under a Creative Commons public license or as otherwise       ',&
'permitted by the Creative Commons policies published at                 ',&
'creativecommons.org/policies, Creative Commons does not authorize the   ',&
'use of the trademark "Creative Commons" or any other trademark or logo  ',&
'of Creative Commons without its prior written consent including,        ',&
'without limitation, in connection with any unauthorized modifications   ',&
'to any of its public licenses or any other arrangements,                ',&
'understandings, or agreements concerning use of licensed material. For  ',&
'the avoidance of doubt, this paragraph does not form part of the public ',&
'licenses.                                                               ',&
'                                                                        ',&
'Creative Commons may be contacted at creativecommons.org.               ',&
'                                                                        ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('16','cecill-2.1')
textblock=[ CHARACTER(LEN=128) :: &
'cecill-2.1',&
'          ',&
'  CONTRAT DE LICENCE DE LOGICIEL LIBRE CeCILL',&
'                                             ',&
'Version 2.1 du 2013-06-21                    ',&
'                                             ',&
'                                             ',&
'    Avertissement                            ',&
'                                             ',&
'Ce contrat est une licence de logiciel libre issue d''une concertation',&
'entre ses auteurs afin que le respect de deux grands principes prside ',&
'sa rdaction:                                                            ',&
'                                                                          ',&
'  * d''une part, le respect des principes de diffusion des logiciels      ',&
'    libres: accs au code source, droits tendus confrs aux utilisateurs,',&
'  * d''autre part, la dsignation d''un droit applicable, le droit            ',&
'    franais, auquel elle est conforme, tant au regard du droit de la         ',&
'    responsabilit civile que du droit de la proprit intellectuelle et    ',&
'    de la protection qu''il offre aux auteurs et titulaires des droits         ',&
'    patrimoniaux sur un logiciel.                                              ',&
'                                                                               ',&
'Les auteurs de la licence CeCILL (Ce[a] C[nrs] I[nria] L[ogiciel] L[ibre])     ',&
'sont:                                                                          ',&
'                                                                               ',&
'Commissariat  l''nergie atomique et aux nergies alternatives - CEA,      ',&
'tablissement public de recherche  caractre scientifique, technique et    ',&
'industriel, dont le sige est situ 25 rue Leblanc, immeuble Le Ponant       ',&
'D, 75015 Paris.                                                                ',&
'                                                                               ',&
'Centre National de la Recherche Scientifique - CNRS, tablissement            ',&
'public  caractre scientifique et technologique, dont le sige est         ',&
'situ 3 rue Michel-Ange, 75794 Paris cedex 16.                                ',&
'                                                                               ',&
'Institut National de Recherche en Informatique et en Automatique -             ',&
'Inria, tablissement public  caractre scientifique et technologique,      ',&
'dont le sige est situ Domaine de Voluceau, Rocquencourt, BP 105, 78153     ',&
'Le Chesnay cedex.                                                              ',&
'                                                                               ',&
'                                                                               ',&
'    Prambule                                                                 ',&
'                                                                               ',&
'Ce contrat est une licence de logiciel libre dont l''objectif est de           ',&
'confrer aux utilisateurs la libert de modification et de                   ',&
'redistribution du logiciel rgi par cette licence dans le cadre d''un         ',&
'modle de diffusion en logiciel libre.                                        ',&
'                                                                               ',&
'L''exercice de ces liberts est assorti de certains devoirs  la charge      ',&
'des utilisateurs afin de prserver ce statut au cours des                     ',&
'redistributions ultrieures.                                                  ',&
'                                                                               ',&
'L''accessibilit au code source et les droits de copie, de modification       ',&
'et de redistribution qui en dcoulent ont pour contrepartie de n''offrir      ',&
'aux utilisateurs qu''une garantie limite et de ne faire peser sur            ',&
'l''auteur du logiciel, le titulaire des droits patrimoniaux et les             ',&
'concdants successifs qu''une responsabilit restreinte.                     ',&
'                                                                               ',&
'A cet gard l''attention de l''utilisateur est attire sur les risques       ',&
'associs au chargement,  l''utilisation,  la modification et/ou au        ',&
'dveloppement et  la reproduction du logiciel par l''utilisateur tant     ',&
'donn sa spcificit de logiciel libre, qui peut le rendre complexe       ',&
'manipuler et qui le rserve donc  des dveloppeurs ou des                  ',&
'professionnels avertis possdant des connaissances informatiques              ',&
'approfondies. Les utilisateurs sont donc invits  charger et tester         ',&
'l''adquation du logiciel  leurs besoins dans des conditions permettant     ',&
'd''assurer la scurit de leurs systmes et/ou de leurs donnes et, plus   ',&
'gnralement,  l''utiliser et l''exploiter dans les mmes conditions de   ',&
'scurit. Ce contrat peut tre reproduit et diffus librement, sous        ',&
'rserve de le conserver en l''tat, sans ajout ni suppression de clauses.    ',&
'                                                                               ',&
'Ce contrat est susceptible de s''appliquer  tout logiciel dont le            ',&
'titulaire des droits patrimoniaux dcide de soumettre l''exploitation aux     ',&
'dispositions qu''il contient.                                                  ',&
'                                                                               ',&
'Une liste de questions frquemment poses se trouve sur le site web          ',&
'officiel de la famille des licences CeCILL                                     ',&
'(http://www.cecill.info/index.fr.html) pour toute clarification qui            ',&
'serait ncessaire.                                                            ',&
'                                                                               ',&
'                                                                               ',&
'    Article 1 - DEFINITIONS                                                    ',&
'                                                                               ',&
'Dans ce contrat, les termes suivants, lorsqu''ils seront crits avec une      ',&
'lettre capitale, auront la signification suivante:                             ',&
'                                                                               ',&
'Contrat: dsigne le prsent contrat de licence, ses ventuelles versions    ',&
'postrieures et annexes.                                                      ',&
'                                                                               ',&
'Logiciel: dsigne le logiciel sous sa forme de Code Objet et/ou de Code       ',&
'Source et le cas chant sa documentation, dans leur tat au moment de      ',&
'l''acceptation du Contrat par le Licenci.                                    ',&
'                                                                               ',&
'Logiciel Initial: dsigne le Logiciel sous sa forme de Code Source et         ',&
'ventuellement de Code Objet et le cas chant sa documentation, dans       ',&
'leur tat au moment de leur premire diffusion sous les termes du Contrat.   ',&
'                                                                               ',&
'Logiciel Modifi: dsigne le Logiciel modifi par au moins une              ',&
'Contribution.                                                                  ',&
'                                                                               ',&
'Code Source: dsigne l''ensemble des instructions et des lignes de            ',&
'programme du Logiciel et auquel l''accs est ncessaire en vue de            ',&
'modifier le Logiciel.                                                          ',&
'                                                                               ',&
'Code Objet: dsigne les fichiers binaires issus de la compilation du          ',&
'Code Source.                                                                   ',&
'                                                                               ',&
'Titulaire: dsigne le ou les dtenteurs des droits patrimoniaux d''auteur    ',&
'sur le Logiciel Initial.                                                       ',&
'                                                                               ',&
'Licenci: dsigne le ou les utilisateurs du Logiciel ayant accept le       ',&
'Contrat.                                                                       ',&
'                                                                               ',&
'Contributeur: dsigne le Licenci auteur d''au moins une Contribution.       ',&
'                                                                               ',&
'Concdant: dsigne le Titulaire ou toute personne physique ou morale         ',&
'distribuant le Logiciel sous le Contrat.                                       ',&
'                                                                               ',&
'Contribution: dsigne l''ensemble des modifications, corrections,             ',&
'traductions, adaptations et/ou nouvelles fonctionnalits intgres dans     ',&
'le Logiciel par tout Contributeur, ainsi que tout Module Interne.              ',&
'                                                                               ',&
'Module: dsigne un ensemble de fichiers sources y compris leur                ',&
'documentation qui permet de raliser des fonctionnalits ou services         ',&
'supplmentaires  ceux fournis par le Logiciel.                              ',&
'                                                                               ',&
'Module Externe: dsigne tout Module, non driv du Logiciel, tel que ce     ',&
'Module et le Logiciel s''excutent dans des espaces d''adressage              ',&
'diffrents, l''un appelant l''autre au moment de leur excution.             ',&
'                                                                               ',&
'Module Interne: dsigne tout Module li au Logiciel de telle sorte           ',&
'qu''ils s''excutent dans le mme espace d''adressage.                       ',&
'                                                                               ',&
'GNU GPL: dsigne la GNU General Public License dans sa version 2 ou           ',&
'toute version ultrieure, telle que publie par Free Software Foundation     ',&
'Inc.                                                                           ',&
'                                                                               ',&
'GNU Affero GPL: dsigne la GNU Affero General Public License dans sa          ',&
'version 3 ou toute version ultrieure, telle que publie par Free            ',&
'Software Foundation Inc.                                                       ',&
'                                                                               ',&
'EUPL: dsigne la Licence Publique de l''Union europenne dans sa version     ',&
'1.1 ou toute version ultrieure, telle que publie par la Commission         ',&
'Europenne.                                                                   ',&
'                                                                               ',&
'Parties: dsigne collectivement le Licenci et le Concdant.                ',&
'                                                                               ',&
'Ces termes s''entendent au singulier comme au pluriel.                         ',&
'                                                                               ',&
'                                                                               ',&
'    Article 2 - OBJET                                                          ',&
'                                                                               ',&
'Le Contrat a pour objet la concession par le Concdant au Licenci d''une    ',&
'licence non exclusive, cessible et mondiale du Logiciel telle que              ',&
'dfinie ci-aprs  l''article 5 <#etendue> pour toute la dure de          ',&
'protection des droits portant sur ce Logiciel.                                 ',&
'                                                                               ',&
'                                                                               ',&
'    Article 3 - ACCEPTATION                                                    ',&
'                                                                               ',&
'3.1 L''acceptation par le Licenci des termes du Contrat est rpute        ',&
'acquise du fait du premier des faits suivants:                                 ',&
'                                                                               ',&
'  * (i) le chargement du Logiciel par tout moyen notamment par                 ',&
'    tlchargement  partir d''un serveur distant ou par chargement       ',&
'    partir d''un support physique;                                             ',&
'  * (ii) le premier exercice par le Licenci de l''un quelconque des          ',&
'    droits concds par le Contrat.                                          ',&
'                                                                               ',&
'3.2 Un exemplaire du Contrat, contenant notamment un avertissement             ',&
'relatif aux spcificits du Logiciel,  la restriction de garantie et     ',&
'la limitation  un usage par des utilisateurs expriments a t mis    ',&
'disposition du Licenci pralablement  son acceptation telle que           ',&
'dfinie  l''article 3.1 <#acceptation-acquise> ci dessus et le Licenci    ',&
'reconnat en avoir pris connaissance.                                         ',&
'                                                                               ',&
'                                                                               ',&
'    Article 4 - ENTREE EN VIGUEUR ET DUREE                                     ',&
'                                                                               ',&
'                                                                               ',&
'      4.1 ENTREE EN VIGUEUR                                                    ',&
'                                                                               ',&
'Le Contrat entre en vigueur  la date de son acceptation par le Licenci     ',&
'telle que dfinie en 3.1 <#acceptation-acquise>.                              ',&
'                                                                               ',&
'                                                                               ',&
'      4.2 DUREE                                                                ',&
'                                                                               ',&
'Le Contrat produira ses effets pendant toute la dure lgale de              ',&
'protection des droits patrimoniaux portant sur le Logiciel.                    ',&
'                                                                               ',&
'                                                                               ',&
'    Article 5 - ETENDUE DES DROITS CONCEDES                                    ',&
'                                                                               ',&
'Le Concdant concde au Licenci, qui accepte, les droits suivants sur      ',&
'le Logiciel pour toutes destinations et pour la dure du Contrat dans         ',&
'les conditions ci-aprs dtailles.                                         ',&
'                                                                               ',&
'Par ailleurs, si le Concdant dtient ou venait  dtenir un ou            ',&
'plusieurs brevets d''invention protgeant tout ou partie des                  ',&
'fonctionnalits du Logiciel ou de ses composants, il s''engage  ne pas      ',&
'opposer les ventuels droits confrs par ces brevets aux Licencis        ',&
'successifs qui utiliseraient, exploiteraient ou modifieraient le               ',&
'Logiciel. En cas de cession de ces brevets, le Concdant s''engage          ',&
'faire reprendre les obligations du prsent alina aux cessionnaires.         ',&
'                                                                               ',&
'                                                                               ',&
'      5.1 DROIT D''UTILISATION                                                 ',&
'                                                                               ',&
'Le Licenci est autoris  utiliser le Logiciel, sans restriction quant     ',&
'aux domaines d''application, tant ci-aprs prcis que cela comporte:     ',&
'                                                                               ',&
' 1.                                                                            ',&
'                                                                               ',&
'    la reproduction permanente ou provisoire du Logiciel en tout ou            ',&
'    partie par tout moyen et sous toute forme.                                 ',&
'                                                                               ',&
' 2.                                                                            ',&
'                                                                               ',&
'    le chargement, l''affichage, l''excution, ou le stockage du Logiciel     ',&
'    sur tout support.                                                          ',&
'                                                                               ',&
' 3.                                                                            ',&
'                                                                               ',&
'    la possibilit d''en observer, d''en tudier, ou d''en tester le         ',&
'    fonctionnement afin de dterminer les ides et principes qui sont      ',&
'    la base de n''importe quel lment de ce Logiciel; et ceci, lorsque      ',&
'    le Licenci effectue toute opration de chargement, d''affichage,        ',&
'    d''excution, de transmission ou de stockage du Logiciel qu''il est en    ',&
'    droit d''effectuer en vertu du Contrat.                                    ',&
'                                                                               ',&
'                                                                               ',&
'      5.2 DROIT D''APPORTER DES CONTRIBUTIONS                                  ',&
'                                                                               ',&
'Le droit d''apporter des Contributions comporte le droit de traduire,          ',&
'd''adapter, d''arranger ou d''apporter toute autre modification au Logiciel    ',&
'et le droit de reproduire le logiciel en rsultant.                           ',&
'                                                                               ',&
'Le Licenci est autoris  apporter toute Contribution au Logiciel sous     ',&
'rserve de mentionner, de faon explicite, son nom en tant qu''auteur de     ',&
'cette Contribution et la date de cration de celle-ci.                        ',&
'                                                                               ',&
'                                                                               ',&
'      5.3 DROIT DE DISTRIBUTION                                                ',&
'                                                                               ',&
'Le droit de distribution comporte notamment le droit de diffuser, de           ',&
'transmettre et de communiquer le Logiciel au public sur tout support et        ',&
'par tout moyen ainsi que le droit de mettre sur le march  titre            ',&
'onreux ou gratuit, un ou des exemplaires du Logiciel par tout procd.     ',&
'                                                                               ',&
'Le Licenci est autoris  distribuer des copies du Logiciel, modifi ou   ',&
'non,  des tiers dans les conditions ci-aprs dtailles.                  ',&
'                                                                               ',&
'                                                                               ',&
'        5.3.1 DISTRIBUTION DU LOGICIEL SANS MODIFICATION                       ',&
'                                                                               ',&
'Le Licenci est autoris  distribuer des copies conformes du Logiciel,     ',&
'sous forme de Code Source ou de Code Objet,  condition que cette             ',&
'distribution respecte les dispositions du Contrat dans leur totalit et       ',&
'soit accompagne:                                                             ',&
'                                                                               ',&
' 1.                                                                            ',&
'                                                                               ',&
'    d''un exemplaire du Contrat,                                               ',&
'                                                                               ',&
' 2.                                                                            ',&
'                                                                               ',&
'    d''un avertissement relatif  la restriction de garantie et de            ',&
'    responsabilit du Concdant telle que prvue aux articles 8             ',&
'    <#responsabilite> et 9 <#garantie>,                                        ',&
'                                                                               ',&
'et que, dans le cas o seul le Code Objet du Logiciel est redistribu,       ',&
'le Licenci permette un accs effectif au Code Source complet du             ',&
'Logiciel pour une dure d''au moins 3 ans  compter de la distribution du    ',&
'logiciel, tant entendu que le cot additionnel d''acquisition du Code       ',&
'Source ne devra pas excder le simple cot de transfert des donnes.        ',&
'                                                                               ',&
'                                                                               ',&
'        5.3.2 DISTRIBUTION DU LOGICIEL MODIFIE                                 ',&
'                                                                               ',&
'Lorsque le Licenci apporte une Contribution au Logiciel, les conditions      ',&
'de distribution du Logiciel Modifi en rsultant sont alors soumises       ',&
'l''intgralit des dispositions du Contrat.                                  ',&
'                                                                               ',&
'Le Licenci est autoris  distribuer le Logiciel Modifi, sous forme de   ',&
'code source ou de code objet,  condition que cette distribution              ',&
'respecte les dispositions du Contrat dans leur totalit et soit               ',&
'accompagne:                                                                  ',&
'                                                                               ',&
' 1.                                                                            ',&
'                                                                               ',&
'    d''un exemplaire du Contrat,                                               ',&
'                                                                               ',&
' 2.                                                                            ',&
'                                                                               ',&
'    d''un avertissement relatif  la restriction de garantie et de            ',&
'    responsabilit du Concdant telle que prvue aux articles 8             ',&
'    <#responsabilite> et 9 <#garantie>,                                        ',&
'                                                                               ',&
'et, dans le cas o seul le code objet du Logiciel Modifi est redistribu,  ',&
'                                                                               ',&
' 3.                                                                            ',&
'                                                                               ',&
'    d''une note prcisant les conditions d''accs effectif au code source    ',&
'    complet du Logiciel Modifi, pendant une priode d''au moins 3 ans     ',&
'    compter de la distribution du Logiciel Modifi, tant entendu que le     ',&
'    cot additionnel d''acquisition du code source ne devra pas excder      ',&
'    le simple cot de transfert des donnes.                                 ',&
'                                                                               ',&
'                                                                               ',&
'        5.3.3 DISTRIBUTION DES MODULES EXTERNES                                ',&
'                                                                               ',&
'Lorsque le Licenci a dvelopp un Module Externe les conditions du         ',&
'Contrat ne s''appliquent pas  ce Module Externe, qui peut tre distribu   ',&
'sous un contrat de licence diffrent.                                         ',&
'                                                                               ',&
'                                                                               ',&
'        5.3.4 COMPATIBILITE AVEC D''AUTRES LICENCES                            ',&
'                                                                               ',&
'Le Licenci peut inclure un code soumis aux dispositions d''une des           ',&
'versions de la licence GNU GPL, GNU Affero GPL et/ou EUPL dans le              ',&
'Logiciel modifi ou non et distribuer l''ensemble sous les conditions de      ',&
'la mme version de la licence GNU GPL, GNU Affero GPL et/ou EUPL.             ',&
'                                                                               ',&
'Le Licenci peut inclure le Logiciel modifi ou non dans un code soumis      ',&
'aux dispositions d''une des versions de la licence GNU GPL, GNU Affero         ',&
'GPL et/ou EUPL et distribuer l''ensemble sous les conditions de la mme       ',&
'version de la licence GNU GPL, GNU Affero GPL et/ou EUPL.                      ',&
'                                                                               ',&
'                                                                               ',&
'    Article 6 - PROPRIETE INTELLECTUELLE                                       ',&
'                                                                               ',&
'                                                                               ',&
'      6.1 SUR LE LOGICIEL INITIAL                                              ',&
'                                                                               ',&
'Le Titulaire est dtenteur des droits patrimoniaux sur le Logiciel            ',&
'Initial. Toute utilisation du Logiciel Initial est soumise au respect          ',&
'des conditions dans lesquelles le Titulaire a choisi de diffuser son           ',&
'oeuvre et nul autre n''a la facult de modifier les conditions de             ',&
'diffusion de ce Logiciel Initial.                                              ',&
'                                                                               ',&
'Le Titulaire s''engage  ce que le Logiciel Initial reste au moins rgi      ',&
'par le Contrat et ce, pour la dure vise  l''article 4.2 <#duree>.        ',&
'                                                                               ',&
'                                                                               ',&
'      6.2 SUR LES CONTRIBUTIONS                                                ',&
'                                                                               ',&
'Le Licenci qui a dvelopp une Contribution est titulaire sur celle-ci     ',&
'des droits de proprit intellectuelle dans les conditions dfinies par     ',&
'la lgislation applicable.                                                    ',&
'                                                                               ',&
'                                                                               ',&
'      6.3 SUR LES MODULES EXTERNES                                             ',&
'                                                                               ',&
'Le Licenci qui a dvelopp un Module Externe est titulaire sur celui-ci    ',&
'des droits de proprit intellectuelle dans les conditions dfinies par     ',&
'la lgislation applicable et reste libre du choix du contrat rgissant       ',&
'sa diffusion.                                                                  ',&
'                                                                               ',&
'                                                                               ',&
'      6.4 DISPOSITIONS COMMUNES                                                ',&
'                                                                               ',&
'Le Licenci s''engage expressment:                                          ',&
'                                                                               ',&
' 1.                                                                            ',&
'                                                                               ',&
'     ne pas supprimer ou modifier de quelque manire que ce soit les        ',&
'    mentions de proprit intellectuelle apposes sur le Logiciel;          ',&
'                                                                               ',&
' 2.                                                                            ',&
'                                                                               ',&
'     reproduire  l''identique lesdites mentions de proprit             ',&
'    intellectuelle sur les copies du Logiciel modifi ou non.                 ',&
'                                                                               ',&
'Le Licenci s''engage  ne pas porter atteinte, directement ou               ',&
'indirectement, aux droits de proprit intellectuelle du Titulaire et/ou     ',&
'des Contributeurs sur le Logiciel et  prendre, le cas chant,           ',&
'l''gard de son personnel toutes les mesures ncessaires pour assurer le     ',&
'respect des dits droits de proprit intellectuelle du Titulaire et/ou       ',&
'des Contributeurs.                                                             ',&
'                                                                               ',&
'                                                                               ',&
'    Article 7 - SERVICES ASSOCIES                                              ',&
'                                                                               ',&
'7.1 Le Contrat n''oblige en aucun cas le Concdant  la ralisation de      ',&
'prestations d''assistance technique ou de maintenance du Logiciel.             ',&
'                                                                               ',&
'Cependant le Concdant reste libre de proposer ce type de services. Les       ',&
'termes et conditions d''une telle assistance technique et/ou d''une telle      ',&
'maintenance seront alors dtermins dans un acte spar. Ces actes de      ',&
'maintenance et/ou assistance technique n''engageront que la seule              ',&
'responsabilit du Concdant qui les propose.                                 ',&
'                                                                               ',&
'7.2 De mme, tout Concdant est libre de proposer, sous sa seule             ',&
'responsabilit,  ses licencis une garantie, qui n''engagera que lui,      ',&
'lors de la redistribution du Logiciel et/ou du Logiciel Modifi et ce,        ',&
'dans les conditions qu''il souhaite. Cette garantie et les modalits          ',&
'financires de son application feront l''objet d''un acte spar entre le   ',&
'Concdant et le Licenci.                                                    ',&
'                                                                               ',&
'                                                                               ',&
'    Article 8 - RESPONSABILITE                                                 ',&
'                                                                               ',&
'8.1 Sous rserve des dispositions de l''article 8.2                           ',&
'<#limite-responsabilite>, le Licenci a la facult, sous rserve de         ',&
'prouver la faute du Concdant concern, de solliciter la rparation du      ',&
'prjudice direct qu''il subirait du fait du Logiciel et dont il apportera     ',&
'la preuve.                                                                     ',&
'                                                                               ',&
'8.2 La responsabilit du Concdant est limite aux engagements pris en      ',&
'application du Contrat et ne saurait tre engage en raison notamment:       ',&
'(i) des dommages dus  l''inexcution, totale ou partielle, de ses           ',&
'obligations par le Licenci, (ii) des dommages directs ou indirects           ',&
'dcoulant de l''utilisation ou des performances du Logiciel subis par le      ',&
'Licenci et (iii) plus gnralement d''un quelconque dommage indirect. En   ',&
'particulier, les Parties conviennent expressment que tout prjudice         ',&
'financier ou commercial (par exemple perte de donnes, perte de               ',&
'bnfices, perte d''exploitation, perte de clientle ou de commandes,       ',&
'manque  gagner, trouble commercial quelconque) ou toute action dirige      ',&
'contre le Licenci par un tiers, constitue un dommage indirect et             ',&
'n''ouvre pas droit  rparation par le Concdant.                           ',&
'                                                                               ',&
'                                                                               ',&
'    Article 9 - GARANTIE                                                       ',&
'                                                                               ',&
'9.1 Le Licenci reconnat que l''tat actuel des connaissances              ',&
'scientifiques et techniques au moment de la mise en circulation du             ',&
'Logiciel ne permet pas d''en tester et d''en vrifier toutes les              ',&
'utilisations ni de dtecter l''existence d''ventuels dfauts. L''attention ',&
'du Licenci a t attire sur ce point sur les risques associs au        ',&
'chargement,  l''utilisation, la modification et/ou au dveloppement et    ',&
'la reproduction du Logiciel qui sont rservs  des utilisateurs avertis.   ',&
'                                                                               ',&
'Il relve de la responsabilit du Licenci de contrler, par tous          ',&
'moyens, l''adquation du produit  ses besoins, son bon fonctionnement et    ',&
'de s''assurer qu''il ne causera pas de dommages aux personnes et aux biens.    ',&
'                                                                               ',&
'9.2 Le Concdant dclare de bonne foi tre en droit de concder            ',&
'l''ensemble des droits attachs au Logiciel (comprenant notamment les         ',&
'droits viss  l''article 5 <#etendue>).                                     ',&
'                                                                               ',&
'9.3 Le Licenci reconnat que le Logiciel est fourni "en l''tat" par le    ',&
'Concdant sans autre garantie, expresse ou tacite, que celle prvue        ',&
'l''article 9.2 <#bonne-foi> et notamment sans aucune garantie sur sa           ',&
'valeur commerciale, son caractre scuris, innovant ou pertinent.          ',&
'                                                                               ',&
'En particulier, le Concdant ne garantit pas que le Logiciel est exempt       ',&
'd''erreur, qu''il fonctionnera sans interruption, qu''il sera compatible       ',&
'avec l''quipement du Licenci et sa configuration logicielle ni qu''il      ',&
'remplira les besoins du Licenci.                                             ',&
'                                                                               ',&
'9.4 Le Concdant ne garantit pas, de manire expresse ou tacite, que le      ',&
'Logiciel ne porte pas atteinte  un quelconque droit de proprit           ',&
'intellectuelle d''un tiers portant sur un brevet, un logiciel ou sur tout      ',&
'autre droit de proprit. Ainsi, le Concdant exclut toute garantie au      ',&
'profit du Licenci contre les actions en contrefaon qui pourraient tre    ',&
'diligentes au titre de l''utilisation, de la modification, et de la          ',&
'redistribution du Logiciel. Nanmoins, si de telles actions sont              ',&
'exerces contre le Licenci, le Concdant lui apportera son expertise       ',&
'technique et juridique pour sa dfense. Cette expertise technique et          ',&
'juridique est dtermine au cas par cas entre le Concdant concern et     ',&
'le Licenci dans le cadre d''un protocole d''accord. Le Concdant dgage    ',&
'toute responsabilit quant  l''utilisation de la dnomination du           ',&
'Logiciel par le Licenci. Aucune garantie n''est apporte quant            ',&
'l''existence de droits antrieurs sur le nom du Logiciel et sur               ',&
'l''existence d''une marque.                                                    ',&
'                                                                               ',&
'                                                                               ',&
'    Article 10 - RESILIATION                                                   ',&
'                                                                               ',&
'10.1 En cas de manquement par le Licenci aux obligations mises  sa         ',&
'charge par le Contrat, le Concdant pourra rsilier de plein droit le        ',&
'Contrat trente (30) jours aprs notification adresse au Licenci et        ',&
'reste sans effet.                                                            ',&
'                                                                               ',&
'10.2 Le Licenci dont le Contrat est rsili n''est plus autoris        ',&
'utiliser, modifier ou distribuer le Logiciel. Cependant, toutes les            ',&
'licences qu''il aura concdes antrieurement  la rsiliation du Contrat ',&
'resteront valides sous rserve qu''elles aient t effectues en           ',&
'conformit avec le Contrat.                                                   ',&
'                                                                               ',&
'                                                                               ',&
'    Article 11 - DISPOSITIONS DIVERSES                                         ',&
'                                                                               ',&
'                                                                               ',&
'      11.1 CAUSE EXTERIEURE                                                    ',&
'                                                                               ',&
'Aucune des Parties ne sera responsable d''un retard ou d''une dfaillance     ',&
'd''excution du Contrat qui serait d  un cas de force majeure, un cas     ',&
'fortuit ou une cause extrieure, telle que, notamment, le mauvais             ',&
'fonctionnement ou les interruptions du rseau lectrique ou de               ',&
'tlcommunication, la paralysie du rseau lie  une attaque              ',&
'informatique, l''intervention des autorits gouvernementales, les             ',&
'catastrophes naturelles, les dgts des eaux, les tremblements de terre,     ',&
'le feu, les explosions, les grves et les conflits sociaux, l''tat de       ',&
'guerre...                                                                      ',&
'                                                                               ',&
'11.2 Le fait, par l''une ou l''autre des Parties, d''omettre en une ou         ',&
'plusieurs occasions de se prvaloir d''une ou plusieurs dispositions du       ',&
'Contrat, ne pourra en aucun cas impliquer renonciation par la Partie           ',&
'intresse  s''en prvaloir ultrieurement.                              ',&
'                                                                               ',&
'11.3 Le Contrat annule et remplace toute convention antrieure, crite       ',&
'ou orale, entre les Parties sur le mme objet et constitue l''accord          ',&
'entier entre les Parties sur cet objet. Aucune addition ou modification        ',&
'aux termes du Contrat n''aura d''effet  l''gard des Parties  moins       ',&
'd''tre faite par crit et signe par leurs reprsentants dment habilits.',&
'                                                                                 ',&
'11.4 Dans l''hypothse o une ou plusieurs des dispositions du Contrat         ',&
's''avrerait contraire  une loi ou  un texte applicable, existants ou       ',&
'futurs, cette loi ou ce texte prvaudrait, et les Parties feraient les          ',&
'amendements ncessaires pour se conformer  cette loi ou  ce texte.          ',&
'Toutes les autres dispositions resteront en vigueur. De mme, la                ',&
'nullit, pour quelque raison que ce soit, d''une des dispositions du            ',&
'Contrat ne saurait entraner la nullit de l''ensemble du Contrat.             ',&
'                                                                                 ',&
'                                                                                 ',&
'      11.5 LANGUE                                                                ',&
'                                                                                 ',&
'Le Contrat est rdig en langue franaise et en langue anglaise, ces          ',&
'deux versions faisant galement foi.                                            ',&
'                                                                                 ',&
'                                                                                 ',&
'    Article 12 - NOUVELLES VERSIONS DU CONTRAT                                   ',&
'                                                                                 ',&
'12.1 Toute personne est autorise  copier et distribuer des copies de         ',&
'ce Contrat.                                                                      ',&
'                                                                                 ',&
'12.2 Afin d''en prserver la cohrence, le texte du Contrat est protg      ',&
'et ne peut tre modifi que par les auteurs de la licence, lesquels se         ',&
'rservent le droit de publier priodiquement des mises  jour ou de           ',&
'nouvelles versions du Contrat, qui possderont chacune un numro               ',&
'distinct. Ces versions ultrieures seront susceptibles de prendre en            ',&
'compte de nouvelles problmatiques rencontres par les logiciels libres.       ',&
'                                                                                 ',&
'12.3 Tout Logiciel diffus sous une version donne du Contrat ne pourra        ',&
'faire l''objet d''une diffusion ultrieure que sous la mme version du         ',&
'Contrat ou une version postrieure, sous rserve des dispositions de           ',&
'l''article 5.3.4 <#compatibilite>.                                               ',&
'                                                                                 ',&
'                                                                                 ',&
'    Article 13 - LOI APPLICABLE ET COMPETENCE TERRITORIALE                       ',&
'                                                                                 ',&
'13.1 Le Contrat est rgi par la loi franaise. Les Parties conviennent         ',&
'de tenter de rgler  l''amiable les diffrends ou litiges qui                ',&
'viendraient  se produire par suite ou  l''occasion du Contrat.               ',&
'                                                                                 ',&
'13.2 A dfaut d''accord amiable dans un dlai de deux (2) mois  compter      ',&
'de leur survenance et sauf situation relevant d''une procdure d''urgence,      ',&
'les diffrends ou litiges seront ports par la Partie la plus diligente        ',&
'devant les Tribunaux comptents de Paris.                                       ',&
'                                                                                 ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('17','cern-ohl-p-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'cern-ohl-p-2.0',&
'              ',&
'CERN Open Hardware Licence Version 2 - Permissive',&
'                                                 ',&
'                                                 ',&
'Preamble                                         ',&
'                                                 ',&
'CERN has developed this licence to promote collaboration among hardware',&
'designers and to provide a legal tool which supports the freedom to use,',&
'study, modify, share and distribute hardware designs and products based on',&
'those designs. Version 2 of the CERN Open Hardware Licence comes in three ',&
'variants: this licence, CERN-OHL-P (permissive); and two reciprocal licences:',&
'CERN-OHL-W (weakly reciprocal) and CERN-OHL-S (strongly reciprocal).         ',&
'                                                                             ',&
'The CERN-OHL-P is copyright CERN 2020. Anyone is welcome to use it, in       ',&
'unmodified form only.                                                        ',&
'                                                                             ',&
'Use of this Licence does not imply any endorsement by CERN of any Licensor or',&
'their designs nor does it imply any involvement by CERN in their development.',&
'                                                                             ',&
'                                                                             ',&
'1 Definitions                                                                ',&
'                                                                             ',&
'  1.1 ''Licence'' means this CERN-OHL-P.                                     ',&
'                                                                             ',&
'  1.2 ''Source'' means information such as design materials or digital code  ',&
'      which can be applied to Make or test a Product or to prepare a Product ',&
'      for use, Conveyance or sale, regardless of its medium or how it is     ',&
'      expressed. It may include Notices.                                     ',&
'                                                                             ',&
'  1.3 ''Covered Source'' means Source that is explicitly made available under',&
'      this Licence.                                                          ',&
'                                                                             ',&
'  1.4 ''Product'' means any device, component, work or physical object, whether',&
'      in finished or intermediate form, arising from the use, application or   ',&
'      processing of Covered Source.                                            ',&
'                                                                               ',&
'  1.5 ''Make'' means to create or configure something, whether by manufacture, ',&
'      assembly, compiling, loading or applying Covered Source or another       ',&
'      Product or otherwise.                                                    ',&
'                                                                               ',&
'  1.6 ''Notice'' means copyright, acknowledgement and trademark notices,       ',&
'      references to the location of any Notices, modification notices          ',&
'      (subsection 3.3(b)) and all notices that refer to this Licence and to    ',&
'      the disclaimer of warranties that are included in the Covered Source.    ',&
'                                                                               ',&
'  1.7 ''Licensee'' or ''You'' means any person exercising rights under this    ',&
'      Licence.                                                                 ',&
'                                                                               ',&
'  1.8 ''Licensor'' means a person who creates Source or modifies Covered Source',&
'      and subsequently Conveys the resulting Covered Source under the terms    ',&
'      and conditions of this Licence. A person may be a Licensee and a         ',&
'      Licensor at the same time.                                               ',&
'                                                                               ',&
'  1.9 ''Convey'' means to communicate to the public or distribute.             ',&
'                                                                               ',&
'                                                                               ',&
'2 Applicability                                                                ',&
'                                                                               ',&
'  2.1 This Licence governs the use, copying, modification, Conveying of        ',&
'      Covered Source and Products, and the Making of Products. By exercising   ',&
'      any right granted under this Licence, You irrevocably accept these terms ',&
'      and conditions.                                                          ',&
'                                                                               ',&
'  2.2 This Licence is granted by the Licensor directly to You, and shall apply ',&
'      worldwide and without limitation in time.                                ',&
'                                                                               ',&
'  2.3 You shall not attempt to restrict by contract or otherwise the rights    ',&
'      granted under this Licence to other Licensees.                           ',&
'                                                                               ',&
'  2.4 This Licence is not intended to restrict fair use, fair dealing, or any  ',&
'      other similar right.                                                     ',&
'                                                                               ',&
'                                                                               ',&
'3 Copying, Modifying and Conveying Covered Source                              ',&
'                                                                               ',&
'  3.1 You may copy and Convey verbatim copies of Covered Source, in any        ',&
'      medium, provided You retain all Notices.                                 ',&
'                                                                               ',&
'  3.2 You may modify Covered Source, other than Notices.                       ',&
'                                                                               ',&
'      You may only delete Notices if they are no longer applicable to the      ',&
'      corresponding Covered Source as modified by You and You may add          ',&
'      additional Notices applicable to Your modifications.                     ',&
'                                                                               ',&
'  3.3 You may Convey modified Covered Source (with the effect that You shall   ',&
'      also become a Licensor) provided that You:                               ',&
'                                                                               ',&
'       a) retain Notices as required in subsection 3.2; and                    ',&
'                                                                               ',&
'       b) add a Notice to the modified Covered Source stating that You have    ',&
'          modified it, with the date and brief description of how You have     ',&
'          modified it.                                                         ',&
'                                                                               ',&
'  3.4 You may Convey Covered Source or modified Covered Source under licence   ',&
'      terms which differ from the terms of this Licence provided that You:     ',&
'                                                                               ',&
'       a) comply at all times with subsection 3.3; and                         ',&
'                                                                               ',&
'       b) provide a copy of this Licence to anyone to whom You Convey Covered  ',&
'          Source or modified Covered Source.                                   ',&
'                                                                               ',&
'                                                                               ',&
'4 Making and Conveying Products                                                ',&
'                                                                               ',&
'You may Make Products, and/or Convey them, provided that You ensure that the   ',&
'recipient of the Product has access to any Notices applicable to the Product.  ',&
'                                                                               ',&
'                                                                               ',&
'5 DISCLAIMER AND LIABILITY                                                     ',&
'                                                                               ',&
'  5.1 DISCLAIMER OF WARRANTY -- The Covered Source and any Products are        ',&
'      provided ''as is'' and any express or implied warranties, including, but ',&
'      not limited to, implied warranties of merchantability, of satisfactory   ',&
'      quality, non-infringement of third party rights, and fitness for a       ',&
'      particular purpose or use are disclaimed in respect of any Source or     ',&
'      Product to the maximum extent permitted by law. The Licensor makes no    ',&
'      representation that any Source or Product does not or will not infringe  ',&
'      any patent, copyright, trade secret or other proprietary right. The      ',&
'      entire risk as to the use, quality, and performance of any Source or     ',&
'      Product shall be with You and not the Licensor. This disclaimer of       ',&
'      warranty is an essential part of this Licence and a condition for the    ',&
'      grant of any rights granted under this Licence.                          ',&
'                                                                               ',&
'  5.2 EXCLUSION AND LIMITATION OF LIABILITY -- The Licensor shall, to the      ',&
'      maximum extent permitted by law, have no liability for direct, indirect, ',&
'      special, incidental, consequential, exemplary, punitive or other damages ',&
'      of any character including, without limitation, procurement of           ',&
'      substitute goods or services, loss of use, data or profits, or business  ',&
'      interruption, however caused and on any theory of contract, warranty,    ',&
'      tort (including negligence), product liability or otherwise, arising in  ',&
'      any way in relation to the Covered Source, modified Covered Source       ',&
'      and/or the Making or Conveyance of a Product, even if advised of the     ',&
'      possibility of such damages, and You shall hold the Licensor(s) free and ',&
'      harmless from any liability, costs, damages, fees and expenses,          ',&
'      including claims by third parties, in relation to such use.              ',&
'                                                                               ',&
'                                                                               ',&
'6 Patents                                                                      ',&
'                                                                               ',&
'  6.1 Subject to the terms and conditions of this Licence, each Licensor       ',&
'      hereby grants to You a perpetual, worldwide, non-exclusive, no-charge,   ',&
'      royalty-free, irrevocable (except as stated in this section 6, or where  ',&
'      terminated by the Licensor for cause) patent licence to Make, have Made, ',&
'      use, offer to sell, sell, import, and otherwise transfer the Covered     ',&
'      Source and Products, where such licence applies only to those patent     ',&
'      claims licensable by such Licensor that are necessarily infringed by     ',&
'      exercising rights under the Covered Source as Conveyed by that Licensor. ',&
'                                                                               ',&
'  6.2 If You institute patent litigation against any entity (including a       ',&
'      cross-claim or counterclaim in a lawsuit) alleging that the Covered      ',&
'      Source or a Product constitutes direct or contributory patent            ',&
'      infringement, or You seek any declaration that a patent licensed to You  ',&
'      under this Licence is invalid or unenforceable then any rights granted   ',&
'      to You under this Licence shall terminate as of the date such process is ',&
'      initiated.                                                               ',&
'                                                                               ',&
'                                                                               ',&
'7 General                                                                      ',&
'                                                                               ',&
'  7.1 If any provisions of this Licence are or subsequently become invalid or  ',&
'      unenforceable for any reason, the remaining provisions shall remain      ',&
'      effective.                                                               ',&
'                                                                               ',&
'  7.2 You shall not use any of the name (including acronyms and                ',&
'      abbreviations), image, or logo by which the Licensor or CERN is known,   ',&
'      except where needed to comply with section 3, or where the use is        ',&
'      otherwise allowed by law. Any such permitted use shall be factual and    ',&
'      shall not be made so as to suggest any kind of endorsement or            ',&
'      implication of involvement by the Licensor or its personnel.             ',&
'                                                                               ',&
'  7.3 CERN may publish updated versions and variants of this Licence which it  ',&
'      considers to be in the spirit of this version, but may differ in detail  ',&
'      to address new problems or concerns. New versions will be published with ',&
'      a unique version number and a variant identifier specifying the variant. ',&
'      If the Licensor has specified that a given variant applies to the        ',&
'      Covered Source without specifying a version, You may treat that Covered  ',&
'      Source as being released under any version of the CERN-OHL with that     ',&
'      variant. If no variant is specified, the Covered Source shall be treated ',&
'      as being released under CERN-OHL-S. The Licensor may also specify that   ',&
'      the Covered Source is subject to a specific version of the CERN-OHL or   ',&
'      any later version in which case You may apply this or any later version  ',&
'      of CERN-OHL with the same variant identifier published by CERN.          ',&
'                                                                               ',&
'  7.4 This Licence shall not be enforceable except by a Licensor acting as     ',&
'      such, and third party beneficiary rights are specifically excluded.      ',&
'                                                                               ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('18','cern-ohl-s-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'cern-ohl-s-2.0',&
'              ',&
'CERN Open Hardware Licence Version 2 - Strongly Reciprocal',&
'                                                          ',&
'                                                          ',&
'Preamble                                                  ',&
'                                                          ',&
'CERN has developed this licence to promote collaboration among hardware',&
'designers and to provide a legal tool which supports the freedom to use,',&
'study, modify, share and distribute hardware designs and products based on',&
'those designs. Version 2 of the CERN Open Hardware Licence comes in three ',&
'variants: CERN-OHL-P (permissive); and two reciprocal licences: CERN-OHL-W',&
'(weakly reciprocal) and this licence, CERN-OHL-S (strongly reciprocal).   ',&
'                                                                          ',&
'The CERN-OHL-S is copyright CERN 2020. Anyone is welcome to use it, in    ',&
'unmodified form only.                                                     ',&
'                                                                          ',&
'Use of this Licence does not imply any endorsement by CERN of any Licensor or',&
'their designs nor does it imply any involvement by CERN in their development.',&
'                                                                             ',&
'                                                                             ',&
'1 Definitions                                                                ',&
'                                                                             ',&
'  1.1 ''Licence'' means this CERN-OHL-S.                                     ',&
'                                                                             ',&
'  1.2 ''Compatible Licence'' means                                           ',&
'                                                                             ',&
'       a) any earlier version of the CERN Open Hardware licence, or          ',&
'                                                                             ',&
'       b) any version of the CERN-OHL-S, or                                  ',&
'                                                                             ',&
'       c) any licence which permits You to treat the Source to which it      ',&
'          applies as licensed under CERN-OHL-S provided that on Conveyance of',&
'          any such Source, or any associated Product You treat the Source in ',&
'          question as being licensed under CERN-OHL-S.                       ',&
'                                                                             ',&
'  1.3 ''Source'' means information such as design materials or digital code  ',&
'      which can be applied to Make or test a Product or to prepare a Product ',&
'      for use, Conveyance or sale, regardless of its medium or how it is     ',&
'      expressed. It may include Notices.                                     ',&
'                                                                             ',&
'  1.4 ''Covered Source'' means Source that is explicitly made available under',&
'      this Licence.                                                          ',&
'                                                                             ',&
'  1.5 ''Product'' means any device, component, work or physical object, whether',&
'      in finished or intermediate form, arising from the use, application or   ',&
'      processing of Covered Source.                                            ',&
'                                                                               ',&
'  1.6 ''Make'' means to create or configure something, whether by manufacture, ',&
'      assembly, compiling, loading or applying Covered Source or another       ',&
'      Product or otherwise.                                                    ',&
'                                                                               ',&
'  1.7 ''Available Component'' means any part, sub-assembly, library or code    ',&
'      which:                                                                   ',&
'                                                                               ',&
'       a) is licensed to You as Complete Source under a Compatible Licence; or ',&
'                                                                               ',&
'       b) is available, at the time a Product or the Source containing it is   ',&
'          first Conveyed, to You and any other prospective licensees           ',&
'                                                                               ',&
'            i) as a physical part with sufficient rights and information       ',&
'               (including any configuration and programming files and          ',&
'               information about its characteristics and interfaces) to enable ',&
'               it either to be Made itself, or to be sourced and used to Make  ',&
'               the Product; or                                                 ',&
'           ii) as part of the normal distribution of a tool used to design or  ',&
'               Make the Product.                                               ',&
'                                                                               ',&
'  1.8 ''Complete Source'' means the set of all Source necessary to Make a      ',&
'      Product, in the preferred form for making modifications, including       ',&
'      necessary installation and interfacing information both for the Product, ',&
'      and for any included Available Components.  If the format is             ',&
'      proprietary, it must also be made available in a format (if the          ',&
'      proprietary tool can create it) which is viewable with a tool available  ',&
'      to potential licensees and licensed under a licence approved by the Free ',&
'      Software Foundation or the Open Source Initiative. Complete Source need  ',&
'      not include the Source of any Available Component, provided that You     ',&
'      include in the Complete Source sufficient information to enable a        ',&
'      recipient to Make or source and use the Available Component to Make the  ',&
'      Product.                                                                 ',&
'                                                                               ',&
'  1.9 ''Source Location'' means a location where a Licensor has placed Covered ',&
'      Source, and which that Licensor reasonably believes will remain easily   ',&
'      accessible for at least three years for anyone to obtain a digital copy. ',&
'                                                                               ',&
' 1.10 ''Notice'' means copyright, acknowledgement and trademark notices, Source',&
'      Location references, modification notices (subsection 3.3(b)) and all    ',&
'      notices that refer to this Licence and to the disclaimer of warranties   ',&
'      that are included in the Covered Source.                                 ',&
'                                                                               ',&
' 1.11 ''Licensee'' or ''You'' means any person exercising rights under this    ',&
'      Licence.                                                                 ',&
'                                                                               ',&
' 1.12 ''Licensor'' means a natural or legal person who creates or modifies     ',&
'      Covered Source. A person may be a Licensee and a Licensor at the same    ',&
'      time.                                                                    ',&
'                                                                               ',&
' 1.13 ''Convey'' means to communicate to the public or distribute.             ',&
'                                                                               ',&
'                                                                               ',&
'2 Applicability                                                                ',&
'                                                                               ',&
'  2.1 This Licence governs the use, copying, modification, Conveying of        ',&
'      Covered Source and Products, and the Making of Products. By exercising   ',&
'      any right granted under this Licence, You irrevocably accept these terms ',&
'      and conditions.                                                          ',&
'                                                                               ',&
'  2.2 This Licence is granted by the Licensor directly to You, and shall apply ',&
'      worldwide and without limitation in time.                                ',&
'                                                                               ',&
'  2.3 You shall not attempt to restrict by contract or otherwise the rights    ',&
'      granted under this Licence to other Licensees.                           ',&
'                                                                               ',&
'  2.4 This Licence is not intended to restrict fair use, fair dealing, or any  ',&
'      other similar right.                                                     ',&
'                                                                               ',&
'                                                                               ',&
'3 Copying, Modifying and Conveying Covered Source                              ',&
'                                                                               ',&
'  3.1 You may copy and Convey verbatim copies of Covered Source, in any        ',&
'      medium, provided You retain all Notices.                                 ',&
'                                                                               ',&
'  3.2 You may modify Covered Source, other than Notices, provided that You     ',&
'      irrevocably undertake to make that modified Covered Source available     ',&
'      from a Source Location should You Convey a Product in circumstances      ',&
'      where the recipient does not otherwise receive a copy of the modified    ',&
'      Covered Source. In each case subsection 3.3 shall apply.                 ',&
'                                                                               ',&
'      You may only delete Notices if they are no longer applicable to the      ',&
'      corresponding Covered Source as modified by You and You may add          ',&
'      additional Notices applicable to Your modifications.  Including Covered  ',&
'      Source in a larger work is modifying the Covered Source, and the larger  ',&
'      work becomes modified Covered Source.                                    ',&
'                                                                               ',&
'  3.3 You may Convey modified Covered Source (with the effect that You shall   ',&
'      also become a Licensor) provided that You:                               ',&
'                                                                               ',&
'       a) retain Notices as required in subsection 3.2;                        ',&
'                                                                               ',&
'       b) add a Notice to the modified Covered Source stating that You have    ',&
'          modified it, with the date and brief description of how You have     ',&
'          modified it;                                                         ',&
'                                                                               ',&
'       c) add a Source Location Notice for the modified Covered Source if You  ',&
'          Convey in circumstances where the recipient does not otherwise       ',&
'          receive a copy of the modified Covered Source; and                   ',&
'                                                                               ',&
'       d) license the modified Covered Source under the terms and conditions   ',&
'          of this Licence (or, as set out in subsection 8.3, a later version,  ',&
'          if permitted by the licence of the original Covered Source). Such    ',&
'          modified Covered Source must be licensed as a whole, but excluding   ',&
'          Available Components contained in it, which remain licensed under    ',&
'          their own applicable licences.                                       ',&
'                                                                               ',&
'                                                                               ',&
'4 Making and Conveying Products                                                ',&
'                                                                               ',&
'You may Make Products, and/or Convey them, provided that You either provide    ',&
'each recipient with a copy of the Complete Source or ensure that each          ',&
'recipient is notified of the Source Location of the Complete Source. That      ',&
'Complete Source is Covered Source, and You must accordingly satisfy Your       ',&
'obligations set out in subsection 3.3. If specified in a Notice, the Product   ',&
'must visibly and securely display the Source Location on it or its packaging   ',&
'or documentation in the manner specified in that Notice.                       ',&
'                                                                               ',&
'                                                                               ',&
'5 Research and Development                                                     ',&
'                                                                               ',&
'You may Convey Covered Source, modified Covered Source or Products to a legal  ',&
'entity carrying out development, testing or quality assurance work on Your     ',&
'behalf provided that the work is performed on terms which prevent the entity   ',&
'from both using the Source or Products for its own internal purposes and       ',&
'Conveying the Source or Products or any modifications to them to any person    ',&
'other than You. Any modifications made by the entity shall be deemed to be     ',&
'made by You pursuant to subsection 3.2.                                        ',&
'                                                                               ',&
'                                                                               ',&
'6 DISCLAIMER AND LIABILITY                                                     ',&
'                                                                               ',&
'  6.1 DISCLAIMER OF WARRANTY -- The Covered Source and any Products are        ',&
'      provided ''as is'' and any express or implied warranties, including, but ',&
'      not limited to, implied warranties of merchantability, of satisfactory   ',&
'      quality, non-infringement of third party rights, and fitness for a       ',&
'      particular purpose or use are disclaimed in respect of any Source or     ',&
'      Product to the maximum extent permitted by law. The Licensor makes no    ',&
'      representation that any Source or Product does not or will not infringe  ',&
'      any patent, copyright, trade secret or other proprietary right. The      ',&
'      entire risk as to the use, quality, and performance of any Source or     ',&
'      Product shall be with You and not the Licensor. This disclaimer of       ',&
'      warranty is an essential part of this Licence and a condition for the    ',&
'      grant of any rights granted under this Licence.                          ',&
'                                                                               ',&
'  6.2 EXCLUSION AND LIMITATION OF LIABILITY -- The Licensor shall, to the      ',&
'      maximum extent permitted by law, have no liability for direct, indirect, ',&
'      special, incidental, consequential, exemplary, punitive or other damages ',&
'      of any character including, without limitation, procurement of           ',&
'      substitute goods or services, loss of use, data or profits, or business  ',&
'      interruption, however caused and on any theory of contract, warranty,    ',&
'      tort (including negligence), product liability or otherwise, arising in  ',&
'      any way in relation to the Covered Source, modified Covered Source       ',&
'      and/or the Making or Conveyance of a Product, even if advised of the     ',&
'      possibility of such damages, and You shall hold the Licensor(s) free and ',&
'      harmless from any liability, costs, damages, fees and expenses,          ',&
'      including claims by third parties, in relation to such use.              ',&
'                                                                               ',&
'                                                                               ',&
'7 Patents                                                                      ',&
'                                                                               ',&
'  7.1 Subject to the terms and conditions of this Licence, each Licensor       ',&
'      hereby grants to You a perpetual, worldwide, non-exclusive, no-charge,   ',&
'      royalty-free, irrevocable (except as stated in subsections 7.2 and 8.4)  ',&
'      patent licence to Make, have Made, use, offer to sell, sell, import, and ',&
'      otherwise transfer the Covered Source and Products, where such licence   ',&
'      applies only to those patent claims licensable by such Licensor that are ',&
'      necessarily infringed by exercising rights under the Covered Source as   ',&
'      Conveyed by that Licensor.                                               ',&
'                                                                               ',&
'  7.2 If You institute patent litigation against any entity (including a       ',&
'      cross-claim or counterclaim in a lawsuit) alleging that the Covered      ',&
'      Source or a Product constitutes direct or contributory patent            ',&
'      infringement, or You seek any declaration that a patent licensed to You  ',&
'      under this Licence is invalid or unenforceable then any rights granted   ',&
'      to You under this Licence shall terminate as of the date such process is ',&
'      initiated.                                                               ',&
'                                                                               ',&
'                                                                               ',&
'8 General                                                                      ',&
'                                                                               ',&
'  8.1 If any provisions of this Licence are or subsequently become invalid or  ',&
'      unenforceable for any reason, the remaining provisions shall remain      ',&
'      effective.                                                               ',&
'                                                                               ',&
'  8.2 You shall not use any of the name (including acronyms and                ',&
'      abbreviations), image, or logo by which the Licensor or CERN is known,   ',&
'      except where needed to comply with section 3, or where the use is        ',&
'      otherwise allowed by law. Any such permitted use shall be factual and    ',&
'      shall not be made so as to suggest any kind of endorsement or            ',&
'      implication of involvement by the Licensor or its personnel.             ',&
'                                                                               ',&
'  8.3 CERN may publish updated versions and variants of this Licence which it  ',&
'      considers to be in the spirit of this version, but may differ in detail  ',&
'      to address new problems or concerns. New versions will be published with ',&
'      a unique version number and a variant identifier specifying the variant. ',&
'      If the Licensor has specified that a given variant applies to the        ',&
'      Covered Source without specifying a version, You may treat that Covered  ',&
'      Source as being released under any version of the CERN-OHL with that     ',&
'      variant. If no variant is specified, the Covered Source shall be treated ',&
'      as being released under CERN-OHL-S. The Licensor may also specify that   ',&
'      the Covered Source is subject to a specific version of the CERN-OHL or   ',&
'      any later version in which case You may apply this or any later version  ',&
'      of CERN-OHL with the same variant identifier published by CERN.          ',&
'                                                                               ',&
'  8.4 This Licence shall terminate with immediate effect if You fail to comply ',&
'      with any of its terms and conditions.                                    ',&
'                                                                               ',&
'  8.5 However, if You cease all breaches of this Licence, then Your Licence    ',&
'      from any Licensor is reinstated unless such Licensor has terminated this ',&
'      Licence by giving You, while You remain in breach, a notice specifying   ',&
'      the breach and requiring You to cure it within 30 days, and You have     ',&
'      failed to come into compliance in all material respects by the end of    ',&
'      the 30 day period. Should You repeat the breach after receipt of a cure  ',&
'      notice and subsequent reinstatement, this Licence will terminate         ',&
'      immediately and permanently. Section 6 shall continue to apply after any ',&
'      termination.                                                             ',&
'                                                                               ',&
'  8.6 This Licence shall not be enforceable except by a Licensor acting as     ',&
'      such, and third party beneficiary rights are specifically excluded.      ',&
'                                                                               ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('19','cern-ohl-w-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'cern-ohl-w-2.0',&
'              ',&
'CERN Open Hardware Licence Version 2 - Weakly Reciprocal',&
'                                                        ',&
'                                                        ',&
'Preamble                                                ',&
'                                                        ',&
'CERN has developed this licence to promote collaboration among hardware',&
'designers and to provide a legal tool which supports the freedom to use,',&
'study, modify, share and distribute hardware designs and products based on',&
'those designs. Version 2 of the CERN Open Hardware Licence comes in three ',&
'variants: CERN-OHL-P (permissive); and two reciprocal licences: this licence,',&
'CERN-OHL-W (weakly reciprocal) and CERN-OHL-S (strongly reciprocal).         ',&
'                                                                             ',&
'The CERN-OHL-W is copyright CERN 2020. Anyone is welcome to use it, in       ',&
'unmodified form only.                                                        ',&
'                                                                             ',&
'Use of this Licence does not imply any endorsement by CERN of any Licensor or',&
'their designs nor does it imply any involvement by CERN in their development.',&
'                                                                             ',&
'                                                                             ',&
'1 Definitions                                                                ',&
'                                                                             ',&
'  1.1 ''Licence'' means this CERN-OHL-W.                                     ',&
'                                                                             ',&
'  1.2 ''Compatible Licence'' means                                           ',&
'                                                                             ',&
'       a) any earlier version of the CERN Open Hardware licence, or          ',&
'                                                                             ',&
'       b) any version of the CERN-OHL-S or the CERN-OHL-W, or                ',&
'                                                                             ',&
'       c) any licence which permits You to treat the Source to which it      ',&
'          applies as licensed under CERN-OHL-S or CERN-OHL-W provided that on',&
'          Conveyance of any such Source, or any associated Product You treat ',&
'          the Source in question as being licensed under CERN-OHL-S or       ',&
'          CERN-OHL-W as appropriate.                                         ',&
'                                                                             ',&
'  1.3 ''Source'' means information such as design materials or digital code  ',&
'      which can be applied to Make or test a Product or to prepare a Product ',&
'      for use, Conveyance or sale, regardless of its medium or how it is     ',&
'      expressed. It may include Notices.                                     ',&
'                                                                             ',&
'  1.4 ''Covered Source'' means Source that is explicitly made available under',&
'      this Licence.                                                          ',&
'                                                                             ',&
'  1.5 ''Product'' means any device, component, work or physical object, whether',&
'      in finished or intermediate form, arising from the use, application or   ',&
'      processing of Covered Source.                                            ',&
'                                                                               ',&
'  1.6 ''Make'' means to create or configure something, whether by manufacture, ',&
'      assembly, compiling, loading or applying Covered Source or another       ',&
'      Product or otherwise.                                                    ',&
'                                                                               ',&
'  1.7 ''Available Component'' means any part, sub-assembly, library or code    ',&
'      which:                                                                   ',&
'                                                                               ',&
'       a) is licensed to You as Complete Source under a Compatible Licence; or ',&
'                                                                               ',&
'       b) is available, at the time a Product or the Source containing it is   ',&
'          first Conveyed, to You and any other prospective licensees           ',&
'                                                                               ',&
'           i) with sufficient rights and information (including any            ',&
'              configuration and programming files and information about its    ',&
'              characteristics and interfaces) to enable it either to be Made   ',&
'              itself, or to be sourced and used to Make the Product; or        ',&
'          ii) as part of the normal distribution of a tool used to design or   ',&
'              Make the Product.                                                ',&
'                                                                               ',&
'  1.8 ''External Material'' means anything (including Source) which:           ',&
'                                                                               ',&
'       a) is only combined with Covered Source in such a way that it           ',&
'          interfaces with the Covered Source using a documented interface      ',&
'          which is described in the Covered Source; and                        ',&
'                                                                               ',&
'       b) is not a derivative of or contains Covered Source, or, if it is, it  ',&
'          is solely to the extent necessary to facilitate such interfacing.    ',&
'                                                                               ',&
'  1.9 ''Complete Source'' means the set of all Source necessary to Make a      ',&
'      Product, in the preferred form for making modifications, including       ',&
'      necessary installation and interfacing information both for the Product, ',&
'      and for any included Available Components.  If the format is             ',&
'      proprietary, it must also be made available in a format (if the          ',&
'      proprietary tool can create it) which is viewable with a tool available  ',&
'      to potential licensees and licensed under a licence approved by the Free ',&
'      Software Foundation or the Open Source Initiative. Complete Source need  ',&
'      not include the Source of any Available Component, provided that You     ',&
'      include in the Complete Source sufficient information to enable a        ',&
'      recipient to Make or source and use the Available Component to Make the  ',&
'      Product.                                                                 ',&
'                                                                               ',&
' 1.10 ''Source Location'' means a location where a Licensor has placed Covered ',&
'      Source, and which that Licensor reasonably believes will remain easily   ',&
'      accessible for at least three years for anyone to obtain a digital copy. ',&
'                                                                               ',&
' 1.11 ''Notice'' means copyright, acknowledgement and trademark notices, Source',&
'      Location references, modification notices (subsection 3.3(b)) and all    ',&
'      notices that refer to this Licence and to the disclaimer of warranties   ',&
'      that are included in the Covered Source.                                 ',&
'                                                                               ',&
' 1.12 ''Licensee'' or ''You'' means any person exercising rights under this    ',&
'      Licence.                                                                 ',&
'                                                                               ',&
' 1.13 ''Licensor'' means a natural or legal person who creates or modifies     ',&
'      Covered Source. A person may be a Licensee and a Licensor at the same    ',&
'      time.                                                                    ',&
'                                                                               ',&
' 1.14 ''Convey'' means to communicate to the public or distribute.             ',&
'                                                                               ',&
'                                                                               ',&
'2 Applicability                                                                ',&
'                                                                               ',&
'  2.1 This Licence governs the use, copying, modification, Conveying of        ',&
'      Covered Source and Products, and the Making of Products. By exercising   ',&
'      any right granted under this Licence, You irrevocably accept these terms ',&
'      and conditions.                                                          ',&
'                                                                               ',&
'  2.2 This Licence is granted by the Licensor directly to You, and shall apply ',&
'      worldwide and without limitation in time.                                ',&
'                                                                               ',&
'  2.3 You shall not attempt to restrict by contract or otherwise the rights    ',&
'      granted under this Licence to other Licensees.                           ',&
'                                                                               ',&
'  2.4 This Licence is not intended to restrict fair use, fair dealing, or any  ',&
'      other similar right.                                                     ',&
'                                                                               ',&
'                                                                               ',&
'3 Copying, Modifying and Conveying Covered Source                              ',&
'                                                                               ',&
'  3.1 You may copy and Convey verbatim copies of Covered Source, in any        ',&
'      medium, provided You retain all Notices.                                 ',&
'                                                                               ',&
'  3.2 You may modify Covered Source, other than Notices, provided that You     ',&
'      irrevocably undertake to make that modified Covered Source available     ',&
'      from a Source Location should You Convey a Product in circumstances      ',&
'      where the recipient does not otherwise receive a copy of the modified    ',&
'      Covered Source. In each case subsection 3.3 shall apply.                 ',&
'                                                                               ',&
'      You may only delete Notices if they are no longer applicable to the      ',&
'      corresponding Covered Source as modified by You and You may add          ',&
'      additional Notices applicable to Your modifications.                     ',&
'                                                                               ',&
'  3.3 You may Convey modified Covered Source (with the effect that You shall   ',&
'      also become a Licensor) provided that You:                               ',&
'                                                                               ',&
'       a) retain Notices as required in subsection 3.2;                        ',&
'                                                                               ',&
'       b) add a Notice to the modified Covered Source stating that You have    ',&
'          modified it, with the date and brief description of how You have     ',&
'          modified it;                                                         ',&
'                                                                               ',&
'       c) add a Source Location Notice for the modified Covered Source if You  ',&
'          Convey in circumstances where the recipient does not otherwise       ',&
'          receive a copy of the modified Covered Source; and                   ',&
'                                                                               ',&
'       d) license the modified Covered Source under the terms and conditions   ',&
'          of this Licence (or, as set out in subsection 8.3, a later version,  ',&
'          if permitted by the licence of the original Covered Source). Such    ',&
'          modified Covered Source must be licensed as a whole, but excluding   ',&
'          Available Components contained in it or External Material to which   ',&
'          it is interfaced, which remain licensed under their own applicable   ',&
'          licences.                                                            ',&
'                                                                               ',&
'                                                                               ',&
'4 Making and Conveying Products                                                ',&
'                                                                               ',&
'  4.1 You may Make Products, and/or Convey them, provided that You either      ',&
'      provide each recipient with a copy of the Complete Source or ensure that ',&
'      each recipient is notified of the Source Location of the Complete        ',&
'      Source. That Complete Source includes Covered Source and You must        ',&
'      accordingly satisfy Your obligations set out in subsection 3.3. If       ',&
'      specified in a Notice, the Product must visibly and securely display the ',&
'      Source Location on it or its packaging or documentation in the manner    ',&
'      specified in that Notice.                                                ',&
'                                                                               ',&
'  4.2 Where You Convey a Product which incorporates External Material, the     ',&
'      Complete Source for that Product which You are required to provide under ',&
'      subsection 4.1 need not include any Source for the External Material.    ',&
'                                                                               ',&
'  4.3 You may license Products under terms of Your choice, provided that such  ',&
'      terms do not restrict or attempt to restrict any recipients'' rights     ',&
'      under this Licence to the Covered Source.                                ',&
'                                                                               ',&
'                                                                               ',&
'5 Research and Development                                                     ',&
'                                                                               ',&
'You may Convey Covered Source, modified Covered Source or Products to a legal  ',&
'entity carrying out development, testing or quality assurance work on Your     ',&
'behalf provided that the work is performed on terms which prevent the entity   ',&
'from both using the Source or Products for its own internal purposes and       ',&
'Conveying the Source or Products or any modifications to them to any person    ',&
'other than You. Any modifications made by the entity shall be deemed to be     ',&
'made by You pursuant to subsection 3.2.                                        ',&
'                                                                               ',&
'                                                                               ',&
'6 DISCLAIMER AND LIABILITY                                                     ',&
'                                                                               ',&
'  6.1 DISCLAIMER OF WARRANTY -- The Covered Source and any Products are        ',&
'      provided ''as is'' and any express or implied warranties, including, but ',&
'      not limited to, implied warranties of merchantability, of satisfactory   ',&
'      quality, non-infringement of third party rights, and fitness for a       ',&
'      particular purpose or use are disclaimed in respect of any Source or     ',&
'      Product to the maximum extent permitted by law. The Licensor makes no    ',&
'      representation that any Source or Product does not or will not infringe  ',&
'      any patent, copyright, trade secret or other proprietary right. The      ',&
'      entire risk as to the use, quality, and performance of any Source or     ',&
'      Product shall be with You and not the Licensor. This disclaimer of       ',&
'      warranty is an essential part of this Licence and a condition for the    ',&
'      grant of any rights granted under this Licence.                          ',&
'                                                                               ',&
'  6.2 EXCLUSION AND LIMITATION OF LIABILITY -- The Licensor shall, to the      ',&
'      maximum extent permitted by law, have no liability for direct, indirect, ',&
'      special, incidental, consequential, exemplary, punitive or other damages ',&
'      of any character including, without limitation, procurement of           ',&
'      substitute goods or services, loss of use, data or profits, or business  ',&
'      interruption, however caused and on any theory of contract, warranty,    ',&
'      tort (including negligence), product liability or otherwise, arising in  ',&
'      any way in relation to the Covered Source, modified Covered Source       ',&
'      and/or the Making or Conveyance of a Product, even if advised of the     ',&
'      possibility of such damages, and You shall hold the Licensor(s) free and ',&
'      harmless from any liability, costs, damages, fees and expenses,          ',&
'      including claims by third parties, in relation to such use.              ',&
'                                                                               ',&
'                                                                               ',&
'7 Patents                                                                      ',&
'                                                                               ',&
'  7.1 Subject to the terms and conditions of this Licence, each Licensor       ',&
'      hereby grants to You a perpetual, worldwide, non-exclusive, no-charge,   ',&
'      royalty-free, irrevocable (except as stated in subsections 7.2 and 8.4)  ',&
'      patent licence to Make, have Made, use, offer to sell, sell, import, and ',&
'      otherwise transfer the Covered Source and Products, where such licence   ',&
'      applies only to those patent claims licensable by such Licensor that are ',&
'      necessarily infringed by exercising rights under the Covered Source as   ',&
'      Conveyed by that Licensor.                                               ',&
'                                                                               ',&
'  7.2 If You institute patent litigation against any entity (including a       ',&
'      cross-claim or counterclaim in a lawsuit) alleging that the Covered      ',&
'      Source or a Product constitutes direct or contributory patent            ',&
'      infringement, or You seek any declaration that a patent licensed to You  ',&
'      under this Licence is invalid or unenforceable then any rights granted   ',&
'      to You under this Licence shall terminate as of the date such process is ',&
'      initiated.                                                               ',&
'                                                                               ',&
'                                                                               ',&
'8 General                                                                      ',&
'                                                                               ',&
'  8.1 If any provisions of this Licence are or subsequently become invalid or  ',&
'      unenforceable for any reason, the remaining provisions shall remain      ',&
'      effective.                                                               ',&
'                                                                               ',&
'  8.2 You shall not use any of the name (including acronyms and                ',&
'      abbreviations), image, or logo by which the Licensor or CERN is known,   ',&
'      except where needed to comply with section 3, or where the use is        ',&
'      otherwise allowed by law. Any such permitted use shall be factual and    ',&
'      shall not be made so as to suggest any kind of endorsement or            ',&
'      implication of involvement by the Licensor or its personnel.             ',&
'                                                                               ',&
'  8.3 CERN may publish updated versions and variants of this Licence which it  ',&
'      considers to be in the spirit of this version, but may differ in detail  ',&
'      to address new problems or concerns. New versions will be published with ',&
'      a unique version number and a variant identifier specifying the variant. ',&
'      If the Licensor has specified that a given variant applies to the        ',&
'      Covered Source without specifying a version, You may treat that Covered  ',&
'      Source as being released under any version of the CERN-OHL with that     ',&
'      variant. If no variant is specified, the Covered Source shall be treated ',&
'      as being released under CERN-OHL-S. The Licensor may also specify that   ',&
'      the Covered Source is subject to a specific version of the CERN-OHL or   ',&
'      any later version in which case You may apply this or any later version  ',&
'      of CERN-OHL with the same variant identifier published by CERN.          ',&
'                                                                               ',&
'      You may treat Covered Source licensed under CERN-OHL-W as licensed under ',&
'      CERN-OHL-S if and only if all Available Components referenced in the     ',&
'      Covered Source comply with the corresponding definition of Available     ',&
'      Component for CERN-OHL-S.                                                ',&
'                                                                               ',&
'  8.4 This Licence shall terminate with immediate effect if You fail to comply ',&
'      with any of its terms and conditions.                                    ',&
'                                                                               ',&
'  8.5 However, if You cease all breaches of this Licence, then Your Licence    ',&
'      from any Licensor is reinstated unless such Licensor has terminated this ',&
'      Licence by giving You, while You remain in breach, a notice specifying   ',&
'      the breach and requiring You to cure it within 30 days, and You have     ',&
'      failed to come into compliance in all material respects by the end of    ',&
'      the 30 day period. Should You repeat the breach after receipt of a cure  ',&
'      notice and subsequent reinstatement, this Licence will terminate         ',&
'      immediately and permanently. Section 6 shall continue to apply after any ',&
'      termination.                                                             ',&
'                                                                               ',&
'  8.6 This Licence shall not be enforceable except by a Licensor acting as     ',&
'       such, and third party beneficiary rights are specifically excluded.     ',&
'                                                                               ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('20','ecl-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'ecl-2.0',&
'       ',&
'Educational Community License',&
'                             ',&
'Version 2.0, April 2007      ',&
'                             ',&
'http://opensource.org/licenses/ECL-2.0',&
'                                      ',&
'The Educational Community License version 2.0 ("ECL") consists of the Apache',&
'2.0 license, modified to change the scope of the patent grant in section 3 to',&
'be specific to the needs of the education communities using this license. The',&
'original Apache 2.0 license can be found at:                                 ',&
'http://www.apache.org/licenses/LICENSE-2.0                                   ',&
'                                                                             ',&
'TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION                 ',&
'                                                                             ',&
'1. Definitions.                                                              ',&
'                                                                             ',&
'"License" shall mean the terms and conditions for use, reproduction, and     ',&
'distribution as defined by Sections 1 through 9 of this document.            ',&
'                                                                             ',&
'"Licensor" shall mean the copyright owner or entity authorized by the        ',&
'copyright owner that is granting the License.                                ',&
'                                                                             ',&
'"Legal Entity" shall mean the union of the acting entity and all other       ',&
'entities that control, are controlled by, or are under common control with   ',&
'that entity. For the purposes of this definition, "control" means (i) the    ',&
'power, direct or indirect, to cause the direction or management of such      ',&
'entity, whether by contract or otherwise, or (ii) ownership of fifty percent ',&
'(50%) or more of the outstanding shares, or (iii) beneficial ownership of such',&
'entity.                                                                       ',&
'                                                                              ',&
'"You" (or "Your") shall mean an individual or Legal Entity exercising         ',&
'permissions granted by this License.                                          ',&
'                                                                              ',&
'"Source" form shall mean the preferred form for making modifications,         ',&
'including but not limited to software source code, documentation source, and  ',&
'configuration files.                                                          ',&
'                                                                              ',&
'"Object" form shall mean any form resulting from mechanical transformation or ',&
'translation of a Source form, including but not limited to compiled object    ',&
'code, generated documentation, and conversions to other media types.          ',&
'                                                                              ',&
'"Work" shall mean the work of authorship, whether in Source or Object form,   ',&
'made available under the License, as indicated by a copyright notice that is  ',&
'included in or attached to the work (an example is provided in the Appendix   ',&
'below).                                                                       ',&
'                                                                              ',&
'"Derivative Works" shall mean any work, whether in Source or Object form, that',&
'is based on (or derived from) the Work and for which the editorial revisions, ',&
'annotations, elaborations, or other modifications represent, as a whole, an   ',&
'original work of authorship. For the purposes of this License, Derivative     ',&
'Works shall not include works that remain separable from, or merely link (or  ',&
'bind by name) to the interfaces of, the Work and Derivative Works thereof.    ',&
'                                                                              ',&
'"Contribution" shall mean any work of authorship, including the original      ',&
'version of the Work and any modifications or additions to that Work or        ',&
'Derivative Works thereof, that is intentionally submitted to Licensor for     ',&
'inclusion in the Work by the copyright owner or by an individual or Legal     ',&
'Entity authorized to submit on behalf of the copyright owner. For the purposes',&
'of this definition, "submitted" means any form of electronic, verbal, or      ',&
'written communication sent to the Licensor or its representatives, including  ',&
'but not limited to communication on electronic mailing lists, source code     ',&
'control systems, and issue tracking systems that are managed by, or on behalf ',&
'of, the Licensor for the purpose of discussing and improving the Work, but    ',&
'excluding communication that is conspicuously marked or otherwise designated  ',&
'in writing by the copyright owner as "Not a Contribution."                    ',&
'                                                                              ',&
'"Contributor" shall mean Licensor and any individual or Legal Entity on behalf',&
'of whom a Contribution has been received by Licensor and subsequently         ',&
'incorporated within the Work.                                                 ',&
'                                                                              ',&
'2. Grant of Copyright License.                                                ',&
'                                                                              ',&
'Subject to the terms and conditions of this License, each Contributor hereby  ',&
'grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, ',&
'irrevocable copyright license to reproduce, prepare Derivative Works of,      ',&
'publicly display, publicly perform, sublicense, and distribute the Work and   ',&
'such Derivative Works in Source or Object form.                               ',&
'                                                                              ',&
'3. Grant of Patent License.                                                   ',&
'                                                                              ',&
'Subject to the terms and conditions of this License, each Contributor hereby  ',&
'grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, ',&
'irrevocable (except as stated in this section) patent license to make, have   ',&
'made, use, offer to sell, sell, import, and otherwise transfer the Work, where',&
'such license applies only to those patent claims licensable by such           ',&
'Contributor that are necessarily infringed by their Contribution(s) alone or  ',&
'by combination of their Contribution(s) with the Work to which such           ',&
'Contribution(s) was submitted. If You institute patent litigation against any ',&
'entity (including a cross-claim or counterclaim in a lawsuit) alleging that   ',&
'the Work or a Contribution incorporated within the Work constitutes direct or ',&
'contributory patent infringement, then any patent licenses granted to You     ',&
'under this License for that Work shall terminate as of the date such          ',&
'litigation is filed. Any patent license granted hereby with respect to        ',&
'contributions by an individual employed by an institution or organization is  ',&
'limited to patent claims where the individual that is the author of the Work  ',&
'is also the inventor of the patent claims licensed, and where the organization',&
'or institution has the right to grant such license under applicable grant and ',&
'research funding agreements. No other express or implied licenses are granted.',&
'                                                                              ',&
'4. Redistribution.                                                            ',&
'                                                                              ',&
'You may reproduce and distribute copies of the Work or Derivative Works       ',&
'thereof in any medium, with or without modifications, and in Source or Object ',&
'form, provided that You meet the following conditions:                        ',&
'                                                                              ',&
'You must give any other recipients of the Work or Derivative Works a copy of  ',&
'this License; and You must cause any modified files to carry prominent notices',&
'stating that You changed the files; and You must retain, in the Source form of',&
'any Derivative Works that You distribute, all copyright, patent, trademark,   ',&
'and attribution notices from the Source form of the Work, excluding those     ',&
'notices that do not pertain to any part of the Derivative Works; and If the   ',&
'Work includes a "NOTICE" text file as part of its distribution, then any      ',&
'Derivative Works that You distribute must include a readable copy of the      ',&
'attribution notices contained within such NOTICE file, excluding those notices',&
'that do not pertain to any part of the Derivative Works, in at least one of   ',&
'the following places: within a NOTICE text file distributed as part of the    ',&
'Derivative Works; within the Source form or documentation, if provided along  ',&
'with the Derivative Works; or, within a display generated by the Derivative   ',&
'Works, if and wherever such third-party notices normally appear. The contents ',&
'of the NOTICE file are for informational purposes only and do not modify the  ',&
'License. You may add Your own attribution notices within Derivative Works that',&
'You distribute, alongside or as an addendum to the NOTICE text from the Work, ',&
'provided that such additional attribution notices cannot be construed as      ',&
'modifying the License. You may add Your own copyright statement to Your       ',&
'modifications and may provide additional or different license terms and       ',&
'conditions for use, reproduction, or distribution of Your modifications, or   ',&
'for any such Derivative Works as a whole, provided Your use, reproduction, and',&
'distribution of the Work otherwise complies with the conditions stated in this',&
'License.                                                                      ',&
'                                                                              ',&
'5. Submission of Contributions.                                               ',&
'                                                                              ',&
'Unless You explicitly state otherwise, any Contribution intentionally         ',&
'submitted for inclusion in the Work by You to the Licensor shall be under the ',&
'terms and conditions of this License, without any additional terms or         ',&
'conditions. Notwithstanding the above, nothing herein shall supersede or      ',&
'modify the terms of any separate license agreement you may have executed with ',&
'Licensor regarding such Contributions.                                        ',&
'                                                                              ',&
'6. Trademarks.                                                                ',&
'                                                                              ',&
'This License does not grant permission to use the trade names, trademarks,    ',&
'service marks, or product names of the Licensor, except as required for       ',&
'reasonable and customary use in describing the origin of the Work and         ',&
'reproducing the content of the NOTICE file.                                   ',&
'                                                                              ',&
'7. Disclaimer of Warranty.                                                    ',&
'                                                                              ',&
'Unless required by applicable law or agreed to in writing, Licensor provides  ',&
'the Work (and each Contributor provides its Contributions) on an "AS IS"      ',&
'BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        ',&
'implied, including, without limitation, any warranties or conditions of TITLE,',&
'NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You   ',&
'are solely responsible for determining the appropriateness of using or        ',&
'redistributing the Work and assume any risks associated with Your exercise of ',&
'permissions under this License.                                               ',&
'                                                                              ',&
'8. Limitation of Liability.                                                   ',&
'                                                                              ',&
'In no event and under no legal theory, whether in tort (including negligence),',&
'contract, or otherwise, unless required by applicable law (such as deliberate ',&
'and grossly negligent acts) or agreed to in writing, shall any Contributor be ',&
'liable to You for damages, including any direct, indirect, special,           ',&
'incidental, or consequential damages of any character arising as a result of  ',&
'this License or out of the use or inability to use the Work (including but not',&
'limited to damages for loss of goodwill, work stoppage, computer failure or   ',&
'malfunction, or any and all other commercial damages or losses), even if such ',&
'Contributor has been advised of the possibility of such damages.              ',&
'                                                                              ',&
'9. Accepting Warranty or Additional Liability.                                ',&
'                                                                              ',&
'While redistributing the Work or Derivative Works thereof, You may choose to  ',&
'offer, and charge a fee for, acceptance of support, warranty, indemnity, or   ',&
'other liability obligations and/or rights consistent with this License.       ',&
'However, in accepting such obligations, You may act only on Your own behalf   ',&
'and on Your sole responsibility, not on behalf of any other Contributor, and  ',&
'only if You agree to indemnify, defend, and hold each Contributor harmless for',&
'any liability incurred by, or claims asserted against, such Contributor by    ',&
'reason of your accepting any such warranty or additional liability.           ',&
'                                                                              ',&
'END OF TERMS AND CONDITIONS                                                   ',&
'                                                                              ',&
'APPENDIX: How to apply the Educational Community License to your work         ',&
'                                                                              ',&
'To apply the Educational Community License to your work, attach the following ',&
'boilerplate notice, with the fields enclosed by brackets "[]" replaced with   ',&
'your own identifying information. (Don''t include the brackets!) The text     ',&
'should be enclosed in the appropriate comment syntax for the file format. We  ',&
'also recommend that a file or class name and description of purpose be        ',&
'included on the same "printed page" as the copyright notice for easier        ',&
'identification within third-party archives.                                   ',&
'                                                                              ',&
'Copyright @YEAR@ [name of copyright owner] Licensed under the Educational     ',&
'Community License, Version 2.0 (the "License"); you may not use this file     ',&
'except in compliance with the License. You may obtain a copy of the License at',&
'                                                                              ',&
'http://opensource.org/licenses/ECL-2.0                                        ',&
'                                                                              ',&
' Unless required by applicable law or agreed to in writing, software          ',&
'distributed under the License is distributed on an "AS IS" BASIS, WITHOUT     ',&
'WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the      ',&
'License for the specific language governing permissions and limitations under ',&
'the License.                                                                  ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('21','epl-1.0')
textblock=[ CHARACTER(LEN=128) :: &
'epl-1.0',&
'       ',&
'Eclipse Public License - v 1.0',&
'                              ',&
'THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC',&
'LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM',&
'CONSTITUTES RECIPIENT''S ACCEPTANCE OF THIS AGREEMENT.                     ',&
'                                                                           ',&
'1. DEFINITIONS                                                             ',&
'                                                                           ',&
'"Contribution" means:                                                      ',&
'     a) in the case of the initial Contributor, the initial code and       ',&
'     documentation distributed under this Agreement, and                   ',&
'     b) in the case of each subsequent Contributor:                        ',&
'          i) changes to the Program, and                                   ',&
'          ii) additions to the Program;                                    ',&
'                                                                           ',&
'where such changes and/or additions to the Program originate from and are  ',&
'distributed by that particular Contributor. A Contribution ''originates'' from a',&
'Contributor if it was added to the Program by such Contributor itself or        ',&
'anyone acting on such Contributor''s behalf. Contributions do not include       ',&
'additions to the Program which: (i) are separate modules of software            ',&
'distributed in conjunction with the Program under their own license agreement,  ',&
'and (ii) are not derivative works of the Program.                               ',&
'"Contributor" means any person or entity that distributes the Program.          ',&
'                                                                                ',&
'"Licensed Patents" mean patent claims licensable by a Contributor which are     ',&
'necessarily infringed by the use or sale of its Contribution alone or when      ',&
'combined with the Program.                                                      ',&
'                                                                                ',&
'"Program" means the Contributions distributed in accordance with this           ',&
'Agreement.                                                                      ',&
'                                                                                ',&
'"Recipient" means anyone who receives the Program under this Agreement,         ',&
'including all Contributors.                                                     ',&
'                                                                                ',&
'2. GRANT OF RIGHTS                                                              ',&
'                                                                                ',&
'     a) Subject to the terms of this Agreement, each Contributor hereby grants  ',&
'     Recipient a non-exclusive, worldwide, royalty-free copyright license to    ',&
'     reproduce, prepare derivative works of, publicly display, publicly         ',&
'     perform, distribute and sublicense the Contribution of such Contributor,   ',&
'     if any, and such derivative works, in source code and object code form.    ',&
'                                                                                ',&
'     b) Subject to the terms of this Agreement, each Contributor hereby grants  ',&
'     Recipient a non-exclusive, worldwide, royalty-free patent license under    ',&
'     Licensed Patents to make, use, sell, offer to sell, import and otherwise   ',&
'     transfer the Contribution of such Contributor, if any, in source code and  ',&
'     object code form. This patent license shall apply to the combination of    ',&
'     the Contribution and the Program if, at the time the Contribution is       ',&
'     added by the Contributor, such addition of the Contribution causes such    ',&
'     combination to be covered by the Licensed Patents. The patent license      ',&
'     shall not apply to any other combinations which include the Contribution.  ',&
'     No hardware per se is licensed hereunder.                                  ',&
'                                                                                ',&
'     c) Recipient understands that although each Contributor grants the         ',&
'     licenses to its Contributions set forth herein, no assurances are          ',&
'     provided by any Contributor that the Program does not infringe the patent  ',&
'     or other intellectual property rights of any other entity. Each            ',&
'     Contributor disclaims any liability to Recipient for claims brought by     ',&
'     any other entity based on infringement of intellectual property rights or  ',&
'     otherwise. As a condition to exercising the rights and licenses granted    ',&
'     hereunder, each Recipient hereby assumes sole responsibility to secure     ',&
'     any other intellectual property rights needed, if any. For example, if a   ',&
'     third party patent license is required to allow Recipient to distribute    ',&
'     the Program, it is Recipient''s responsibility to acquire that license     ',&
'     before distributing the Program.                                           ',&
'                                                                                ',&
'     d) Each Contributor represents that to its knowledge it has sufficient     ',&
'     copyright rights in its Contribution, if any, to grant the copyright       ',&
'     license set forth in this Agreement.                                       ',&
'                                                                                ',&
'3. REQUIREMENTS                                                                 ',&
'A Contributor may choose to distribute the Program in object code form under    ',&
'its own license agreement, provided that:                                       ',&
'                                                                                ',&
'     a) it complies with the terms and conditions of this Agreement; and        ',&
'                                                                                ',&
'     b) its license agreement:                                                  ',&
'          i) effectively disclaims on behalf of all Contributors all            ',&
'          warranties and conditions, express and implied, including warranties  ',&
'          or conditions of title and non-infringement, and implied warranties   ',&
'          or conditions of merchantability and fitness for a particular         ',&
'          purpose;                                                              ',&
'          ii) effectively excludes on behalf of all Contributors all liability  ',&
'          for damages, including direct, indirect, special, incidental and      ',&
'          consequential damages, such as lost profits;                          ',&
'          iii) states that any provisions which differ from this Agreement are  ',&
'          offered by that Contributor alone and not by any other party; and     ',&
'          iv) states that source code for the Program is available from such    ',&
'          Contributor, and informs licensees how to obtain it in a reasonable   ',&
'          manner on or through a medium customarily used for software           ',&
'          exchange.                                                             ',&
'                                                                                ',&
'When the Program is made available in source code form:                         ',&
'                                                                                ',&
'     a) it must be made available under this Agreement; and                     ',&
'                                                                                ',&
'     b) a copy of this Agreement must be included with each copy of the         ',&
'     Program.                                                                   ',&
'Contributors may not remove or alter any copyright notices contained within     ',&
'the Program.                                                                    ',&
'                                                                                ',&
'Each Contributor must identify itself as the originator of its Contribution,    ',&
'if any, in a manner that reasonably allows subsequent Recipients to identify    ',&
'the originator of the Contribution.                                             ',&
'                                                                                ',&
'4. COMMERCIAL DISTRIBUTION                                                      ',&
'Commercial distributors of software may accept certain responsibilities with    ',&
'respect to end users, business partners and the like. While this license is     ',&
'intended to facilitate the commercial use of the Program, the Contributor who   ',&
'includes the Program in a commercial product offering should do so in a manner  ',&
'which does not create potential liability for other Contributors. Therefore,    ',&
'if a Contributor includes the Program in a commercial product offering, such    ',&
'Contributor ("Commercial Contributor") hereby agrees to defend and indemnify    ',&
'every other Contributor ("Indemnified Contributor") against any losses,         ',&
'damages and costs (collectively "Losses") arising from claims, lawsuits and     ',&
'other legal actions brought by a third party against the Indemnified            ',&
'Contributor to the extent caused by the acts or omissions of such Commercial    ',&
'Contributor in connection with its distribution of the Program in a commercial  ',&
'product offering. The obligations in this section do not apply to any claims    ',&
'or Losses relating to any actual or alleged intellectual property               ',&
'infringement. In order to qualify, an Indemnified Contributor must: a)          ',&
'promptly notify the Commercial Contributor in writing of such claim, and b)     ',&
'allow the Commercial Contributor to control, and cooperate with the Commercial  ',&
'Contributor in, the defense and any related settlement negotiations. The        ',&
'Indemnified Contributor may participate in any such claim at its own expense.   ',&
'                                                                                ',&
'For example, a Contributor might include the Program in a commercial product    ',&
'offering, Product X. That Contributor is then a Commercial Contributor. If      ',&
'that Commercial Contributor then makes performance claims, or offers            ',&
'warranties related to Product X, those performance claims and warranties are    ',&
'such Commercial Contributor''s responsibility alone. Under this section, the    ',&
'Commercial Contributor would have to defend claims against the other            ',&
'Contributors related to those performance claims and warranties, and if a       ',&
'court requires any other Contributor to pay any damages as a result, the        ',&
'Commercial Contributor must pay those damages.                                  ',&
'                                                                                ',&
'5. NO WARRANTY                                                                  ',&
'EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN  ',&
'"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR  ',&
'IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE,   ',&
'NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each     ',&
'Recipient is solely responsible for determining the appropriateness of using    ',&
'and distributing the Program and assumes all risks associated with its          ',&
'exercise of rights under this Agreement , including but not limited to the      ',&
'risks and costs of program errors, compliance with applicable laws, damage to   ',&
'or loss of data, programs or equipment, and unavailability or interruption of   ',&
'operations.                                                                     ',&
'                                                                                ',&
'6. DISCLAIMER OF LIABILITY                                                      ',&
'EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY      ',&
'CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL,     ',&
'SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION      ',&
'LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN        ',&
'CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)         ',&
'ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE         ',&
'EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY    ',&
'OF SUCH DAMAGES.                                                                ',&
'                                                                                ',&
'7. GENERAL                                                                      ',&
'                                                                                ',&
'If any provision of this Agreement is invalid or unenforceable under            ',&
'applicable law, it shall not affect the validity or enforceability of the       ',&
'remainder of the terms of this Agreement, and without further action by the     ',&
'parties hereto, such provision shall be reformed to the minimum extent          ',&
'necessary to make such provision valid and enforceable.                         ',&
'                                                                                ',&
'If Recipient institutes patent litigation against any entity (including a       ',&
'cross-claim or counterclaim in a lawsuit) alleging that the Program itself      ',&
'(excluding combinations of the Program with other software or hardware)         ',&
'infringes such Recipient''s patent(s), then such Recipient''s rights granted    ',&
'under Section 2(b) shall terminate as of the date such litigation is filed.     ',&
'                                                                                ',&
'All Recipient''s rights under this Agreement shall terminate if it fails to     ',&
'comply with any of the material terms or conditions of this Agreement and does  ',&
'not cure such failure in a reasonable period of time after becoming aware of    ',&
'such noncompliance. If all Recipient''s rights under this Agreement terminate,  ',&
'Recipient agrees to cease use and distribution of the Program as soon as        ',&
'reasonably practicable. However, Recipient''s obligations under this Agreement  ',&
'and any licenses granted by Recipient relating to the Program shall continue    ',&
'and survive.                                                                    ',&
'                                                                                ',&
'Everyone is permitted to copy and distribute copies of this Agreement, but in   ',&
'order to avoid inconsistency the Agreement is copyrighted and may only be       ',&
'modified in the following manner. The Agreement Steward reserves the right to   ',&
'publish new versions (including revisions) of this Agreement from time to       ',&
'time. No one other than the Agreement Steward has the right to modify this      ',&
'Agreement. The Eclipse Foundation is the initial Agreement Steward. The         ',&
'Eclipse Foundation may assign the responsibility to serve as the Agreement      ',&
'Steward to a suitable separate entity. Each new version of the Agreement will   ',&
'be given a distinguishing version number. The Program (including                ',&
'Contributions) may always be distributed subject to the version of the          ',&
'Agreement under which it was received. In addition, after a new version of the  ',&
'Agreement is published, Contributor may elect to distribute the Program         ',&
'(including its Contributions) under the new version. Except as expressly        ',&
'stated in Sections 2(a) and 2(b) above, Recipient receives no rights or         ',&
'licenses to the intellectual property of any Contributor under this Agreement,  ',&
'whether expressly, by implication, estoppel or otherwise. All rights in the     ',&
'Program not expressly granted under this Agreement are reserved.                ',&
'                                                                                ',&
'This Agreement is governed by the laws of the State of New York and the         ',&
'intellectual property laws of the United States of America. No party to this    ',&
'Agreement will bring a legal action under this Agreement more than one year     ',&
'after the cause of action arose. Each party waives its rights to a jury trial   ',&
'in any resulting litigation.                                                    ',&
'                                                                                ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('22','epl-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'epl-2.0',&
'       ',&
'Eclipse Public License - v 2.0',&
'                              ',&
'    THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE',&
'    PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION ',&
'    OF THE PROGRAM CONSTITUTES RECIPIENT''S ACCEPTANCE OF THIS AGREEMENT.',&
'                                                                         ',&
'1. DEFINITIONS                                                           ',&
'                                                                         ',&
'"Contribution" means:                                                    ',&
'                                                                         ',&
'  a) in the case of the initial Contributor, the initial content         ',&
'     Distributed under this Agreement, and                               ',&
'                                                                         ',&
'  b) in the case of each subsequent Contributor:                         ',&
'     i) changes to the Program, and                                      ',&
'     ii) additions to the Program;                                       ',&
'  where such changes and/or additions to the Program originate from      ',&
'  and are Distributed by that particular Contributor. A Contribution     ',&
'  "originates" from a Contributor if it was added to the Program by      ',&
'  such Contributor itself or anyone acting on such Contributor''s behalf.',&
'  Contributions do not include changes or additions to the Program that  ',&
'  are not Modified Works.                                                ',&
'                                                                         ',&
'"Contributor" means any person or entity that Distributes the Program.   ',&
'                                                                         ',&
'"Licensed Patents" mean patent claims licensable by a Contributor which  ',&
'are necessarily infringed by the use or sale of its Contribution alone   ',&
'or when combined with the Program.                                       ',&
'                                                                         ',&
'"Program" means the Contributions Distributed in accordance with this    ',&
'Agreement.                                                               ',&
'                                                                         ',&
'"Recipient" means anyone who receives the Program under this Agreement   ',&
'or any Secondary License (as applicable), including Contributors.        ',&
'                                                                         ',&
'"Derivative Works" shall mean any work, whether in Source Code or other  ',&
'form, that is based on (or derived from) the Program and for which the   ',&
'editorial revisions, annotations, elaborations, or other modifications   ',&
'represent, as a whole, an original work of authorship.                   ',&
'                                                                         ',&
'"Modified Works" shall mean any work in Source Code or other form that   ',&
'results from an addition to, deletion from, or modification of the       ',&
'contents of the Program, including, for purposes of clarity any new file ',&
'in Source Code form that contains any contents of the Program. Modified  ',&
'Works shall not include works that contain only declarations,            ',&
'interfaces, types, classes, structures, or files of the Program solely   ',&
'in each case in order to link to, bind by name, or subclass the Program  ',&
'or Modified Works thereof.                                               ',&
'                                                                         ',&
'"Distribute" means the acts of a) distributing or b) making available    ',&
'in any manner that enables the transfer of a copy.                       ',&
'                                                                         ',&
'"Source Code" means the form of a Program preferred for making           ',&
'modifications, including but not limited to software source code,        ',&
'documentation source, and configuration files.                           ',&
'                                                                         ',&
'"Secondary License" means either the GNU General Public License,         ',&
'Version 2.0, or any later versions of that license, including any        ',&
'exceptions or additional permissions as identified by the initial        ',&
'Contributor.                                                             ',&
'                                                                         ',&
'2. GRANT OF RIGHTS                                                       ',&
'                                                                         ',&
'  a) Subject to the terms of this Agreement, each Contributor hereby     ',&
'  grants Recipient a non-exclusive, worldwide, royalty-free copyright    ',&
'  license to reproduce, prepare Derivative Works of, publicly display,   ',&
'  publicly perform, Distribute and sublicense the Contribution of such   ',&
'  Contributor, if any, and such Derivative Works.                        ',&
'                                                                         ',&
'  b) Subject to the terms of this Agreement, each Contributor hereby     ',&
'  grants Recipient a non-exclusive, worldwide, royalty-free patent       ',&
'  license under Licensed Patents to make, use, sell, offer to sell,      ',&
'  import and otherwise transfer the Contribution of such Contributor,    ',&
'  if any, in Source Code or other form. This patent license shall        ',&
'  apply to the combination of the Contribution and the Program if, at    ',&
'  the time the Contribution is added by the Contributor, such addition   ',&
'  of the Contribution causes such combination to be covered by the       ',&
'  Licensed Patents. The patent license shall not apply to any other      ',&
'  combinations which include the Contribution. No hardware per se is     ',&
'  licensed hereunder.                                                    ',&
'                                                                         ',&
'  c) Recipient understands that although each Contributor grants the     ',&
'  licenses to its Contributions set forth herein, no assurances are      ',&
'  provided by any Contributor that the Program does not infringe the     ',&
'  patent or other intellectual property rights of any other entity.      ',&
'  Each Contributor disclaims any liability to Recipient for claims       ',&
'  brought by any other entity based on infringement of intellectual      ',&
'  property rights or otherwise. As a condition to exercising the         ',&
'  rights and licenses granted hereunder, each Recipient hereby           ',&
'  assumes sole responsibility to secure any other intellectual           ',&
'  property rights needed, if any. For example, if a third party          ',&
'  patent license is required to allow Recipient to Distribute the        ',&
'  Program, it is Recipient''s responsibility to acquire that license     ',&
'  before distributing the Program.                                       ',&
'                                                                         ',&
'  d) Each Contributor represents that to its knowledge it has            ',&
'  sufficient copyright rights in its Contribution, if any, to grant      ',&
'  the copyright license set forth in this Agreement.                     ',&
'                                                                         ',&
'  e) Notwithstanding the terms of any Secondary License, no              ',&
'  Contributor makes additional grants to any Recipient (other than       ',&
'  those set forth in this Agreement) as a result of such Recipient''s    ',&
'  receipt of the Program under the terms of a Secondary License          ',&
'  (if permitted under the terms of Section 3).                           ',&
'                                                                         ',&
'3. REQUIREMENTS                                                          ',&
'                                                                         ',&
'3.1 If a Contributor Distributes the Program in any form, then:          ',&
'                                                                         ',&
'  a) the Program must also be made available as Source Code, in          ',&
'  accordance with section 3.2, and the Contributor must accompany        ',&
'  the Program with a statement that the Source Code for the Program      ',&
'  is available under this Agreement, and informs Recipients how to       ',&
'  obtain it in a reasonable manner on or through a medium customarily    ',&
'  used for software exchange; and                                        ',&
'                                                                         ',&
'  b) the Contributor may Distribute the Program under a license          ',&
'  different than this Agreement, provided that such license:             ',&
'     i) effectively disclaims on behalf of all other Contributors all    ',&
'     warranties and conditions, express and implied, including           ',&
'     warranties or conditions of title and non-infringement, and         ',&
'     implied warranties or conditions of merchantability and fitness     ',&
'     for a particular purpose;                                           ',&
'                                                                         ',&
'     ii) effectively excludes on behalf of all other Contributors all    ',&
'     liability for damages, including direct, indirect, special,         ',&
'     incidental and consequential damages, such as lost profits;         ',&
'                                                                         ',&
'     iii) does not attempt to limit or alter the recipients'' rights     ',&
'     in the Source Code under section 3.2; and                           ',&
'                                                                         ',&
'     iv) requires any subsequent distribution of the Program by any      ',&
'     party to be under a license that satisfies the requirements         ',&
'     of this section 3.                                                  ',&
'                                                                         ',&
'3.2 When the Program is Distributed as Source Code:                      ',&
'                                                                         ',&
'  a) it must be made available under this Agreement, or if the           ',&
'  Program (i) is combined with other material in a separate file or      ',&
'  files made available under a Secondary License, and (ii) the initial   ',&
'  Contributor attached to the Source Code the notice described in        ',&
'  Exhibit A of this Agreement, then the Program may be made available    ',&
'  under the terms of such Secondary Licenses, and                        ',&
'                                                                         ',&
'  b) a copy of this Agreement must be included with each copy of         ',&
'  the Program.                                                           ',&
'                                                                         ',&
'3.3 Contributors may not remove or alter any copyright, patent,          ',&
'trademark, attribution notices, disclaimers of warranty, or limitations  ',&
'of liability ("notices") contained within the Program from any copy of   ',&
'the Program which they Distribute, provided that Contributors may add    ',&
'their own appropriate notices.                                           ',&
'                                                                         ',&
'4. COMMERCIAL DISTRIBUTION                                               ',&
'                                                                         ',&
'Commercial distributors of software may accept certain responsibilities  ',&
'with respect to end users, business partners and the like. While this    ',&
'license is intended to facilitate the commercial use of the Program,     ',&
'the Contributor who includes the Program in a commercial product         ',&
'offering should do so in a manner which does not create potential        ',&
'liability for other Contributors. Therefore, if a Contributor includes   ',&
'the Program in a commercial product offering, such Contributor           ',&
'("Commercial Contributor") hereby agrees to defend and indemnify every   ',&
'other Contributor ("Indemnified Contributor") against any losses,        ',&
'damages and costs (collectively "Losses") arising from claims, lawsuits  ',&
'and other legal actions brought by a third party against the Indemnified ',&
'Contributor to the extent caused by the acts or omissions of such        ',&
'Commercial Contributor in connection with its distribution of the Program',&
'in a commercial product offering. The obligations in this section do not ',&
'apply to any claims or Losses relating to any actual or alleged          ',&
'intellectual property infringement. In order to qualify, an Indemnified  ',&
'Contributor must: a) promptly notify the Commercial Contributor in       ',&
'writing of such claim, and b) allow the Commercial Contributor to control,',&
'and cooperate with the Commercial Contributor in, the defense and any     ',&
'related settlement negotiations. The Indemnified Contributor may          ',&
'participate in any such claim at its own expense.                         ',&
'                                                                          ',&
'For example, a Contributor might include the Program in a commercial      ',&
'product offering, Product X. That Contributor is then a Commercial        ',&
'Contributor. If that Commercial Contributor then makes performance        ',&
'claims, or offers warranties related to Product X, those performance      ',&
'claims and warranties are such Commercial Contributor''s responsibility   ',&
'alone. Under this section, the Commercial Contributor would have to       ',&
'defend claims against the other Contributors related to those performance ',&
'claims and warranties, and if a court requires any other Contributor to   ',&
'pay any damages as a result, the Commercial Contributor must pay          ',&
'those damages.                                                            ',&
'                                                                          ',&
'5. NO WARRANTY                                                            ',&
'                                                                          ',&
'EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT        ',&
'PERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN "AS IS"        ',&
'BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR    ',&
'IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF    ',&
'TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR      ',&
'PURPOSE. Each Recipient is solely responsible for determining the         ',&
'appropriateness of using and distributing the Program and assumes all     ',&
'risks associated with its exercise of rights under this Agreement,        ',&
'including but not limited to the risks and costs of program errors,       ',&
'compliance with applicable laws, damage to or loss of data, programs      ',&
'or equipment, and unavailability or interruption of operations.           ',&
'                                                                          ',&
'6. DISCLAIMER OF LIABILITY                                                ',&
'                                                                          ',&
'EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT        ',&
'PERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS       ',&
'SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,   ',&
'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST    ',&
'PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN       ',&
'CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ',&
'ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE   ',&
'EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE          ',&
'POSSIBILITY OF SUCH DAMAGES.                                              ',&
'                                                                          ',&
'7. GENERAL                                                                ',&
'                                                                          ',&
'If any provision of this Agreement is invalid or unenforceable under      ',&
'applicable law, it shall not affect the validity or enforceability of     ',&
'the remainder of the terms of this Agreement, and without further         ',&
'action by the parties hereto, such provision shall be reformed to the     ',&
'minimum extent necessary to make such provision valid and enforceable.    ',&
'                                                                          ',&
'If Recipient institutes patent litigation against any entity              ',&
'(including a cross-claim or counterclaim in a lawsuit) alleging that the  ',&
'Program itself (excluding combinations of the Program with other software ',&
'or hardware) infringes such Recipient''s patent(s), then such Recipient''s',&
'rights granted under Section 2(b) shall terminate as of the date such     ',&
'litigation is filed.                                                      ',&
'                                                                          ',&
'All Recipient''s rights under this Agreement shall terminate if it        ',&
'fails to comply with any of the material terms or conditions of this      ',&
'Agreement and does not cure such failure in a reasonable period of        ',&
'time after becoming aware of such noncompliance. If all Recipient''s      ',&
'rights under this Agreement terminate, Recipient agrees to cease use      ',&
'and distribution of the Program as soon as reasonably practicable.        ',&
'However, Recipient''s obligations under this Agreement and any licenses   ',&
'granted by Recipient relating to the Program shall continue and survive.  ',&
'                                                                          ',&
'Everyone is permitted to copy and distribute copies of this Agreement,    ',&
'but in order to avoid inconsistency the Agreement is copyrighted and      ',&
'may only be modified in the following manner. The Agreement Steward       ',&
'reserves the right to publish new versions (including revisions) of       ',&
'this Agreement from time to time. No one other than the Agreement         ',&
'Steward has the right to modify this Agreement. The Eclipse Foundation    ',&
'is the initial Agreement Steward. The Eclipse Foundation may assign the   ',&
'responsibility to serve as the Agreement Steward to a suitable separate   ',&
'entity. Each new version of the Agreement will be given a distinguishing  ',&
'version number. The Program (including Contributions) may always be       ',&
'Distributed subject to the version of the Agreement under which it was    ',&
'received. In addition, after a new version of the Agreement is published, ',&
'Contributor may elect to Distribute the Program (including its            ',&
'Contributions) under the new version.                                     ',&
'                                                                          ',&
'Except as expressly stated in Sections 2(a) and 2(b) above, Recipient     ',&
'receives no rights or licenses to the intellectual property of any        ',&
'Contributor under this Agreement, whether expressly, by implication,      ',&
'estoppel or otherwise. All rights in the Program not expressly granted    ',&
'under this Agreement are reserved. Nothing in this Agreement is intended  ',&
'to be enforceable by any entity that is not a Contributor or Recipient.   ',&
'No third-party beneficiary rights are created under this Agreement.       ',&
'                                                                          ',&
'Exhibit A - Form of Secondary Licenses Notice                             ',&
'                                                                          ',&
'"This Source Code may also be made available under the following          ',&
'Secondary Licenses when the conditions for such availability set forth    ',&
'in the Eclipse Public License, v. 2.0 are satisfied: {name license(s),    ',&
'version(s), and exceptions or additional permissions here}."              ',&
'                                                                          ',&
'  Simply including a copy of this Agreement, including this Exhibit A     ',&
'  is not sufficient to license the Source Code under Secondary Licenses.  ',&
'                                                                          ',&
'  If it is not possible or desirable to put the notice in a particular    ',&
'  file, then You may include the notice in a location (such as a LICENSE  ',&
'  file in a relevant directory) where a recipient would be likely to      ',&
'  look for such a notice.                                                 ',&
'                                                                          ',&
'  You may add additional accurate notices of copyright ownership.         ',&
'                                                                          ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('23','eupl-1.1')
textblock=[ CHARACTER(LEN=128) :: &
'eupl-1.1',&
'        ',&
'European Union Public Licence',&
'V. 1.1                       ',&
'                             ',&
'                             ',&
'EUPL  the European Community 2007',&
'                                   ',&
'                                   ',&
'This European Union Public Licence (the EUPL) applies to the',&
'Work or Software (as defined below) which is provided under the terms of this',&
'Licence. Any use of the Work, other than as authorised under this Licence is ',&
'prohibited (to the extent such use is covered by a right of the copyright    ',&
'holder of the Work).                                                         ',&
'                                                                             ',&
'The Original Work is provided under the terms of this                        ',&
'Licence when the Licensor (as defined below) has placed the following notice ',&
'immediately following the copyright notice for the Original Work:            ',&
'                                                                             ',&
'Licensed under the EUPL V.1.1                                                ',&
'                                                                             ',&
'or has expressed by any other mean his willingness to license under the EUPL.',&
'                                                                             ',&
'                                                                             ',&
'1. Definitions                                                               ',&
'                                                                             ',&
'In this Licence, the                                                         ',&
'following terms have the following meaning:                                  ',&
'                                                                             ',&
'- The Licence: this Licence.                                                 ',&
'                                                                             ',&
'- The Original Work or the Software: the software distributed                ',&
'and/or communicated by the Licensor under this Licence, available as Source  ',&
'Code and also as Executable Code as the case may be.                         ',&
'                                                                             ',&
'- Derivative Works:                                                          ',&
'the works or software that could be created by the Licensee, based upon the  ',&
'Original Work or modifications thereof. This Licence does not define the     ',&
'extent of modification or dependence on the Original Work required in order to',&
'classify a work as a Derivative Work; this extent is determined by copyright  ',&
'law applicable in the country mentioned in Article 15.                        ',&
'                                                                              ',&
'- The Work: the Original Work and/or its Derivative Works.                    ',&
'                                                                              ',&
'- The Source Code: the human-readable form of the Work which is the most      ',&
'convenient for people to study and modify.                                    ',&
'                                                                              ',&
'- The Executable Code: any code which has generally been compiled and which   ',&
'is meant to be interpreted by a computer as a program.                        ',&
'                                                                              ',&
'- The Licensor: the natural or legal person that distributes and/or           ',&
'communicates the Work under the Licence.                                      ',&
'                                                                              ',&
'- Contributor(s): any natural or legal person who modifies the Work under the ',&
'Licence, or otherwise contributes to the creation of a Derivative Work.       ',&
'                                                                              ',&
'- The Licensee or You: any natural or legal person who makes any usage of',&
'the Software under the terms of the Licence.                                   ',&
'                                                                               ',&
'- Distribution and/or Communication: any act of selling, giving, lending,      ',&
'renting, distributing, communicating, transmitting, or otherwise               ',&
'making available, on-line or off-line, copies of the Work or providing access  ',&
'to its essential functionalities at the disposal of any other natural or legal ',&
'person.                                                                        ',&
'                                                                               ',&
'                                                                               ',&
'2. Scope of the rights granted by the Licence                                  ',&
'                                                                               ',&
'The Licensor hereby grants You a world-wide, royalty-free, non-exclusive,      ',&
'sub-licensable licence to do the following, for the duration of copyright      ',&
'vested in the Original Work:                                                   ',&
'                                                                               ',&
'- use the Work in any circumstance and for all usage,                          ',&
'- reproduce the Work,                                                          ',&
'- modify the Original Work, and make Derivative Works                          ',&
'based upon the Work,                                                           ',&
'- communicate to the public, including the right to make available or display  ',&
'the Work or copies thereof to the public and perform publicly, as the case     ',&
'may be, the Work,                                                              ',&
'- distribute the Work or copies thereof,                                       ',&
'- lend and rent the Work or copies thereof,                                    ',&
'- sub-license rights in the Work or copies thereof.                            ',&
'                                                                               ',&
'Those rights can be exercised on any media, supports and formats, whether now  ',&
'known or later invented, as far as the applicable law permits so.              ',&
'                                                                               ',&
'In the countries where moral rights apply, the Licensor waives his right to    ',&
'exercise his moral right to the extent allowed by law in order to make         ',&
'effective the licence of the economic rights here above listed.                ',&
'                                                                               ',&
'The Licensor grants to the Licensee royalty-free, non exclusive usage rights   ',&
'to any patents held by the Licensor, to the extent necessary to make use of    ',&
'the rights granted on the Work under this Licence.                             ',&
'                                                                               ',&
'                                                                               ',&
'3. Communication of the Source Code                                            ',&
'                                                                               ',&
'The Licensor may provide the Work either                                       ',&
'in its Source Code form, or as Executable Code. If the Work is provided as     ',&
'Executable Code, the Licensor provides in addition a machine-readable copy of  ',&
'the Source Code of the Work along with each copy of the Work that the Licensor ',&
'distributes or indicates, in a notice following the copyright notice attached  ',&
'to the Work, a repository where the Source Code is easily and freely           ',&
'accessible for as long as the Licensor continues to distribute and/or          ',&
'communicate the Work.                                                          ',&
'                                                                               ',&
'                                                                               ',&
'4. Limitations on copyright                                                    ',&
'                                                                               ',&
'Nothing in this Licence is intended to deprive the Licensee of the benefits    ',&
'from any exception or limitation to the exclusive rights of the rights owners  ',&
'in the Original Work or Software, of the exhaustion of those rights or of      ',&
'other applicable limitations thereto.                                          ',&
'                                                                               ',&
'                                                                               ',&
'5. Obligations of the Licensee                                                 ',&
'                                                                               ',&
'The grant of the rights mentioned above is subject to some restrictions and    ',&
'obligations imposed on the Licensee. Those obligations are the following:      ',&
'                                                                               ',&
'Attribution right:                                                             ',&
'the Licensee shall keep intact all copyright, patent or trademarks notices and ',&
'all notices that refer to the Licence and to the disclaimer of warranties. The ',&
'Licensee must include a copy of such notices and a copy of the Licence with    ',&
'every copy of the Work he/she distributes and/or communicates. The Licensee    ',&
'must cause any Derivative Work to carry prominent notices stating that the     ',&
'Work has been modified and the date of modification.                           ',&
'                                                                               ',&
'Copyleft clause:                                                               ',&
'If the Licensee distributes and/or communicates copies of the Original Works   ',&
'or Derivative Works based upon the Original Work, this Distribution and/or     ',&
'Communication will be done under the terms of this Licence or of a later       ',&
'version of this Licence unless the Original Work is expressly distributed only ',&
'under this version of the Licence. The Licensee (becoming Licensor) cannot     ',&
'offer or impose any additional terms or conditions on the Work or Derivative   ',&
'Work that alter or restrict the terms of the Licence.                          ',&
'                                                                               ',&
'Compatibility clause:                                                          ',&
'If the Licensee Distributes and/or Communicates Derivative Works or copies     ',&
'thereof based upon both the Original Work and another work  licensed under a   ',&
'Compatible Licence, this Distribution and/or Communication can be done under   ',&
'the terms of this Compatible Licence. For the sake of this clause,             ',&
'Compatible Licence refers to the licences listed in the appendix         ',&
'attached to this Licence. Should the Licensees obligations under the        ',&
'Compatible Licence conflict with his/her obligations under this Licence, the   ',&
'obligations of the Compatible Licence shall prevail.                           ',&
'                                                                               ',&
'Provision of Source Code:                                                      ',&
'When distributing and/or communicating copies of the Work, the Licensee        ',&
'will provide a machine-readable copy of the Source Code or indicate a          ',&
'repository where this Source will be easily and freely available for as long   ',&
'as the Licensee continues to distribute and/or communicate the Work.           ',&
'                                                                               ',&
'Legal Protection:                                                              ',&
'This Licence does not grant permission to use the trade names,                 ',&
'trademarks, service marks, or names of the Licensor, except as required for    ',&
'reasonable and customary use in describing the origin of the Work and          ',&
'reproducing the content of the copyright notice.                               ',&
'                                                                               ',&
'                                                                               ',&
'6. Chain of Authorship                                                         ',&
'                                                                               ',&
'The original Licensor warrants that the copyright in the Original Work         ',&
'granted hereunder is owned by him/her or licensed to him/her and               ',&
'that he/she has the power and authority to grant the Licence.                  ',&
'                                                                               ',&
'Each Contributor warrants that the copyright in the modifications he/she       ',&
'brings to the Work are owned by him/her or licensed to him/her and that        ',&
'he/she has the power and authority to grant the Licence.                       ',&
'                                                                               ',&
'Each time You accept the Licence, the original Licensor and subsequent         ',&
'Contributors grant You a licence to their contributions to the Work, under     ',&
'the terms of this Licence.                                                     ',&
'                                                                               ',&
'                                                                               ',&
'7. Disclaimer of Warranty                                                      ',&
'                                                                               ',&
'The Work is a work in progress, which is continuously improved by numerous     ',&
'contributors. It is not a finished work and may therefore contain defects or   ',&
'bugs inherent to this type of software development.                      ',&
'                                                                               ',&
'For the above reason, the Work is provided under the Licence on an as is ',&
'basis and without warranties of any kind concerning the Work, including        ',&
'without limitation merchantability, fitness for a particular purpose, absence  ',&
'of defects or errors, accuracy, non-infringement of intellectual property      ',&
'rights other than copyright as stated in Article 6 of this Licence.            ',&
'                                                                               ',&
'This disclaimer of warranty is an essential part of the Licence and a          ',&
'condition for the grant of any rights to the Work.                             ',&
'                                                                               ',&
'                                                                               ',&
'8. Disclaimer of Liability                                                     ',&
'                                                                               ',&
'Except in the cases of wilful misconduct or damages directly caused to         ',&
'natural persons, the Licensor will in no event be liable for any direct or     ',&
'indirect, material or moral, damages of any kind, arising out of the Licence   ',&
'or of the use of the Work, including without limitation,                       ',&
'damages for loss of goodwill, work stoppage, computer failure or malfunction,  ',&
'loss of data or any commercial damage, even if the Licensor has been advised   ',&
'of the possibility of such damage. However, the Licensor will be liable under  ',&
'statutory product liability laws as far such laws apply to the Work.           ',&
'                                                                               ',&
'                                                                               ',&
'9. Additional agreements                                                       ',&
'                                                                               ',&
'While distributing the Original Work or Derivative Works, You may choose       ',&
'to conclude an additional agreement to offer, and charge a fee for,            ',&
'acceptance of support, warranty, indemnity, or other liability                 ',&
'obligations and/or services consistent with this Licence. However, in          ',&
'accepting such obligations, You may act only on your own behalf and on your    ',&
'sole responsibility, not on behalf of the original Licensor or any other       ',&
'Contributor, and only if You agree to indemnify, defend, and hold each         ',&
'Contributor harmless for any liability incurred by, or claims asserted against ',&
'such Contributor by the fact You have accepted any such warranty or additional ',&
'liability.                                                                     ',&
'                                                                               ',&
'                                                                               ',&
'10. Acceptance of the Licence                                                  ',&
'                                                                               ',&
'The provisions of this Licence can be accepted by clicking on                  ',&
'an icon I agree placed under the bottom of a window displaying the text of',&
'this Licence or by affirming consent in any other similar way, in accordance    ',&
'with the rules of applicable law. Clicking on that icon indicates your clear    ',&
'and irrevocable acceptance of this Licence and                                  ',&
'all of its terms and conditions.                                                ',&
'                                                                                ',&
'Similarly, you irrevocably accept this Licence and                              ',&
'all of its terms and conditions by exercising any rights granted to You         ',&
'by Article 2 of this Licence, such as the use of the Work,                      ',&
'the creation by You of a Derivative Work or the Distribution and/or             ',&
'Communication by You of the Work or copies thereof.                             ',&
'                                                                                ',&
'                                                                                ',&
'11. Information to the public                                                   ',&
'                                                                                ',&
'In case of any Distribution and/or Communication of the Work by means of        ',&
'electronic communication by You (for example, by offering to download           ',&
'the Work from a remote location) the distribution channel or media (for         ',&
'example, a website) must at least provide to the public the information         ',&
'requested by the applicable law regarding the Licensor, the Licence and the     ',&
'way it may be accessible, concluded, stored and reproduced by the               ',&
'Licensee.                                                                       ',&
'                                                                                ',&
'                                                                                ',&
'12. Termination of the Licence                                                  ',&
'                                                                                ',&
'The Licence and the rights granted hereunder will terminate automatically       ',&
'upon any breach by the Licensee of the terms of the Licence.                    ',&
'                                                                                ',&
'Such a termination will not terminate the licences of any person who has        ',&
'received the Work from the Licensee under the Licence, provided such persons    ',&
'remain in full compliance with the Licence.                                     ',&
'                                                                                ',&
'                                                                                ',&
'13. Miscellaneous                                                               ',&
'                                                                                ',&
'Without prejudice of Article 9 above, the Licence represents the complete       ',&
'agreement between the Parties as to the Work licensed hereunder.                ',&
'                                                                                ',&
'If any provision of the Licence is invalid or unenforceable under applicable    ',&
'law, this will not affect the validity or enforceability of the Licence as a    ',&
'whole. Such provision will be construed and/or reformed so as necessary         ',&
'to make it valid and enforceable.                                               ',&
'                                                                                ',&
'The European Commission may publish other linguistic versions and/or new        ',&
'versions of this Licence, so far this is required and reasonable, without       ',&
'reducing the scope of the rights granted by the Licence.                        ',&
'New versions of the Licence will be published with a unique version number.     ',&
'                                                                                ',&
'All linguistic versions of this Licence, approved by the European Commission,   ',&
'have identical value. Parties can take advantage of the linguistic version      ',&
'of their choice.                                                                ',&
'                                                                                ',&
'                                                                                ',&
'14. Jurisdiction                                                                ',&
'                                                                                ',&
'Any litigation resulting from the interpretation of this License, arising       ',&
'between the European Commission, as a Licensor, and any Licensee,               ',&
'will be subject to the jurisdiction of the Court of Justice of the              ',&
'European Communities, as laid down in article 238 of the Treaty establishing    ',&
'the European Community.                                                         ',&
'                                                                                ',&
'Any litigation arising between Parties, other than the European Commission,     ',&
'and resulting from the interpretation of this License, will be subject to the   ',&
'exclusive jurisdiction of the competent court where the Licensor resides or     ',&
'conducts its primary business.                                                  ',&
'                                                                                ',&
'                                                                                ',&
'15. Applicable Law                                                              ',&
'                                                                                ',&
'This Licence shall be governed by the law of the European Union country where   ',&
'the Licensor resides or has his registered office.                              ',&
'                                                                                ',&
'This licence shall be governed by the Belgian law if:                           ',&
'                                                                                ',&
'- a litigation arises between the European Commission, as a Licensor, and any   ',&
'Licensee;                                                                       ',&
'- the Licensor, other than the European Commission, has no residence or         ',&
'registered office inside a European Union country.                              ',&
'                                                                                ',&
'                                                                                ',&
'===                                                                             ',&
'                                                                                ',&
'                                                                                ',&
'Appendix                                                                        ',&
'                                                                                ',&
'                                                                                ',&
'Compatible Licences according to article 5 EUPL are:                      ',&
'- GNU General Public License (GNU GPL) v. 2                                     ',&
'- Open Software License (OSL) v. 2.1, v. 3.0                                    ',&
'- Common Public License v. 1.0                                                  ',&
'- Eclipse Public License v. 1.0                                                 ',&
'- Cecill v. 2.0                                                                 ',&
'                                                                                ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('24','eupl-1.2')
textblock=[ CHARACTER(LEN=128) :: &
'eupl-1.2',&
'        ',&
'                      EUROPEAN UNION PUBLIC LICENCE v. 1.2',&
'                      EUPL  the European Union 2007, 2016',&
'                                                           ',&
'This European Union Public Licence (the EUPL) applies to the Work (as',&
'defined below) which is provided under the terms of this Licence. Any use of',&
'the Work, other than as authorised under this Licence is prohibited (to the ',&
'extent such use is covered by a right of the copyright holder of the Work). ',&
'                                                                            ',&
'The Work is provided under the terms of this Licence when the Licensor (as  ',&
'defined below) has placed the following notice immediately following the    ',&
'copyright notice for the Work:                                              ',&
'                                                                            ',&
'        Licensed under the EUPL                                             ',&
'                                                                            ',&
'or has expressed by any other means his willingness to license under the EUPL.',&
'                                                                              ',&
'1. Definitions                                                                ',&
'                                                                              ',&
'In this Licence, the following terms have the following meaning:              ',&
'                                                                              ',&
'- The Licence: this Licence.                                            ',&
'                                                                              ',&
'- The Original Work: the work or software distributed or communicated by the',&
'  Licensor under this Licence, available as Source Code and also as Executable    ',&
'  Code as the case may be.                                                        ',&
'                                                                                  ',&
'- Derivative Works: the works or software that could be created by the      ',&
'  Licensee, based upon the Original Work or modifications thereof. This           ',&
'  Licence does not define the extent of modification or dependence on the         ',&
'  Original Work required in order to classify a work as a Derivative Work;        ',&
'  this extent is determined by copyright law applicable in the country            ',&
'  mentioned in Article 15.                                                        ',&
'                                                                                  ',&
'- The Work: the Original Work or its Derivative Works.                      ',&
'                                                                                  ',&
'- The Source Code: the human-readable form of the Work which is the most    ',&
'  convenient for people to study and modify.                                      ',&
'                                                                                  ',&
'- The Executable Code: any code which has generally been compiled and which ',&
'  is meant to be interpreted by a computer as a program.                          ',&
'                                                                                  ',&
'- The Licensor: the natural or legal person that distributes or communicates',&
'  the Work under the Licence.                                                     ',&
'                                                                                  ',&
'- Contributor(s): any natural or legal person who modifies the Work under   ',&
'  the Licence, or otherwise contributes to the creation of a Derivative Work.     ',&
'                                                                                  ',&
'- The Licensee or You: any natural or legal person who makes any usage of',&
'  the Work under the terms of the Licence.                                           ',&
'                                                                                     ',&
'- Distribution or Communication: any act of selling, giving, lending,    ',&
'  renting, distributing, communicating, transmitting, or otherwise making            ',&
'  available, online or offline, copies of the Work or providing access to its        ',&
'  essential functionalities at the disposal of any other natural or legal            ',&
'  person.                                                                            ',&
'                                                                                     ',&
'2. Scope of the rights granted by the Licence                                        ',&
'                                                                                     ',&
'The Licensor hereby grants You a worldwide, royalty-free, non-exclusive,             ',&
'sublicensable licence to do the following, for the duration of copyright             ',&
'vested in the Original Work:                                                         ',&
'                                                                                     ',&
'- use the Work in any circumstance and for all usage,                                ',&
'- reproduce the Work,                                                                ',&
'- modify the Work, and make Derivative Works based upon the Work,                    ',&
'- communicate to the public, including the right to make available or display        ',&
'  the Work or copies thereof to the public and perform publicly, as the case         ',&
'  may be, the Work,                                                                  ',&
'- distribute the Work or copies thereof,                                             ',&
'- lend and rent the Work or copies thereof,                                          ',&
'- sublicense rights in the Work or copies thereof.                                   ',&
'                                                                                     ',&
'Those rights can be exercised on any media, supports and formats, whether now        ',&
'known or later invented, as far as the applicable law permits so.                    ',&
'                                                                                     ',&
'In the countries where moral rights apply, the Licensor waives his right to          ',&
'exercise his moral right to the extent allowed by law in order to make               ',&
'effective the licence of the economic rights here above listed.                      ',&
'                                                                                     ',&
'The Licensor grants to the Licensee royalty-free, non-exclusive usage rights         ',&
'to any patents held by the Licensor, to the extent necessary to make use of          ',&
'the rights granted on the Work under this Licence.                                   ',&
'                                                                                     ',&
'3. Communication of the Source Code                                                  ',&
'                                                                                     ',&
'The Licensor may provide the Work either in its Source Code form, or as              ',&
'Executable Code. If the Work is provided as Executable Code, the Licensor            ',&
'provides in addition a machine-readable copy of the Source Code of the Work          ',&
'along with each copy of the Work that the Licensor distributes or indicates,         ',&
'in a notice following the copyright notice attached to the Work, a repository        ',&
'where the Source Code is easily and freely accessible for as long as the             ',&
'Licensor continues to distribute or communicate the Work.                            ',&
'                                                                                     ',&
'4. Limitations on copyright                                                          ',&
'                                                                                     ',&
'Nothing in this Licence is intended to deprive the Licensee of the benefits          ',&
'from any exception or limitation to the exclusive rights of the rights owners        ',&
'in the Work, of the exhaustion of those rights or of other applicable                ',&
'limitations thereto.                                                                 ',&
'                                                                                     ',&
'5. Obligations of the Licensee                                                       ',&
'                                                                                     ',&
'The grant of the rights mentioned above is subject to some restrictions and          ',&
'obligations imposed on the Licensee. Those obligations are the following:            ',&
'                                                                                     ',&
'Attribution right: The Licensee shall keep intact all copyright, patent or           ',&
'trademarks notices and all notices that refer to the Licence and to the              ',&
'disclaimer of warranties. The Licensee must include a copy of such notices and       ',&
'a copy of the Licence with every copy of the Work he/she distributes or              ',&
'communicates. The Licensee must cause any Derivative Work to carry prominent         ',&
'notices stating that the Work has been modified and the date of modification.        ',&
'                                                                                     ',&
'Copyleft clause: If the Licensee distributes or communicates copies of the           ',&
'Original Works or Derivative Works, this Distribution or Communication will be       ',&
'done under the terms of this Licence or of a later version of this Licence           ',&
'unless the Original Work is expressly distributed only under this version of         ',&
'the Licence  for example by communicating EUPL v. 1.2 only. The Licensee    ',&
'(becoming Licensor) cannot offer or impose any additional terms or conditions        ',&
'on the Work or Derivative Work that alter or restrict the terms of the               ',&
'Licence.                                                                             ',&
'                                                                                     ',&
'Compatibility clause: If the Licensee Distributes or Communicates Derivative         ',&
'Works or copies thereof based upon both the Work and another work licensed           ',&
'under a Compatible Licence, this Distribution or Communication can be done           ',&
'under the terms of this Compatible Licence. For the sake of this clause,             ',&
'Compatible Licence refers to the licences listed in the appendix attached to   ',&
'this Licence. Should the Licensee''s obligations under the Compatible Licence        ',&
'conflict with his/her obligations under this Licence, the obligations of the         ',&
'Compatible Licence shall prevail.                                                    ',&
'                                                                                     ',&
'Provision of Source Code: When distributing or communicating copies of the           ',&
'Work, the Licensee will provide a machine-readable copy of the Source Code or        ',&
'indicate a repository where this Source will be easily and freely available          ',&
'for as long as the Licensee continues to distribute or communicate the Work.         ',&
'                                                                                     ',&
'Legal Protection: This Licence does not grant permission to use the trade            ',&
'names, trademarks, service marks, or names of the Licensor, except as required       ',&
'for reasonable and customary use in describing the origin of the Work and            ',&
'reproducing the content of the copyright notice.                                     ',&
'                                                                                     ',&
'6. Chain of Authorship                                                               ',&
'                                                                                     ',&
'The original Licensor warrants that the copyright in the Original Work granted       ',&
'hereunder is owned by him/her or licensed to him/her and that he/she has the         ',&
'power and authority to grant the Licence.                                            ',&
'                                                                                     ',&
'Each Contributor warrants that the copyright in the modifications he/she             ',&
'brings to the Work are owned by him/her or licensed to him/her and that he/she       ',&
'has the power and authority to grant the Licence.                                    ',&
'                                                                                     ',&
'Each time You accept the Licence, the original Licensor and subsequent               ',&
'Contributors grant You a licence to their contributions to the Work, under the       ',&
'terms of this Licence.                                                               ',&
'                                                                                     ',&
'7. Disclaimer of Warranty                                                            ',&
'                                                                                     ',&
'The Work is a work in progress, which is continuously improved by numerous           ',&
'Contributors. It is not a finished work and may therefore contain defects or         ',&
'bugs inherent to this type of development.                                     ',&
'                                                                                     ',&
'For the above reason, the Work is provided under the Licence on an as is       ',&
'basis and without warranties of any kind concerning the Work, including              ',&
'without limitation merchantability, fitness for a particular purpose, absence        ',&
'of defects or errors, accuracy, non-infringement of intellectual property            ',&
'rights other than copyright as stated in Article 6 of this Licence.                  ',&
'                                                                                     ',&
'This disclaimer of warranty is an essential part of the Licence and a                ',&
'condition for the grant of any rights to the Work.                                   ',&
'                                                                                     ',&
'8. Disclaimer of Liability                                                           ',&
'                                                                                     ',&
'Except in the cases of wilful misconduct or damages directly caused to natural       ',&
'persons, the Licensor will in no event be liable for any direct or indirect,         ',&
'material or moral, damages of any kind, arising out of the Licence or of the         ',&
'use of the Work, including without limitation, damages for loss of goodwill,         ',&
'work stoppage, computer failure or malfunction, loss of data or any commercial       ',&
'damage, even if the Licensor has been advised of the possibility of such             ',&
'damage. However, the Licensor will be liable under statutory product liability       ',&
'laws as far such laws apply to the Work.                                             ',&
'                                                                                     ',&
'9. Additional agreements                                                             ',&
'                                                                                     ',&
'While distributing the Work, You may choose to conclude an additional                ',&
'agreement, defining obligations or services consistent with this Licence.            ',&
'However, if accepting obligations, You may act only on your own behalf and on        ',&
'your sole responsibility, not on behalf of the original Licensor or any other        ',&
'Contributor, and only if You agree to indemnify, defend, and hold each               ',&
'Contributor harmless for any liability incurred by, or claims asserted against       ',&
'such Contributor by the fact You have accepted any warranty or additional            ',&
'liability.                                                                           ',&
'                                                                                     ',&
'10. Acceptance of the Licence                                                        ',&
'                                                                                     ',&
'The provisions of this Licence can be accepted by clicking on an icon I           ',&
'agree placed under the bottom of a window displaying the text of this Licence     ',&
'or by affirming consent in any other similar way, in accordance with the rules       ',&
'of applicable law. Clicking on that icon indicates your clear and irrevocable        ',&
'acceptance of this Licence and all of its terms and conditions.                      ',&
'                                                                                     ',&
'Similarly, you irrevocably accept this Licence and all of its terms and              ',&
'conditions by exercising any rights granted to You by Article 2 of this              ',&
'Licence, such as the use of the Work, the creation by You of a Derivative Work       ',&
'or the Distribution or Communication by You of the Work or copies thereof.           ',&
'                                                                                     ',&
'11. Information to the public                                                        ',&
'                                                                                     ',&
'In case of any Distribution or Communication of the Work by means of                 ',&
'electronic communication by You (for example, by offering to download the Work       ',&
'from a remote location) the distribution channel or media (for example, a            ',&
'website) must at least provide to the public the information requested by the        ',&
'applicable law regarding the Licensor, the Licence and the way it may be             ',&
'accessible, concluded, stored and reproduced by the Licensee.                        ',&
'                                                                                     ',&
'12. Termination of the Licence                                                       ',&
'                                                                                     ',&
'The Licence and the rights granted hereunder will terminate automatically upon       ',&
'any breach by the Licensee of the terms of the Licence.                              ',&
'                                                                                     ',&
'Such a termination will not terminate the licences of any person who has             ',&
'received the Work from the Licensee under the Licence, provided such persons         ',&
'remain in full compliance with the Licence.                                          ',&
'                                                                                     ',&
'13. Miscellaneous                                                                    ',&
'                                                                                     ',&
'Without prejudice of Article 9 above, the Licence represents the complete            ',&
'agreement between the Parties as to the Work.                                        ',&
'                                                                                     ',&
'If any provision of the Licence is invalid or unenforceable under applicable         ',&
'law, this will not affect the validity or enforceability of the Licence as a         ',&
'whole. Such provision will be construed or reformed so as necessary to make it       ',&
'valid and enforceable.                                                               ',&
'                                                                                     ',&
'The European Commission may publish other linguistic versions or new versions        ',&
'of this Licence or updated versions of the Appendix, so far this is required         ',&
'and reasonable, without reducing the scope of the rights granted by the              ',&
'Licence. New versions of the Licence will be published with a unique version         ',&
'number.                                                                              ',&
'                                                                                     ',&
'All linguistic versions of this Licence, approved by the European Commission,        ',&
'have identical value. Parties can take advantage of the linguistic version of        ',&
'their choice.                                                                        ',&
'                                                                                     ',&
'14. Jurisdiction                                                                     ',&
'                                                                                     ',&
'Without prejudice to specific agreement between parties,                             ',&
'                                                                                     ',&
'- any litigation resulting from the interpretation of this License, arising          ',&
'  between the European Union institutions, bodies, offices or agencies, as a         ',&
'  Licensor, and any Licensee, will be subject to the jurisdiction of the Court       ',&
'  of Justice of the European Union, as laid down in article 272 of the Treaty        ',&
'  on the Functioning of the European Union,                                          ',&
'                                                                                     ',&
'- any litigation arising between other parties and resulting from the                ',&
'  interpretation of this License, will be subject to the exclusive                   ',&
'  jurisdiction of the competent court where the Licensor resides or conducts         ',&
'  its primary business.                                                              ',&
'                                                                                     ',&
'15. Applicable Law                                                                   ',&
'                                                                                     ',&
'Without prejudice to specific agreement between parties,                             ',&
'                                                                                     ',&
'- this Licence shall be governed by the law of the European Union Member State       ',&
'  where the Licensor has his seat, resides or has his registered office,             ',&
'                                                                                     ',&
'- this licence shall be governed by Belgian law if the Licensor has no seat,         ',&
'  residence or registered office inside a European Union Member State.               ',&
'                                                                                     ',&
'Appendix                                                                             ',&
'                                                                                     ',&
'Compatible Licences according to Article 5 EUPL are:                           ',&
'                                                                                     ',&
'- GNU General Public License (GPL) v. 2, v. 3                                        ',&
'- GNU Affero General Public License (AGPL) v. 3                                      ',&
'- Open Software License (OSL) v. 2.1, v. 3.0                                         ',&
'- Eclipse Public License (EPL) v. 1.0                                                ',&
'- CeCILL v. 2.0, v. 2.1                                                              ',&
'- Mozilla Public Licence (MPL) v. 2                                                  ',&
'- GNU Lesser General Public Licence (LGPL) v. 2.1, v. 3                              ',&
'- Creative Commons Attribution-ShareAlike v. 3.0 Unported (CC BY-SA 3.0) for         ',&
'  works other than software                                                          ',&
'- European Union Public Licence (EUPL) v. 1.1, v. 1.2                                ',&
'- Qubec Free and Open-Source Licence  Reciprocity (LiLiQ-R) or Strong           ',&
'  Reciprocity (LiLiQ-R+).                                                            ',&
'                                                                                     ',&
'The European Commission may update this Appendix to later versions of the            ',&
'above licences without producing a new version of the EUPL, as long as they          ',&
'provide the rights granted in Article 2 of this Licence and protect the              ',&
'covered Source Code from exclusive appropriation.                                    ',&
'                                                                                     ',&
'All other changes or additions to this Appendix require the production of a          ',&
'new EUPL version.                                                                    ',&
'                                                                                     ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('25','gfdl-1.3')
textblock=[ CHARACTER(LEN=128) :: &
'gfdl-1.3',&
'        ',&
'                GNU Free Documentation License',&
'                 Version 1.3, 3 November 2008 ',&
'                                              ',&
'                                              ',&
' Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.',&
'     <https://fsf.org/>                                                   ',&
' Everyone is permitted to copy and distribute verbatim copies             ',&
' of this license document, but changing it is not allowed.                ',&
'                                                                          ',&
'0. PREAMBLE                                                               ',&
'                                                                          ',&
'The purpose of this License is to make a manual, textbook, or other       ',&
'functional and useful document "free" in the sense of freedom: to         ',&
'assure everyone the effective freedom to copy and redistribute it,        ',&
'with or without modifying it, either commercially or noncommercially.     ',&
'Secondarily, this License preserves for the author and publisher a way    ',&
'to get credit for their work, while not being considered responsible      ',&
'for modifications made by others.                                         ',&
'                                                                          ',&
'This License is a kind of "copyleft", which means that derivative         ',&
'works of the document must themselves be free in the same sense.  It      ',&
'complements the GNU General Public License, which is a copyleft           ',&
'license designed for free software.                                       ',&
'                                                                          ',&
'We have designed this License in order to use it for manuals for free     ',&
'software, because free software needs free documentation: a free          ',&
'program should come with manuals providing the same freedoms that the     ',&
'software does.  But this License is not limited to software manuals;      ',&
'it can be used for any textual work, regardless of subject matter or      ',&
'whether it is published as a printed book.  We recommend this License     ',&
'principally for works whose purpose is instruction or reference.          ',&
'                                                                          ',&
'                                                                          ',&
'1. APPLICABILITY AND DEFINITIONS                                          ',&
'                                                                          ',&
'This License applies to any manual or other work, in any medium, that     ',&
'contains a notice placed by the copyright holder saying it can be         ',&
'distributed under the terms of this License.  Such a notice grants a      ',&
'world-wide, royalty-free license, unlimited in duration, to use that      ',&
'work under the conditions stated herein.  The "Document", below,          ',&
'refers to any such manual or work.  Any member of the public is a         ',&
'licensee, and is addressed as "you".  You accept the license if you       ',&
'copy, modify or distribute the work in a way requiring permission         ',&
'under copyright law.                                                      ',&
'                                                                          ',&
'A "Modified Version" of the Document means any work containing the        ',&
'Document or a portion of it, either copied verbatim, or with              ',&
'modifications and/or translated into another language.                    ',&
'                                                                          ',&
'A "Secondary Section" is a named appendix or a front-matter section of    ',&
'the Document that deals exclusively with the relationship of the          ',&
'publishers or authors of the Document to the Document''s overall          ',&
'subject (or to related matters) and contains nothing that could fall      ',&
'directly within that overall subject.  (Thus, if the Document is in       ',&
'part a textbook of mathematics, a Secondary Section may not explain       ',&
'any mathematics.)  The relationship could be a matter of historical       ',&
'connection with the subject or with related matters, or of legal,         ',&
'commercial, philosophical, ethical or political position regarding        ',&
'them.                                                                     ',&
'                                                                          ',&
'The "Invariant Sections" are certain Secondary Sections whose titles      ',&
'are designated, as being those of Invariant Sections, in the notice       ',&
'that says that the Document is released under this License.  If a         ',&
'section does not fit the above definition of Secondary then it is not     ',&
'allowed to be designated as Invariant.  The Document may contain zero     ',&
'Invariant Sections.  If the Document does not identify any Invariant      ',&
'Sections then there are none.                                             ',&
'                                                                          ',&
'The "Cover Texts" are certain short passages of text that are listed,     ',&
'as Front-Cover Texts or Back-Cover Texts, in the notice that says that    ',&
'the Document is released under this License.  A Front-Cover Text may      ',&
'be at most 5 words, and a Back-Cover Text may be at most 25 words.        ',&
'                                                                          ',&
'A "Transparent" copy of the Document means a machine-readable copy,       ',&
'represented in a format whose specification is available to the           ',&
'general public, that is suitable for revising the document                ',&
'straightforwardly with generic text editors or (for images composed of    ',&
'pixels) generic paint programs or (for drawings) some widely available    ',&
'drawing editor, and that is suitable for input to text formatters or      ',&
'for automatic translation to a variety of formats suitable for input      ',&
'to text formatters.  A copy made in an otherwise Transparent file         ',&
'format whose markup, or absence of markup, has been arranged to thwart    ',&
'or discourage subsequent modification by readers is not Transparent.      ',&
'An image format is not Transparent if used for any substantial amount     ',&
'of text.  A copy that is not "Transparent" is called "Opaque".            ',&
'                                                                          ',&
'Examples of suitable formats for Transparent copies include plain         ',&
'ASCII without markup, Texinfo input format, LaTeX input format, SGML      ',&
'or XML using a publicly available DTD, and standard-conforming simple     ',&
'HTML, PostScript or PDF designed for human modification.  Examples of     ',&
'transparent image formats include PNG, XCF and JPG.  Opaque formats       ',&
'include proprietary formats that can be read and edited only by           ',&
'proprietary word processors, SGML or XML for which the DTD and/or         ',&
'processing tools are not generally available, and the                     ',&
'machine-generated HTML, PostScript or PDF produced by some word           ',&
'processors for output purposes only.                                      ',&
'                                                                          ',&
'The "Title Page" means, for a printed book, the title page itself,        ',&
'plus such following pages as are needed to hold, legibly, the material    ',&
'this License requires to appear in the title page.  For works in          ',&
'formats which do not have any title page as such, "Title Page" means      ',&
'the text near the most prominent appearance of the work''s title,         ',&
'preceding the beginning of the body of the text.                          ',&
'                                                                          ',&
'The "publisher" means any person or entity that distributes copies of     ',&
'the Document to the public.                                               ',&
'                                                                          ',&
'A section "Entitled XYZ" means a named subunit of the Document whose      ',&
'title either is precisely XYZ or contains XYZ in parentheses following    ',&
'text that translates XYZ in another language.  (Here XYZ stands for a     ',&
'specific section name mentioned below, such as "Acknowledgements",        ',&
'"Dedications", "Endorsements", or "History".)  To "Preserve the Title"    ',&
'of such a section when you modify the Document means that it remains a    ',&
'section "Entitled XYZ" according to this definition.                      ',&
'                                                                          ',&
'The Document may include Warranty Disclaimers next to the notice which    ',&
'states that this License applies to the Document.  These Warranty         ',&
'Disclaimers are considered to be included by reference in this            ',&
'License, but only as regards disclaiming warranties: any other            ',&
'implication that these Warranty Disclaimers may have is void and has      ',&
'no effect on the meaning of this License.                                 ',&
'                                                                          ',&
'2. VERBATIM COPYING                                                       ',&
'                                                                          ',&
'You may copy and distribute the Document in any medium, either            ',&
'commercially or noncommercially, provided that this License, the          ',&
'copyright notices, and the license notice saying this License applies     ',&
'to the Document are reproduced in all copies, and that you add no         ',&
'other conditions whatsoever to those of this License.  You may not use    ',&
'technical measures to obstruct or control the reading or further          ',&
'copying of the copies you make or distribute.  However, you may accept    ',&
'compensation in exchange for copies.  If you distribute a large enough    ',&
'number of copies you must also follow the conditions in section 3.        ',&
'                                                                          ',&
'You may also lend copies, under the same conditions stated above, and     ',&
'you may publicly display copies.                                          ',&
'                                                                          ',&
'                                                                          ',&
'3. COPYING IN QUANTITY                                                    ',&
'                                                                          ',&
'If you publish printed copies (or copies in media that commonly have      ',&
'printed covers) of the Document, numbering more than 100, and the         ',&
'Document''s license notice requires Cover Texts, you must enclose the     ',&
'copies in covers that carry, clearly and legibly, all these Cover         ',&
'Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on      ',&
'the back cover.  Both covers must also clearly and legibly identify       ',&
'you as the publisher of these copies.  The front cover must present       ',&
'the full title with all words of the title equally prominent and          ',&
'visible.  You may add other material on the covers in addition.           ',&
'Copying with changes limited to the covers, as long as they preserve      ',&
'the title of the Document and satisfy these conditions, can be treated    ',&
'as verbatim copying in other respects.                                    ',&
'                                                                          ',&
'If the required texts for either cover are too voluminous to fit          ',&
'legibly, you should put the first ones listed (as many as fit             ',&
'reasonably) on the actual cover, and continue the rest onto adjacent      ',&
'pages.                                                                    ',&
'                                                                          ',&
'If you publish or distribute Opaque copies of the Document numbering      ',&
'more than 100, you must either include a machine-readable Transparent     ',&
'copy along with each Opaque copy, or state in or with each Opaque copy    ',&
'a computer-network location from which the general network-using          ',&
'public has access to download using public-standard network protocols     ',&
'a complete Transparent copy of the Document, free of added material.      ',&
'If you use the latter option, you must take reasonably prudent steps,     ',&
'when you begin distribution of Opaque copies in quantity, to ensure       ',&
'that this Transparent copy will remain thus accessible at the stated      ',&
'location until at least one year after the last time you distribute an    ',&
'Opaque copy (directly or through your agents or retailers) of that        ',&
'edition to the public.                                                    ',&
'                                                                          ',&
'It is requested, but not required, that you contact the authors of the    ',&
'Document well before redistributing any large number of copies, to        ',&
'give them a chance to provide you with an updated version of the          ',&
'Document.                                                                 ',&
'                                                                          ',&
'                                                                          ',&
'4. MODIFICATIONS                                                          ',&
'                                                                          ',&
'You may copy and distribute a Modified Version of the Document under      ',&
'the conditions of sections 2 and 3 above, provided that you release       ',&
'the Modified Version under precisely this License, with the Modified      ',&
'Version filling the role of the Document, thus licensing distribution     ',&
'and modification of the Modified Version to whoever possesses a copy      ',&
'of it.  In addition, you must do these things in the Modified Version:    ',&
'                                                                          ',&
'A. Use in the Title Page (and on the covers, if any) a title distinct     ',&
'   from that of the Document, and from those of previous versions         ',&
'   (which should, if there were any, be listed in the History section     ',&
'   of the Document).  You may use the same title as a previous version    ',&
'   if the original publisher of that version gives permission.            ',&
'B. List on the Title Page, as authors, one or more persons or entities    ',&
'   responsible for authorship of the modifications in the Modified        ',&
'   Version, together with at least five of the principal authors of the   ',&
'   Document (all of its principal authors, if it has fewer than five),    ',&
'   unless they release you from this requirement.                         ',&
'C. State on the Title page the name of the publisher of the               ',&
'   Modified Version, as the publisher.                                    ',&
'D. Preserve all the copyright notices of the Document.                    ',&
'E. Add an appropriate copyright notice for your modifications             ',&
'   adjacent to the other copyright notices.                               ',&
'F. Include, immediately after the copyright notices, a license notice     ',&
'   giving the public permission to use the Modified Version under the     ',&
'   terms of this License, in the form shown in the Addendum below.        ',&
'G. Preserve in that license notice the full lists of Invariant Sections   ',&
'   and required Cover Texts given in the Document''s license notice.      ',&
'H. Include an unaltered copy of this License.                             ',&
'I. Preserve the section Entitled "History", Preserve its Title, and add   ',&
'   to it an item stating at least the title, year, new authors, and       ',&
'   publisher of the Modified Version as given on the Title Page.  If      ',&
'   there is no section Entitled "History" in the Document, create one     ',&
'   stating the title, year, authors, and publisher of the Document as     ',&
'   given on its Title Page, then add an item describing the Modified      ',&
'   Version as stated in the previous sentence.                            ',&
'J. Preserve the network location, if any, given in the Document for       ',&
'   public access to a Transparent copy of the Document, and likewise      ',&
'   the network locations given in the Document for previous versions      ',&
'   it was based on.  These may be placed in the "History" section.        ',&
'   You may omit a network location for a work that was published at       ',&
'   least four years before the Document itself, or if the original        ',&
'   publisher of the version it refers to gives permission.                ',&
'K. For any section Entitled "Acknowledgements" or "Dedications",          ',&
'   Preserve the Title of the section, and preserve in the section all     ',&
'   the substance and tone of each of the contributor acknowledgements     ',&
'   and/or dedications given therein.                                      ',&
'L. Preserve all the Invariant Sections of the Document,                   ',&
'   unaltered in their text and in their titles.  Section numbers          ',&
'   or the equivalent are not considered part of the section titles.       ',&
'M. Delete any section Entitled "Endorsements".  Such a section            ',&
'   may not be included in the Modified Version.                           ',&
'N. Do not retitle any existing section to be Entitled "Endorsements"      ',&
'   or to conflict in title with any Invariant Section.                    ',&
'O. Preserve any Warranty Disclaimers.                                     ',&
'                                                                          ',&
'If the Modified Version includes new front-matter sections or             ',&
'appendices that qualify as Secondary Sections and contain no material     ',&
'copied from the Document, you may at your option designate some or all    ',&
'of these sections as invariant.  To do this, add their titles to the      ',&
'list of Invariant Sections in the Modified Version''s license notice.     ',&
'These titles must be distinct from any other section titles.              ',&
'                                                                          ',&
'You may add a section Entitled "Endorsements", provided it contains       ',&
'nothing but endorsements of your Modified Version by various              ',&
'parties--for example, statements of peer review or that the text has      ',&
'been approved by an organization as the authoritative definition of a     ',&
'standard.                                                                 ',&
'                                                                          ',&
'You may add a passage of up to five words as a Front-Cover Text, and a    ',&
'passage of up to 25 words as a Back-Cover Text, to the end of the list    ',&
'of Cover Texts in the Modified Version.  Only one passage of              ',&
'Front-Cover Text and one of Back-Cover Text may be added by (or           ',&
'through arrangements made by) any one entity.  If the Document already    ',&
'includes a cover text for the same cover, previously added by you or      ',&
'by arrangement made by the same entity you are acting on behalf of,       ',&
'you may not add another; but you may replace the old one, on explicit     ',&
'permission from the previous publisher that added the old one.            ',&
'                                                                          ',&
'The author(s) and publisher(s) of the Document do not by this License     ',&
'give permission to use their names for publicity for or to assert or      ',&
'imply endorsement of any Modified Version.                                ',&
'                                                                          ',&
'                                                                          ',&
'5. COMBINING DOCUMENTS                                                    ',&
'                                                                          ',&
'You may combine the Document with other documents released under this     ',&
'License, under the terms defined in section 4 above for modified          ',&
'versions, provided that you include in the combination all of the         ',&
'Invariant Sections of all of the original documents, unmodified, and      ',&
'list them all as Invariant Sections of your combined work in its          ',&
'license notice, and that you preserve all their Warranty Disclaimers.     ',&
'                                                                          ',&
'The combined work need only contain one copy of this License, and         ',&
'multiple identical Invariant Sections may be replaced with a single       ',&
'copy.  If there are multiple Invariant Sections with the same name but    ',&
'different contents, make the title of each such section unique by         ',&
'adding at the end of it, in parentheses, the name of the original         ',&
'author or publisher of that section if known, or else a unique number.    ',&
'Make the same adjustment to the section titles in the list of             ',&
'Invariant Sections in the license notice of the combined work.            ',&
'                                                                          ',&
'In the combination, you must combine any sections Entitled "History"      ',&
'in the various original documents, forming one section Entitled           ',&
'"History"; likewise combine any sections Entitled "Acknowledgements",     ',&
'and any sections Entitled "Dedications".  You must delete all sections    ',&
'Entitled "Endorsements".                                                  ',&
'                                                                          ',&
'                                                                          ',&
'6. COLLECTIONS OF DOCUMENTS                                               ',&
'                                                                          ',&
'You may make a collection consisting of the Document and other            ',&
'documents released under this License, and replace the individual         ',&
'copies of this License in the various documents with a single copy        ',&
'that is included in the collection, provided that you follow the rules    ',&
'of this License for verbatim copying of each of the documents in all      ',&
'other respects.                                                           ',&
'                                                                          ',&
'You may extract a single document from such a collection, and             ',&
'distribute it individually under this License, provided you insert a      ',&
'copy of this License into the extracted document, and follow this         ',&
'License in all other respects regarding verbatim copying of that          ',&
'document.                                                                 ',&
'                                                                          ',&
'                                                                          ',&
'7. AGGREGATION WITH INDEPENDENT WORKS                                     ',&
'                                                                          ',&
'A compilation of the Document or its derivatives with other separate      ',&
'and independent documents or works, in or on a volume of a storage or     ',&
'distribution medium, is called an "aggregate" if the copyright            ',&
'resulting from the compilation is not used to limit the legal rights      ',&
'of the compilation''s users beyond what the individual works permit.      ',&
'When the Document is included in an aggregate, this License does not      ',&
'apply to the other works in the aggregate which are not themselves        ',&
'derivative works of the Document.                                         ',&
'                                                                          ',&
'If the Cover Text requirement of section 3 is applicable to these         ',&
'copies of the Document, then if the Document is less than one half of     ',&
'the entire aggregate, the Document''s Cover Texts may be placed on        ',&
'covers that bracket the Document within the aggregate, or the             ',&
'electronic equivalent of covers if the Document is in electronic form.    ',&
'Otherwise they must appear on printed covers that bracket the whole       ',&
'aggregate.                                                                ',&
'                                                                          ',&
'                                                                          ',&
'8. TRANSLATION                                                            ',&
'                                                                          ',&
'Translation is considered a kind of modification, so you may              ',&
'distribute translations of the Document under the terms of section 4.     ',&
'Replacing Invariant Sections with translations requires special           ',&
'permission from their copyright holders, but you may include              ',&
'translations of some or all Invariant Sections in addition to the         ',&
'original versions of these Invariant Sections.  You may include a         ',&
'translation of this License, and all the license notices in the           ',&
'Document, and any Warranty Disclaimers, provided that you also include    ',&
'the original English version of this License and the original versions    ',&
'of those notices and disclaimers.  In case of a disagreement between      ',&
'the translation and the original version of this License or a notice      ',&
'or disclaimer, the original version will prevail.                         ',&
'                                                                          ',&
'If a section in the Document is Entitled "Acknowledgements",              ',&
'"Dedications", or "History", the requirement (section 4) to Preserve      ',&
'its Title (section 1) will typically require changing the actual          ',&
'title.                                                                    ',&
'                                                                          ',&
'                                                                          ',&
'9. TERMINATION                                                            ',&
'                                                                          ',&
'You may not copy, modify, sublicense, or distribute the Document          ',&
'except as expressly provided under this License.  Any attempt             ',&
'otherwise to copy, modify, sublicense, or distribute it is void, and      ',&
'will automatically terminate your rights under this License.              ',&
'                                                                          ',&
'However, if you cease all violation of this License, then your license    ',&
'from a particular copyright holder is reinstated (a) provisionally,       ',&
'unless and until the copyright holder explicitly and finally              ',&
'terminates your license, and (b) permanently, if the copyright holder     ',&
'fails to notify you of the violation by some reasonable means prior to    ',&
'60 days after the cessation.                                              ',&
'                                                                          ',&
'Moreover, your license from a particular copyright holder is              ',&
'reinstated permanently if the copyright holder notifies you of the        ',&
'violation by some reasonable means, this is the first time you have       ',&
'received notice of violation of this License (for any work) from that     ',&
'copyright holder, and you cure the violation prior to 30 days after       ',&
'your receipt of the notice.                                               ',&
'                                                                          ',&
'Termination of your rights under this section does not terminate the      ',&
'licenses of parties who have received copies or rights from you under     ',&
'this License.  If your rights have been terminated and not permanently    ',&
'reinstated, receipt of a copy of some or all of the same material does    ',&
'not give you any rights to use it.                                        ',&
'                                                                          ',&
'                                                                          ',&
'10. FUTURE REVISIONS OF THIS LICENSE                                      ',&
'                                                                          ',&
'The Free Software Foundation may publish new, revised versions of the     ',&
'GNU Free Documentation License from time to time.  Such new versions      ',&
'will be similar in spirit to the present version, but may differ in       ',&
'detail to address new problems or concerns.  See                          ',&
'https://www.gnu.org/licenses/.                                            ',&
'                                                                          ',&
'Each version of the License is given a distinguishing version number.     ',&
'If the Document specifies that a particular numbered version of this      ',&
'License "or any later version" applies to it, you have the option of      ',&
'following the terms and conditions either of that specified version or    ',&
'of any later version that has been published (not as a draft) by the      ',&
'Free Software Foundation.  If the Document does not specify a version     ',&
'number of this License, you may choose any version ever published (not    ',&
'as a draft) by the Free Software Foundation.  If the Document             ',&
'specifies that a proxy can decide which future versions of this           ',&
'License can be used, that proxy''s public statement of acceptance of a    ',&
'version permanently authorizes you to choose that version for the         ',&
'Document.                                                                 ',&
'                                                                          ',&
'11. RELICENSING                                                           ',&
'                                                                          ',&
'"Massive Multiauthor Collaboration Site" (or "MMC Site") means any        ',&
'World Wide Web server that publishes copyrightable works and also         ',&
'provides prominent facilities for anybody to edit those works.  A         ',&
'public wiki that anybody can edit is an example of such a server.  A      ',&
'"Massive Multiauthor Collaboration" (or "MMC") contained in the site      ',&
'means any set of copyrightable works thus published on the MMC site.      ',&
'                                                                          ',&
'"CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0         ',&
'license published by Creative Commons Corporation, a not-for-profit       ',&
'corporation with a principal place of business in San Francisco,          ',&
'California, as well as future copyleft versions of that license           ',&
'published by that same organization.                                      ',&
'                                                                          ',&
'"Incorporate" means to publish or republish a Document, in whole or in    ',&
'part, as part of another Document.                                        ',&
'                                                                          ',&
'An MMC is "eligible for relicensing" if it is licensed under this         ',&
'License, and if all works that were first published under this License    ',&
'somewhere other than this MMC, and subsequently incorporated in whole or  ',&
'in part into the MMC, (1) had no cover texts or invariant sections, and   ',&
'(2) were thus incorporated prior to November 1, 2008.                     ',&
'                                                                          ',&
'The operator of an MMC Site may republish an MMC contained in the site    ',&
'under CC-BY-SA on the same site at any time before August 1, 2009,        ',&
'provided the MMC is eligible for relicensing.                             ',&
'                                                                          ',&
'                                                                          ',&
'ADDENDUM: How to use this License for your documents                      ',&
'                                                                          ',&
'To use this License in a document you have written, include a copy of     ',&
'the License in the document and put the following copyright and           ',&
'license notices just after the title page:                                ',&
'                                                                          ',&
'    Copyright (c)  YEAR  YOUR NAME.                                       ',&
'    Permission is granted to copy, distribute and/or modify this document ',&
'    under the terms of the GNU Free Documentation License, Version 1.3    ',&
'    or any later version published by the Free Software Foundation;       ',&
'    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.',&
'    A copy of the license is included in the section entitled "GNU            ',&
'    Free Documentation License".                                              ',&
'                                                                              ',&
'If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,       ',&
'replace the "with...Texts." line with this:                                   ',&
'                                                                              ',&
'    with the Invariant Sections being LIST THEIR TITLES, with the             ',&
'    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.   ',&
'                                                                              ',&
'If you have Invariant Sections without Cover Texts, or some other             ',&
'combination of the three, merge those two alternatives to suit the            ',&
'situation.                                                                    ',&
'                                                                              ',&
'If your document contains nontrivial examples of program code, we             ',&
'recommend releasing these examples in parallel under your choice of           ',&
'free software license, such as the GNU General Public License,                ',&
'to permit their use in free software.                                         ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('26','gpl-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'gpl-2.0',&
'       ',&
'                    GNU GENERAL PUBLIC LICENSE',&
'                       Version 2, June 1991   ',&
'                                              ',&
' Copyright (C) 1989, 1991 Free Software Foundation, Inc.,',&
' 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA',&
' Everyone is permitted to copy and distribute verbatim copies',&
' of this license document, but changing it is not allowed.   ',&
'                                                             ',&
'                            Preamble                         ',&
'                                                             ',&
'  The licenses for most software are designed to take away your',&
'freedom to share and change it.  By contrast, the GNU General Public',&
'License is intended to guarantee your freedom to share and change free',&
'software--to make sure the software is free for all its users.  This  ',&
'General Public License applies to most of the Free Software           ',&
'Foundation''s software and to any other program whose authors commit to',&
'using it.  (Some other Free Software Foundation software is covered by ',&
'the GNU Lesser General Public License instead.)  You can apply it to   ',&
'your programs, too.                                                    ',&
'                                                                       ',&
'  When we speak of free software, we are referring to freedom, not     ',&
'price.  Our General Public Licenses are designed to make sure that you ',&
'have the freedom to distribute copies of free software (and charge for ',&
'this service if you wish), that you receive source code or can get it  ',&
'if you want it, that you can change the software or use pieces of it   ',&
'in new free programs; and that you know you can do these things.       ',&
'                                                                       ',&
'  To protect your rights, we need to make restrictions that forbid     ',&
'anyone to deny you these rights or to ask you to surrender the rights. ',&
'These restrictions translate to certain responsibilities for you if you',&
'distribute copies of the software, or if you modify it.                ',&
'                                                                       ',&
'  For example, if you distribute copies of such a program, whether     ',&
'gratis or for a fee, you must give the recipients all the rights that  ',&
'you have.  You must make sure that they, too, receive or can get the   ',&
'source code.  And you must show them these terms so they know their    ',&
'rights.                                                                ',&
'                                                                       ',&
'  We protect your rights with two steps: (1) copyright the software, and',&
'(2) offer you this license which gives you legal permission to copy,    ',&
'distribute and/or modify the software.                                  ',&
'                                                                        ',&
'  Also, for each author''s protection and ours, we want to make certain ',&
'that everyone understands that there is no warranty for this free       ',&
'software.  If the software is modified by someone else and passed on, we',&
'want its recipients to know that what they have is not the original, so ',&
'that any problems introduced by others will not reflect on the original ',&
'authors'' reputations.                                                  ',&
'                                                                        ',&
'  Finally, any free program is threatened constantly by software        ',&
'patents.  We wish to avoid the danger that redistributors of a free     ',&
'program will individually obtain patent licenses, in effect making the  ',&
'program proprietary.  To prevent this, we have made it clear that any   ',&
'patent must be licensed for everyone''s free use or not licensed at all.',&
'                                                                        ',&
'  The precise terms and conditions for copying, distribution and        ',&
'modification follow.                                                    ',&
'                                                                        ',&
'                    GNU GENERAL PUBLIC LICENSE                          ',&
'   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION      ',&
'                                                                        ',&
'  0. This License applies to any program or other work which contains   ',&
'a notice placed by the copyright holder saying it may be distributed    ',&
'under the terms of this General Public License.  The "Program", below,  ',&
'refers to any such program or work, and a "work based on the Program"   ',&
'means either the Program or any derivative work under copyright law:    ',&
'that is to say, a work containing the Program or a portion of it,       ',&
'either verbatim or with modifications and/or translated into another    ',&
'language.  (Hereinafter, translation is included without limitation in  ',&
'the term "modification".)  Each licensee is addressed as "you".         ',&
'                                                                        ',&
'Activities other than copying, distribution and modification are not    ',&
'covered by this License; they are outside its scope.  The act of        ',&
'running the Program is not restricted, and the output from the Program  ',&
'is covered only if its contents constitute a work based on the          ',&
'Program (independent of having been made by running the Program).       ',&
'Whether that is true depends on what the Program does.                  ',&
'                                                                        ',&
'  1. You may copy and distribute verbatim copies of the Program''s      ',&
'source code as you receive it, in any medium, provided that you         ',&
'conspicuously and appropriately publish on each copy an appropriate     ',&
'copyright notice and disclaimer of warranty; keep intact all the        ',&
'notices that refer to this License and to the absence of any warranty;  ',&
'and give any other recipients of the Program a copy of this License     ',&
'along with the Program.                                                 ',&
'                                                                        ',&
'You may charge a fee for the physical act of transferring a copy, and   ',&
'you may at your option offer warranty protection in exchange for a fee. ',&
'                                                                        ',&
'  2. You may modify your copy or copies of the Program or any portion   ',&
'of it, thus forming a work based on the Program, and copy and           ',&
'distribute such modifications or work under the terms of Section 1      ',&
'above, provided that you also meet all of these conditions:             ',&
'                                                                        ',&
'    a) You must cause the modified files to carry prominent notices     ',&
'    stating that you changed the files and the date of any change.      ',&
'                                                                        ',&
'    b) You must cause any work that you distribute or publish, that in  ',&
'    whole or in part contains or is derived from the Program or any     ',&
'    part thereof, to be licensed as a whole at no charge to all third   ',&
'    parties under the terms of this License.                            ',&
'                                                                        ',&
'    c) If the modified program normally reads commands interactively    ',&
'    when run, you must cause it, when started running for such          ',&
'    interactive use in the most ordinary way, to print or display an    ',&
'    announcement including an appropriate copyright notice and a        ',&
'    notice that there is no warranty (or else, saying that you provide  ',&
'    a warranty) and that users may redistribute the program under       ',&
'    these conditions, and telling the user how to view a copy of this   ',&
'    License.  (Exception: if the Program itself is interactive but      ',&
'    does not normally print such an announcement, your work based on    ',&
'    the Program is not required to print an announcement.)              ',&
'                                                                        ',&
'These requirements apply to the modified work as a whole.  If           ',&
'identifiable sections of that work are not derived from the Program,    ',&
'and can be reasonably considered independent and separate works in      ',&
'themselves, then this License, and its terms, do not apply to those     ',&
'sections when you distribute them as separate works.  But when you      ',&
'distribute the same sections as part of a whole which is a work based   ',&
'on the Program, the distribution of the whole must be on the terms of   ',&
'this License, whose permissions for other licensees extend to the       ',&
'entire whole, and thus to each and every part regardless of who wrote it.',&
'                                                                         ',&
'Thus, it is not the intent of this section to claim rights or contest    ',&
'your rights to work written entirely by you; rather, the intent is to    ',&
'exercise the right to control the distribution of derivative or          ',&
'collective works based on the Program.                                   ',&
'                                                                         ',&
'In addition, mere aggregation of another work not based on the Program   ',&
'with the Program (or with a work based on the Program) on a volume of    ',&
'a storage or distribution medium does not bring the other work under     ',&
'the scope of this License.                                               ',&
'                                                                         ',&
'  3. You may copy and distribute the Program (or a work based on it,     ',&
'under Section 2) in object code or executable form under the terms of    ',&
'Sections 1 and 2 above provided that you also do one of the following:   ',&
'                                                                         ',&
'    a) Accompany it with the complete corresponding machine-readable     ',&
'    source code, which must be distributed under the terms of Sections   ',&
'    1 and 2 above on a medium customarily used for software interchange; or,',&
'                                                                            ',&
'    b) Accompany it with a written offer, valid for at least three          ',&
'    years, to give any third party, for a charge no more than your          ',&
'    cost of physically performing source distribution, a complete           ',&
'    machine-readable copy of the corresponding source code, to be           ',&
'    distributed under the terms of Sections 1 and 2 above on a medium       ',&
'    customarily used for software interchange; or,                          ',&
'                                                                            ',&
'    c) Accompany it with the information you received as to the offer       ',&
'    to distribute corresponding source code.  (This alternative is          ',&
'    allowed only for noncommercial distribution and only if you             ',&
'    received the program in object code or executable form with such        ',&
'    an offer, in accord with Subsection b above.)                           ',&
'                                                                            ',&
'The source code for a work means the preferred form of the work for         ',&
'making modifications to it.  For an executable work, complete source        ',&
'code means all the source code for all modules it contains, plus any        ',&
'associated interface definition files, plus the scripts used to             ',&
'control compilation and installation of the executable.  However, as a      ',&
'special exception, the source code distributed need not include             ',&
'anything that is normally distributed (in either source or binary           ',&
'form) with the major components (compiler, kernel, and so on) of the        ',&
'operating system on which the executable runs, unless that component        ',&
'itself accompanies the executable.                                          ',&
'                                                                            ',&
'If distribution of executable or object code is made by offering            ',&
'access to copy from a designated place, then offering equivalent            ',&
'access to copy the source code from the same place counts as                ',&
'distribution of the source code, even though third parties are not          ',&
'compelled to copy the source along with the object code.                    ',&
'                                                                            ',&
'  4. You may not copy, modify, sublicense, or distribute the Program        ',&
'except as expressly provided under this License.  Any attempt               ',&
'otherwise to copy, modify, sublicense or distribute the Program is          ',&
'void, and will automatically terminate your rights under this License.      ',&
'However, parties who have received copies, or rights, from you under        ',&
'this License will not have their licenses terminated so long as such        ',&
'parties remain in full compliance.                                          ',&
'                                                                            ',&
'  5. You are not required to accept this License, since you have not        ',&
'signed it.  However, nothing else grants you permission to modify or        ',&
'distribute the Program or its derivative works.  These actions are          ',&
'prohibited by law if you do not accept this License.  Therefore, by         ',&
'modifying or distributing the Program (or any work based on the             ',&
'Program), you indicate your acceptance of this License to do so, and        ',&
'all its terms and conditions for copying, distributing or modifying         ',&
'the Program or works based on it.                                           ',&
'                                                                            ',&
'  6. Each time you redistribute the Program (or any work based on the       ',&
'Program), the recipient automatically receives a license from the           ',&
'original licensor to copy, distribute or modify the Program subject to      ',&
'these terms and conditions.  You may not impose any further                 ',&
'restrictions on the recipients'' exercise of the rights granted herein.     ',&
'You are not responsible for enforcing compliance by third parties to        ',&
'this License.                                                               ',&
'                                                                            ',&
'  7. If, as a consequence of a court judgment or allegation of patent       ',&
'infringement or for any other reason (not limited to patent issues),        ',&
'conditions are imposed on you (whether by court order, agreement or         ',&
'otherwise) that contradict the conditions of this License, they do not      ',&
'excuse you from the conditions of this License.  If you cannot              ',&
'distribute so as to satisfy simultaneously your obligations under this      ',&
'License and any other pertinent obligations, then as a consequence you      ',&
'may not distribute the Program at all.  For example, if a patent            ',&
'license would not permit royalty-free redistribution of the Program by      ',&
'all those who receive copies directly or indirectly through you, then       ',&
'the only way you could satisfy both it and this License would be to         ',&
'refrain entirely from distribution of the Program.                          ',&
'                                                                            ',&
'If any portion of this section is held invalid or unenforceable under       ',&
'any particular circumstance, the balance of the section is intended to      ',&
'apply and the section as a whole is intended to apply in other              ',&
'circumstances.                                                              ',&
'                                                                            ',&
'It is not the purpose of this section to induce you to infringe any         ',&
'patents or other property right claims or to contest validity of any        ',&
'such claims; this section has the sole purpose of protecting the            ',&
'integrity of the free software distribution system, which is                ',&
'implemented by public license practices.  Many people have made             ',&
'generous contributions to the wide range of software distributed            ',&
'through that system in reliance on consistent application of that           ',&
'system; it is up to the author/donor to decide if he or she is willing      ',&
'to distribute software through any other system and a licensee cannot       ',&
'impose that choice.                                                         ',&
'                                                                            ',&
'This section is intended to make thoroughly clear what is believed to       ',&
'be a consequence of the rest of this License.                               ',&
'                                                                            ',&
'  8. If the distribution and/or use of the Program is restricted in         ',&
'certain countries either by patents or by copyrighted interfaces, the       ',&
'original copyright holder who places the Program under this License         ',&
'may add an explicit geographical distribution limitation excluding          ',&
'those countries, so that distribution is permitted only in or among         ',&
'countries not thus excluded.  In such case, this License incorporates       ',&
'the limitation as if written in the body of this License.                   ',&
'                                                                            ',&
'  9. The Free Software Foundation may publish revised and/or new versions   ',&
'of the General Public License from time to time.  Such new versions will    ',&
'be similar in spirit to the present version, but may differ in detail to    ',&
'address new problems or concerns.                                           ',&
'                                                                            ',&
'Each version is given a distinguishing version number.  If the Program      ',&
'specifies a version number of this License which applies to it and "any     ',&
'later version", you have the option of following the terms and conditions   ',&
'either of that version or of any later version published by the Free        ',&
'Software Foundation.  If the Program does not specify a version number of   ',&
'this License, you may choose any version ever published by the Free Software',&
'Foundation.                                                                 ',&
'                                                                            ',&
'  10. If you wish to incorporate parts of the Program into other free       ',&
'programs whose distribution conditions are different, write to the author   ',&
'to ask for permission.  For software which is copyrighted by the Free       ',&
'Software Foundation, write to the Free Software Foundation; we sometimes    ',&
'make exceptions for this.  Our decision will be guided by the two goals     ',&
'of preserving the free status of all derivatives of our free software and   ',&
'of promoting the sharing and reuse of software generally.                   ',&
'                                                                            ',&
'                            NO WARRANTY                                     ',&
'                                                                            ',&
'  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY  ',&
'FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN    ',&
'OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES      ',&
'PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED  ',&
'OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF        ',&
'MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS   ',&
'TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE      ',&
'PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,    ',&
'REPAIR OR CORRECTION.                                                       ',&
'                                                                            ',&
'  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING ',&
'WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR         ',&
'REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,  ',&
'INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING ',&
'OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED   ',&
'TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY    ',&
'YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER  ',&
'PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE       ',&
'POSSIBILITY OF SUCH DAMAGES.                                                ',&
'                                                                            ',&
'                     END OF TERMS AND CONDITIONS                            ',&
'                                                                            ',&
'            How to Apply These Terms to Your New Programs                   ',&
'                                                                            ',&
'  If you develop a new program, and you want it to be of the greatest       ',&
'possible use to the public, the best way to achieve this is to make it      ',&
'free software which everyone can redistribute and change under these terms. ',&
'                                                                            ',&
'  To do so, attach the following notices to the program.  It is safest      ',&
'to attach them to the start of each source file to most effectively         ',&
'convey the exclusion of warranty; and each file should have at least        ',&
'the "copyright" line and a pointer to where the full notice is found.       ',&
'                                                                            ',&
'    <one line to give the program''s name and a brief idea of what it does.>',&
'    Copyright (C) @YEAR@  @NAME_OF_AUTHOR@                                  ',&
'                                                                            ',&
'    This program is free software; you can redistribute it and/or modify    ',&
'    it under the terms of the GNU General Public License as published by    ',&
'    the Free Software Foundation; either version 2 of the License, or       ',&
'    (at your option) any later version.                                     ',&
'                                                                            ',&
'    This program is distributed in the hope that it will be useful,         ',&
'    but WITHOUT ANY WARRANTY; without even the implied warranty of          ',&
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           ',&
'    GNU General Public License for more details.                            ',&
'                                                                            ',&
'    You should have received a copy of the GNU General Public License along ',&
'    with this program; if not, write to the Free Software Foundation, Inc., ',&
'    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.             ',&
'                                                                            ',&
'Also add information on how to contact you by electronic and paper mail.    ',&
'                                                                            ',&
'If the program is interactive, make it output a short notice like this      ',&
'when it starts in an interactive mode:                                      ',&
'                                                                            ',&
'    Gnomovision version 69, Copyright (C) year name of author               ',&
'    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w''.',&
'    This is free software, and you are welcome to redistribute it             ',&
'    under certain conditions; type `show c'' for details.                     ',&
'                                                                              ',&
'The hypothetical commands `show w'' and `show c'' should show the appropriate ',&
'parts of the General Public License.  Of course, the commands you use may     ',&
'be called something other than `show w'' and `show c''; they could even be    ',&
'mouse-clicks or menu items--whatever suits your program.                      ',&
'                                                                              ',&
'You should also get your employer (if you work as a programmer) or your       ',&
'school, if any, to sign a "copyright disclaimer" for the program, if          ',&
'necessary.  Here is a sample; alter the names:                                ',&
'                                                                              ',&
'  Yoyodyne, Inc., hereby disclaims all copyright interest in the program      ',&
'  `Gnomovision'' (which makes passes at compilers) written by James Hacker.   ',&
'                                                                              ',&
'  <signature of Ty Coon>, 1 April 1989                                        ',&
'  Ty Coon, President of Vice                                                  ',&
'                                                                              ',&
'This General Public License does not permit incorporating your program into   ',&
'proprietary programs.  If your program is a subroutine library, you may       ',&
'consider it more useful to permit linking proprietary applications with the   ',&
'library.  If this is what you want to do, use the GNU Lesser General          ',&
'Public License instead of this License.                                       ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('27','gpl-3.0')
textblock=[ CHARACTER(LEN=128) :: &
'gpl-3.0',&
'       ',&
'                    GNU GENERAL PUBLIC LICENSE',&
'                       Version 3, 29 June 2007',&
'                                              ',&
' Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>',&
' Everyone is permitted to copy and distribute verbatim copies        ',&
' of this license document, but changing it is not allowed.           ',&
'                                                                     ',&
'                            Preamble                                 ',&
'                                                                     ',&
'  The GNU General Public License is a free, copyleft license for     ',&
'software and other kinds of works.                                   ',&
'                                                                     ',&
'  The licenses for most software and other practical works are designed',&
'to take away your freedom to share and change the works.  By contrast, ',&
'the GNU General Public License is intended to guarantee your freedom to',&
'share and change all versions of a program--to make sure it remains free',&
'software for all its users.  We, the Free Software Foundation, use the  ',&
'GNU General Public License for most of our software; it applies also to ',&
'any other work released this way by its authors.  You can apply it to   ',&
'your programs, too.                                                     ',&
'                                                                        ',&
'  When we speak of free software, we are referring to freedom, not      ',&
'price.  Our General Public Licenses are designed to make sure that you  ',&
'have the freedom to distribute copies of free software (and charge for  ',&
'them if you wish), that you receive source code or can get it if you    ',&
'want it, that you can change the software or use pieces of it in new    ',&
'free programs, and that you know you can do these things.               ',&
'                                                                        ',&
'  To protect your rights, we need to prevent others from denying you    ',&
'these rights or asking you to surrender the rights.  Therefore, you have',&
'certain responsibilities if you distribute copies of the software, or if',&
'you modify it: responsibilities to respect the freedom of others.       ',&
'                                                                        ',&
'  For example, if you distribute copies of such a program, whether      ',&
'gratis or for a fee, you must pass on to the recipients the same        ',&
'freedoms that you received.  You must make sure that they, too, receive ',&
'or can get the source code.  And you must show them these terms so they ',&
'know their rights.                                                      ',&
'                                                                        ',&
'  Developers that use the GNU GPL protect your rights with two steps:   ',&
'(1) assert copyright on the software, and (2) offer you this License    ',&
'giving you legal permission to copy, distribute and/or modify it.       ',&
'                                                                        ',&
'  For the developers'' and authors'' protection, the GPL clearly explains',&
'that there is no warranty for this free software.  For both users'' and  ',&
'authors'' sake, the GPL requires that modified versions be marked as     ',&
'changed, so that their problems will not be attributed erroneously to    ',&
'authors of previous versions.                                            ',&
'                                                                         ',&
'  Some devices are designed to deny users access to install or run       ',&
'modified versions of the software inside them, although the manufacturer ',&
'can do so.  This is fundamentally incompatible with the aim of           ',&
'protecting users'' freedom to change the software.  The systematic       ',&
'pattern of such abuse occurs in the area of products for individuals to  ',&
'use, which is precisely where it is most unacceptable.  Therefore, we    ',&
'have designed this version of the GPL to prohibit the practice for those ',&
'products.  If such problems arise substantially in other domains, we     ',&
'stand ready to extend this provision to those domains in future versions ',&
'of the GPL, as needed to protect the freedom of users.                   ',&
'                                                                         ',&
'  Finally, every program is threatened constantly by software patents.   ',&
'States should not allow patents to restrict development and use of       ',&
'software on general-purpose computers, but in those that do, we wish to  ',&
'avoid the special danger that patents applied to a free program could    ',&
'make it effectively proprietary.  To prevent this, the GPL assures that  ',&
'patents cannot be used to render the program non-free.                   ',&
'                                                                         ',&
'  The precise terms and conditions for copying, distribution and         ',&
'modification follow.                                                     ',&
'                                                                         ',&
'                       TERMS AND CONDITIONS                              ',&
'                                                                         ',&
'  0. Definitions.                                                        ',&
'                                                                         ',&
'  "This License" refers to version 3 of the GNU General Public License.  ',&
'                                                                         ',&
'  "Copyright" also means copyright-like laws that apply to other kinds of',&
'works, such as semiconductor masks.                                      ',&
'                                                                         ',&
'  "The Program" refers to any copyrightable work licensed under this     ',&
'License.  Each licensee is addressed as "you".  "Licensees" and          ',&
'"recipients" may be individuals or organizations.                        ',&
'                                                                         ',&
'  To "modify" a work means to copy from or adapt all or part of the work ',&
'in a fashion requiring copyright permission, other than the making of an ',&
'exact copy.  The resulting work is called a "modified version" of the    ',&
'earlier work or a work "based on" the earlier work.                      ',&
'                                                                         ',&
'  A "covered work" means either the unmodified Program or a work based   ',&
'on the Program.                                                          ',&
'                                                                         ',&
'  To "propagate" a work means to do anything with it that, without       ',&
'permission, would make you directly or secondarily liable for            ',&
'infringement under applicable copyright law, except executing it on a    ',&
'computer or modifying a private copy.  Propagation includes copying,     ',&
'distribution (with or without modification), making available to the     ',&
'public, and in some countries other activities as well.                  ',&
'                                                                         ',&
'  To "convey" a work means any kind of propagation that enables other    ',&
'parties to make or receive copies.  Mere interaction with a user through ',&
'a computer network, with no transfer of a copy, is not conveying.        ',&
'                                                                         ',&
'  An interactive user interface displays "Appropriate Legal Notices"     ',&
'to the extent that it includes a convenient and prominently visible      ',&
'feature that (1) displays an appropriate copyright notice, and (2)       ',&
'tells the user that there is no warranty for the work (except to the     ',&
'extent that warranties are provided), that licensees may convey the      ',&
'work under this License, and how to view a copy of this License.  If     ',&
'the interface presents a list of user commands or options, such as a     ',&
'menu, a prominent item in the list meets this criterion.                 ',&
'                                                                         ',&
'  1. Source Code.                                                        ',&
'                                                                         ',&
'  The "source code" for a work means the preferred form of the work      ',&
'for making modifications to it.  "Object code" means any non-source      ',&
'form of a work.                                                          ',&
'                                                                         ',&
'  A "Standard Interface" means an interface that either is an official   ',&
'standard defined by a recognized standards body, or, in the case of      ',&
'interfaces specified for a particular programming language, one that     ',&
'is widely used among developers working in that language.                ',&
'                                                                         ',&
'  The "System Libraries" of an executable work include anything, other   ',&
'than the work as a whole, that (a) is included in the normal form of     ',&
'packaging a Major Component, but which is not part of that Major         ',&
'Component, and (b) serves only to enable use of the work with that       ',&
'Major Component, or to implement a Standard Interface for which an       ',&
'implementation is available to the public in source code form.  A        ',&
'"Major Component", in this context, means a major essential component    ',&
'(kernel, window system, and so on) of the specific operating system      ',&
'(if any) on which the executable work runs, or a compiler used to        ',&
'produce the work, or an object code interpreter used to run it.          ',&
'                                                                         ',&
'  The "Corresponding Source" for a work in object code form means all    ',&
'the source code needed to generate, install, and (for an executable      ',&
'work) run the object code and to modify the work, including scripts to   ',&
'control those activities.  However, it does not include the work''s      ',&
'System Libraries, or general-purpose tools or generally available free   ',&
'programs which are used unmodified in performing those activities but    ',&
'which are not part of the work.  For example, Corresponding Source       ',&
'includes interface definition files associated with source files for     ',&
'the work, and the source code for shared libraries and dynamically       ',&
'linked subprograms that the work is specifically designed to require,    ',&
'such as by intimate data communication or control flow between those     ',&
'subprograms and other parts of the work.                                 ',&
'                                                                         ',&
'  The Corresponding Source need not include anything that users          ',&
'can regenerate automatically from other parts of the Corresponding       ',&
'Source.                                                                  ',&
'                                                                         ',&
'  The Corresponding Source for a work in source code form is that        ',&
'same work.                                                               ',&
'                                                                         ',&
'  2. Basic Permissions.                                                  ',&
'                                                                         ',&
'  All rights granted under this License are granted for the term of      ',&
'copyright on the Program, and are irrevocable provided the stated        ',&
'conditions are met.  This License explicitly affirms your unlimited      ',&
'permission to run the unmodified Program.  The output from running a     ',&
'covered work is covered by this License only if the output, given its    ',&
'content, constitutes a covered work.  This License acknowledges your     ',&
'rights of fair use or other equivalent, as provided by copyright law.    ',&
'                                                                         ',&
'  You may make, run and propagate covered works that you do not          ',&
'convey, without conditions so long as your license otherwise remains     ',&
'in force.  You may convey covered works to others for the sole purpose   ',&
'of having them make modifications exclusively for you, or provide you    ',&
'with facilities for running those works, provided that you comply with   ',&
'the terms of this License in conveying all material for which you do     ',&
'not control copyright.  Those thus making or running the covered works   ',&
'for you must do so exclusively on your behalf, under your direction      ',&
'and control, on terms that prohibit them from making any copies of       ',&
'your copyrighted material outside their relationship with you.           ',&
'                                                                         ',&
'  Conveying under any other circumstances is permitted solely under      ',&
'the conditions stated below.  Sublicensing is not allowed; section 10    ',&
'makes it unnecessary.                                                    ',&
'                                                                         ',&
'  3. Protecting Users'' Legal Rights From Anti-Circumvention Law.        ',&
'                                                                         ',&
'  No covered work shall be deemed part of an effective technological     ',&
'measure under any applicable law fulfilling obligations under article    ',&
'11 of the WIPO copyright treaty adopted on 20 December 1996, or          ',&
'similar laws prohibiting or restricting circumvention of such            ',&
'measures.                                                                ',&
'                                                                         ',&
'  When you convey a covered work, you waive any legal power to forbid    ',&
'circumvention of technological measures to the extent such circumvention ',&
'is effected by exercising rights under this License with respect to      ',&
'the covered work, and you disclaim any intention to limit operation or   ',&
'modification of the work as a means of enforcing, against the work''s    ',&
'users, your or third parties'' legal rights to forbid circumvention of   ',&
'technological measures.                                                  ',&
'                                                                         ',&
'  4. Conveying Verbatim Copies.                                          ',&
'                                                                         ',&
'  You may convey verbatim copies of the Program''s source code as you    ',&
'receive it, in any medium, provided that you conspicuously and           ',&
'appropriately publish on each copy an appropriate copyright notice;      ',&
'keep intact all notices stating that this License and any                ',&
'non-permissive terms added in accord with section 7 apply to the code;   ',&
'keep intact all notices of the absence of any warranty; and give all     ',&
'recipients a copy of this License along with the Program.                ',&
'                                                                         ',&
'  You may charge any price or no price for each copy that you convey,    ',&
'and you may offer support or warranty protection for a fee.              ',&
'                                                                         ',&
'  5. Conveying Modified Source Versions.                                 ',&
'                                                                         ',&
'  You may convey a work based on the Program, or the modifications to    ',&
'produce it from the Program, in the form of source code under the        ',&
'terms of section 4, provided that you also meet all of these conditions: ',&
'                                                                         ',&
'    a) The work must carry prominent notices stating that you modified   ',&
'    it, and giving a relevant date.                                      ',&
'                                                                         ',&
'    b) The work must carry prominent notices stating that it is          ',&
'    released under this License and any conditions added under section   ',&
'    7.  This requirement modifies the requirement in section 4 to        ',&
'    "keep intact all notices".                                           ',&
'                                                                         ',&
'    c) You must license the entire work, as a whole, under this          ',&
'    License to anyone who comes into possession of a copy.  This         ',&
'    License will therefore apply, along with any applicable section 7    ',&
'    additional terms, to the whole of the work, and all its parts,       ',&
'    regardless of how they are packaged.  This License gives no          ',&
'    permission to license the work in any other way, but it does not     ',&
'    invalidate such permission if you have separately received it.       ',&
'                                                                         ',&
'    d) If the work has interactive user interfaces, each must display    ',&
'    Appropriate Legal Notices; however, if the Program has interactive   ',&
'    interfaces that do not display Appropriate Legal Notices, your       ',&
'    work need not make them do so.                                       ',&
'                                                                         ',&
'  A compilation of a covered work with other separate and independent    ',&
'works, which are not by their nature extensions of the covered work,     ',&
'and which are not combined with it such as to form a larger program,     ',&
'in or on a volume of a storage or distribution medium, is called an      ',&
'"aggregate" if the compilation and its resulting copyright are not       ',&
'used to limit the access or legal rights of the compilation''s users     ',&
'beyond what the individual works permit.  Inclusion of a covered work    ',&
'in an aggregate does not cause this License to apply to the other        ',&
'parts of the aggregate.                                                  ',&
'                                                                         ',&
'  6. Conveying Non-Source Forms.                                         ',&
'                                                                         ',&
'  You may convey a covered work in object code form under the terms      ',&
'of sections 4 and 5, provided that you also convey the                   ',&
'machine-readable Corresponding Source under the terms of this License,   ',&
'in one of these ways:                                                    ',&
'                                                                         ',&
'    a) Convey the object code in, or embodied in, a physical product     ',&
'    (including a physical distribution medium), accompanied by the       ',&
'    Corresponding Source fixed on a durable physical medium              ',&
'    customarily used for software interchange.                           ',&
'                                                                         ',&
'    b) Convey the object code in, or embodied in, a physical product     ',&
'    (including a physical distribution medium), accompanied by a         ',&
'    written offer, valid for at least three years and valid for as       ',&
'    long as you offer spare parts or customer support for that product   ',&
'    model, to give anyone who possesses the object code either (1) a     ',&
'    copy of the Corresponding Source for all the software in the         ',&
'    product that is covered by this License, on a durable physical       ',&
'    medium customarily used for software interchange, for a price no     ',&
'    more than your reasonable cost of physically performing this         ',&
'    conveying of source, or (2) access to copy the                       ',&
'    Corresponding Source from a network server at no charge.             ',&
'                                                                         ',&
'    c) Convey individual copies of the object code with a copy of the    ',&
'    written offer to provide the Corresponding Source.  This             ',&
'    alternative is allowed only occasionally and noncommercially, and    ',&
'    only if you received the object code with such an offer, in accord   ',&
'    with subsection 6b.                                                  ',&
'                                                                         ',&
'    d) Convey the object code by offering access from a designated       ',&
'    place (gratis or for a charge), and offer equivalent access to the   ',&
'    Corresponding Source in the same way through the same place at no    ',&
'    further charge.  You need not require recipients to copy the         ',&
'    Corresponding Source along with the object code.  If the place to    ',&
'    copy the object code is a network server, the Corresponding Source   ',&
'    may be on a different server (operated by you or a third party)      ',&
'    that supports equivalent copying facilities, provided you maintain   ',&
'    clear directions next to the object code saying where to find the    ',&
'    Corresponding Source.  Regardless of what server hosts the           ',&
'    Corresponding Source, you remain obligated to ensure that it is      ',&
'    available for as long as needed to satisfy these requirements.       ',&
'                                                                         ',&
'    e) Convey the object code using peer-to-peer transmission, provided  ',&
'    you inform other peers where the object code and Corresponding       ',&
'    Source of the work are being offered to the general public at no     ',&
'    charge under subsection 6d.                                          ',&
'                                                                         ',&
'  A separable portion of the object code, whose source code is excluded  ',&
'from the Corresponding Source as a System Library, need not be           ',&
'included in conveying the object code work.                              ',&
'                                                                         ',&
'  A "User Product" is either (1) a "consumer product", which means any   ',&
'tangible personal property which is normally used for personal, family,  ',&
'or household purposes, or (2) anything designed or sold for incorporation',&
'into a dwelling.  In determining whether a product is a consumer product,',&
'doubtful cases shall be resolved in favor of coverage.  For a particular ',&
'product received by a particular user, "normally used" refers to a       ',&
'typical or common use of that class of product, regardless of the status ',&
'of the particular user or of the way in which the particular user        ',&
'actually uses, or expects or is expected to use, the product.  A product ',&
'is a consumer product regardless of whether the product has substantial  ',&
'commercial, industrial or non-consumer uses, unless such uses represent  ',&
'the only significant mode of use of the product.                         ',&
'                                                                         ',&
'  "Installation Information" for a User Product means any methods,       ',&
'procedures, authorization keys, or other information required to install ',&
'and execute modified versions of a covered work in that User Product from',&
'a modified version of its Corresponding Source.  The information must    ',&
'suffice to ensure that the continued functioning of the modified object  ',&
'code is in no case prevented or interfered with solely because           ',&
'modification has been made.                                              ',&
'                                                                         ',&
'  If you convey an object code work under this section in, or with, or   ',&
'specifically for use in, a User Product, and the conveying occurs as     ',&
'part of a transaction in which the right of possession and use of the    ',&
'User Product is transferred to the recipient in perpetuity or for a      ',&
'fixed term (regardless of how the transaction is characterized), the     ',&
'Corresponding Source conveyed under this section must be accompanied     ',&
'by the Installation Information.  But this requirement does not apply    ',&
'if neither you nor any third party retains the ability to install        ',&
'modified object code on the User Product (for example, the work has      ',&
'been installed in ROM).                                                  ',&
'                                                                         ',&
'  The requirement to provide Installation Information does not include a ',&
'requirement to continue to provide support service, warranty, or updates ',&
'for a work that has been modified or installed by the recipient, or for  ',&
'the User Product in which it has been modified or installed.  Access to a',&
'network may be denied when the modification itself materially and        ',&
'adversely affects the operation of the network or violates the rules and ',&
'protocols for communication across the network.                          ',&
'                                                                         ',&
'  Corresponding Source conveyed, and Installation Information provided,  ',&
'in accord with this section must be in a format that is publicly         ',&
'documented (and with an implementation available to the public in        ',&
'source code form), and must require no special password or key for       ',&
'unpacking, reading or copying.                                           ',&
'                                                                         ',&
'  7. Additional Terms.                                                   ',&
'                                                                         ',&
'  "Additional permissions" are terms that supplement the terms of this   ',&
'License by making exceptions from one or more of its conditions.         ',&
'Additional permissions that are applicable to the entire Program shall   ',&
'be treated as though they were included in this License, to the extent   ',&
'that they are valid under applicable law.  If additional permissions     ',&
'apply only to part of the Program, that part may be used separately      ',&
'under those permissions, but the entire Program remains governed by      ',&
'this License without regard to the additional permissions.               ',&
'                                                                         ',&
'  When you convey a copy of a covered work, you may at your option       ',&
'remove any additional permissions from that copy, or from any part of    ',&
'it.  (Additional permissions may be written to require their own         ',&
'removal in certain cases when you modify the work.)  You may place       ',&
'additional permissions on material, added by you to a covered work,      ',&
'for which you have or can give appropriate copyright permission.         ',&
'                                                                         ',&
'  Notwithstanding any other provision of this License, for material you  ',&
'add to a covered work, you may (if authorized by the copyright holders of',&
'that material) supplement the terms of this License with terms:          ',&
'                                                                         ',&
'    a) Disclaiming warranty or limiting liability differently from the   ',&
'    terms of sections 15 and 16 of this License; or                      ',&
'                                                                         ',&
'    b) Requiring preservation of specified reasonable legal notices or   ',&
'    author attributions in that material or in the Appropriate Legal     ',&
'    Notices displayed by works containing it; or                         ',&
'                                                                         ',&
'    c) Prohibiting misrepresentation of the origin of that material, or  ',&
'    requiring that modified versions of such material be marked in       ',&
'    reasonable ways as different from the original version; or           ',&
'                                                                         ',&
'    d) Limiting the use for publicity purposes of names of licensors or  ',&
'    authors of the material; or                                          ',&
'                                                                         ',&
'    e) Declining to grant rights under trademark law for use of some     ',&
'    trade names, trademarks, or service marks; or                        ',&
'                                                                         ',&
'    f) Requiring indemnification of licensors and authors of that        ',&
'    material by anyone who conveys the material (or modified versions of ',&
'    it) with contractual assumptions of liability to the recipient, for  ',&
'    any liability that these contractual assumptions directly impose on  ',&
'    those licensors and authors.                                         ',&
'                                                                         ',&
'  All other non-permissive additional terms are considered "further      ',&
'restrictions" within the meaning of section 10.  If the Program as you   ',&
'received it, or any part of it, contains a notice stating that it is     ',&
'governed by this License along with a term that is a further             ',&
'restriction, you may remove that term.  If a license document contains   ',&
'a further restriction but permits relicensing or conveying under this    ',&
'License, you may add to a covered work material governed by the terms    ',&
'of that license document, provided that the further restriction does     ',&
'not survive such relicensing or conveying.                               ',&
'                                                                         ',&
'  If you add terms to a covered work in accord with this section, you    ',&
'must place, in the relevant source files, a statement of the             ',&
'additional terms that apply to those files, or a notice indicating       ',&
'where to find the applicable terms.                                      ',&
'                                                                         ',&
'  Additional terms, permissive or non-permissive, may be stated in the   ',&
'form of a separately written license, or stated as exceptions;           ',&
'the above requirements apply either way.                                 ',&
'                                                                         ',&
'  8. Termination.                                                        ',&
'                                                                         ',&
'  You may not propagate or modify a covered work except as expressly     ',&
'provided under this License.  Any attempt otherwise to propagate or      ',&
'modify it is void, and will automatically terminate your rights under    ',&
'this License (including any patent licenses granted under the third      ',&
'paragraph of section 11).                                                ',&
'                                                                         ',&
'  However, if you cease all violation of this License, then your         ',&
'license from a particular copyright holder is reinstated (a)             ',&
'provisionally, unless and until the copyright holder explicitly and      ',&
'finally terminates your license, and (b) permanently, if the copyright   ',&
'holder fails to notify you of the violation by some reasonable means     ',&
'prior to 60 days after the cessation.                                    ',&
'                                                                         ',&
'  Moreover, your license from a particular copyright holder is           ',&
'reinstated permanently if the copyright holder notifies you of the       ',&
'violation by some reasonable means, this is the first time you have      ',&
'received notice of violation of this License (for any work) from that    ',&
'copyright holder, and you cure the violation prior to 30 days after      ',&
'your receipt of the notice.                                              ',&
'                                                                         ',&
'  Termination of your rights under this section does not terminate the   ',&
'licenses of parties who have received copies or rights from you under    ',&
'this License.  If your rights have been terminated and not permanently   ',&
'reinstated, you do not qualify to receive new licenses for the same      ',&
'material under section 10.                                               ',&
'                                                                         ',&
'  9. Acceptance Not Required for Having Copies.                          ',&
'                                                                         ',&
'  You are not required to accept this License in order to receive or     ',&
'run a copy of the Program.  Ancillary propagation of a covered work      ',&
'occurring solely as a consequence of using peer-to-peer transmission     ',&
'to receive a copy likewise does not require acceptance.  However,        ',&
'nothing other than this License grants you permission to propagate or    ',&
'modify any covered work.  These actions infringe copyright if you do     ',&
'not accept this License.  Therefore, by modifying or propagating a       ',&
'covered work, you indicate your acceptance of this License to do so.     ',&
'                                                                         ',&
'  10. Automatic Licensing of Downstream Recipients.                      ',&
'                                                                         ',&
'  Each time you convey a covered work, the recipient automatically       ',&
'receives a license from the original licensors, to run, modify and       ',&
'propagate that work, subject to this License.  You are not responsible   ',&
'for enforcing compliance by third parties with this License.             ',&
'                                                                         ',&
'  An "entity transaction" is a transaction transferring control of an    ',&
'organization, or substantially all assets of one, or subdividing an      ',&
'organization, or merging organizations.  If propagation of a covered     ',&
'work results from an entity transaction, each party to that              ',&
'transaction who receives a copy of the work also receives whatever       ',&
'licenses to the work the party''s predecessor in interest had or could   ',&
'give under the previous paragraph, plus a right to possession of the     ',&
'Corresponding Source of the work from the predecessor in interest, if    ',&
'the predecessor has it or can get it with reasonable efforts.            ',&
'                                                                         ',&
'  You may not impose any further restrictions on the exercise of the     ',&
'rights granted or affirmed under this License.  For example, you may     ',&
'not impose a license fee, royalty, or other charge for exercise of       ',&
'rights granted under this License, and you may not initiate litigation   ',&
'(including a cross-claim or counterclaim in a lawsuit) alleging that     ',&
'any patent claim is infringed by making, using, selling, offering for    ',&
'sale, or importing the Program or any portion of it.                     ',&
'                                                                         ',&
'  11. Patents.                                                           ',&
'                                                                         ',&
'  A "contributor" is a copyright holder who authorizes use under this    ',&
'License of the Program or a work on which the Program is based.  The     ',&
'work thus licensed is called the contributor''s "contributor version".   ',&
'                                                                         ',&
'  A contributor''s "essential patent claims" are all patent claims       ',&
'owned or controlled by the contributor, whether already acquired or      ',&
'hereafter acquired, that would be infringed by some manner, permitted    ',&
'by this License, of making, using, or selling its contributor version,   ',&
'but do not include claims that would be infringed only as a              ',&
'consequence of further modification of the contributor version.  For     ',&
'purposes of this definition, "control" includes the right to grant       ',&
'patent sublicenses in a manner consistent with the requirements of       ',&
'this License.                                                            ',&
'                                                                         ',&
'  Each contributor grants you a non-exclusive, worldwide, royalty-free   ',&
'patent license under the contributor''s essential patent claims, to      ',&
'make, use, sell, offer for sale, import and otherwise run, modify and    ',&
'propagate the contents of its contributor version.                       ',&
'                                                                         ',&
'  In the following three paragraphs, a "patent license" is any express   ',&
'agreement or commitment, however denominated, not to enforce a patent    ',&
'(such as an express permission to practice a patent or covenant not to   ',&
'sue for patent infringement).  To "grant" such a patent license to a     ',&
'party means to make such an agreement or commitment not to enforce a     ',&
'patent against the party.                                                ',&
'                                                                         ',&
'  If you convey a covered work, knowingly relying on a patent license,   ',&
'and the Corresponding Source of the work is not available for anyone     ',&
'to copy, free of charge and under the terms of this License, through a   ',&
'publicly available network server or other readily accessible means,     ',&
'then you must either (1) cause the Corresponding Source to be so         ',&
'available, or (2) arrange to deprive yourself of the benefit of the      ',&
'patent license for this particular work, or (3) arrange, in a manner     ',&
'consistent with the requirements of this License, to extend the patent   ',&
'license to downstream recipients.  "Knowingly relying" means you have    ',&
'actual knowledge that, but for the patent license, your conveying the    ',&
'covered work in a country, or your recipient''s use of the covered work  ',&
'in a country, would infringe one or more identifiable patents in that    ',&
'country that you have reason to believe are valid.                       ',&
'                                                                         ',&
'  If, pursuant to or in connection with a single transaction or          ',&
'arrangement, you convey, or propagate by procuring conveyance of, a      ',&
'covered work, and grant a patent license to some of the parties          ',&
'receiving the covered work authorizing them to use, propagate, modify    ',&
'or convey a specific copy of the covered work, then the patent license   ',&
'you grant is automatically extended to all recipients of the covered     ',&
'work and works based on it.                                              ',&
'                                                                         ',&
'  A patent license is "discriminatory" if it does not include within     ',&
'the scope of its coverage, prohibits the exercise of, or is              ',&
'conditioned on the non-exercise of one or more of the rights that are    ',&
'specifically granted under this License.  You may not convey a covered   ',&
'work if you are a party to an arrangement with a third party that is     ',&
'in the business of distributing software, under which you make payment   ',&
'to the third party based on the extent of your activity of conveying     ',&
'the work, and under which the third party grants, to any of the          ',&
'parties who would receive the covered work from you, a discriminatory    ',&
'patent license (a) in connection with copies of the covered work         ',&
'conveyed by you (or copies made from those copies), or (b) primarily     ',&
'for and in connection with specific products or compilations that        ',&
'contain the covered work, unless you entered into that arrangement,      ',&
'or that patent license was granted, prior to 28 March 2007.              ',&
'                                                                         ',&
'  Nothing in this License shall be construed as excluding or limiting    ',&
'any implied license or other defenses to infringement that may           ',&
'otherwise be available to you under applicable patent law.               ',&
'                                                                         ',&
'  12. No Surrender of Others'' Freedom.                                  ',&
'                                                                         ',&
'  If conditions are imposed on you (whether by court order, agreement or ',&
'otherwise) that contradict the conditions of this License, they do not   ',&
'excuse you from the conditions of this License.  If you cannot convey a  ',&
'covered work so as to satisfy simultaneously your obligations under this ',&
'License and any other pertinent obligations, then as a consequence you may',&
'not convey it at all.  For example, if you agree to terms that obligate you',&
'to collect a royalty for further conveying from those to whom you convey   ',&
'the Program, the only way you could satisfy both those terms and this      ',&
'License would be to refrain entirely from conveying the Program.           ',&
'                                                                           ',&
'  13. Use with the GNU Affero General Public License.                      ',&
'                                                                           ',&
'  Notwithstanding any other provision of this License, you have            ',&
'permission to link or combine any covered work with a work licensed        ',&
'under version 3 of the GNU Affero General Public License into a single     ',&
'combined work, and to convey the resulting work.  The terms of this        ',&
'License will continue to apply to the part which is the covered work,      ',&
'but the special requirements of the GNU Affero General Public License,     ',&
'section 13, concerning interaction through a network will apply to the     ',&
'combination as such.                                                       ',&
'                                                                           ',&
'  14. Revised Versions of this License.                                    ',&
'                                                                           ',&
'  The Free Software Foundation may publish revised and/or new versions of  ',&
'the GNU General Public License from time to time.  Such new versions will  ',&
'be similar in spirit to the present version, but may differ in detail to   ',&
'address new problems or concerns.                                          ',&
'                                                                           ',&
'  Each version is given a distinguishing version number.  If the           ',&
'Program specifies that a certain numbered version of the GNU General       ',&
'Public License "or any later version" applies to it, you have the          ',&
'option of following the terms and conditions either of that numbered       ',&
'version or of any later version published by the Free Software             ',&
'Foundation.  If the Program does not specify a version number of the       ',&
'GNU General Public License, you may choose any version ever published      ',&
'by the Free Software Foundation.                                           ',&
'                                                                           ',&
'  If the Program specifies that a proxy can decide which future            ',&
'versions of the GNU General Public License can be used, that proxy''s      ',&
'public statement of acceptance of a version permanently authorizes you     ',&
'to choose that version for the Program.                                    ',&
'                                                                           ',&
'  Later license versions may give you additional or different              ',&
'permissions.  However, no additional obligations are imposed on any        ',&
'author or copyright holder as a result of your choosing to follow a        ',&
'later version.                                                             ',&
'                                                                           ',&
'  15. Disclaimer of Warranty.                                              ',&
'                                                                           ',&
'  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY         ',&
'APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT     ',&
'HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY  ',&
'OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,   ',&
'THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     ',&
'PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM ',&
'IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF   ',&
'ALL NECESSARY SERVICING, REPAIR OR CORRECTION.                             ',&
'                                                                           ',&
'  16. Limitation of Liability.                                             ',&
'                                                                           ',&
'  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING    ',&
'WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS  ',&
'THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY',&
'GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE   ',&
'USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF  ',&
'DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD ',&
'PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),   ',&
'EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF  ',&
'SUCH DAMAGES.                                                              ',&
'                                                                           ',&
'  17. Interpretation of Sections 15 and 16.                                ',&
'                                                                           ',&
'  If the disclaimer of warranty and limitation of liability provided       ',&
'above cannot be given local legal effect according to their terms,         ',&
'reviewing courts shall apply local law that most closely approximates      ',&
'an absolute waiver of all civil liability in connection with the           ',&
'Program, unless a warranty or assumption of liability accompanies a        ',&
'copy of the Program in return for a fee.                                   ',&
'                                                                           ',&
'                     END OF TERMS AND CONDITIONS                           ',&
'                                                                           ',&
'            How to Apply These Terms to Your New Programs                  ',&
'                                                                           ',&
'  If you develop a new program, and you want it to be of the greatest      ',&
'possible use to the public, the best way to achieve this is to make it     ',&
'free software which everyone can redistribute and change under these terms.',&
'                                                                           ',&
'  To do so, attach the following notices to the program.  It is safest     ',&
'to attach them to the start of each source file to most effectively        ',&
'state the exclusion of warranty; and each file should have at least        ',&
'the "copyright" line and a pointer to where the full notice is found.      ',&
'                                                                           ',&
'    <one line to give the program''s name and a brief idea of what it does.>',&
'    Copyright (C) @YEAR@  @NAME_OF_AUTHOR@                                  ',&
'                                                                            ',&
'    This program is free software: you can redistribute it and/or modify    ',&
'    it under the terms of the GNU General Public License as published by    ',&
'    the Free Software Foundation, either version 3 of the License, or       ',&
'    (at your option) any later version.                                     ',&
'                                                                            ',&
'    This program is distributed in the hope that it will be useful,         ',&
'    but WITHOUT ANY WARRANTY; without even the implied warranty of          ',&
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           ',&
'    GNU General Public License for more details.                            ',&
'                                                                            ',&
'    You should have received a copy of the GNU General Public License       ',&
'    along with this program.  If not, see <https://www.gnu.org/licenses/>.  ',&
'                                                                            ',&
'Also add information on how to contact you by electronic and paper mail.    ',&
'                                                                            ',&
'  If the program does terminal interaction, make it output a short          ',&
'notice like this when it starts in an interactive mode:                     ',&
'                                                                            ',&
'    <program>  Copyright (C) @YEAR@  @NAME_OF_AUTHOR@                       ',&
'    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w''.',&
'    This is free software, and you are welcome to redistribute it              ',&
'    under certain conditions; type `show c'' for details.                      ',&
'                                                                               ',&
'The hypothetical commands `show w'' and `show c'' should show the appropriate  ',&
'parts of the General Public License.  Of course, your program''s commands      ',&
'might be different; for a GUI interface, you would use an "about box".         ',&
'                                                                               ',&
'  You should also get your employer (if you work as a programmer) or school,   ',&
'if any, to sign a "copyright disclaimer" for the program, if necessary.        ',&
'For more information on this, and how to apply and follow the GNU GPL, see     ',&
'<https://www.gnu.org/licenses/>.                                               ',&
'                                                                               ',&
'  The GNU General Public License does not permit incorporating your program    ',&
'into proprietary programs.  If your program is a subroutine library, you       ',&
'may consider it more useful to permit linking proprietary applications with    ',&
'the library.  If this is what you want to do, use the GNU Lesser General       ',&
'Public License instead of this License.  But first, please read                ',&
'<https://www.gnu.org/licenses/why-not-lgpl.html>.                              ',&
'                                                                               ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('28','isc')
textblock=[ CHARACTER(LEN=128) :: &
'isc',&
'   ',&
'ISC License',&
'           ',&
'Copyright (c) @YEAR@ @FULLNAME@',&
'                               ',&
'Permission to use, copy, modify, and/or distribute this software for any',&
'purpose with or without fee is hereby granted, provided that the above  ',&
'copyright notice and this permission notice appear in all copies.       ',&
'                                                                        ',&
'THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH',&
'REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  ',&
'AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, ',&
'INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  ',&
'LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR',&
'OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR       ',&
'PERFORMANCE OF THIS SOFTWARE.                                                ',&
'                                                                             ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('29','lgpl-2.1')
textblock=[ CHARACTER(LEN=128) :: &
'lgpl-2.1',&
'        ',&
'                  GNU LESSER GENERAL PUBLIC LICENSE',&
'                       Version 2.1, February 1999  ',&
'                                                   ',&
' Copyright (C) 1991, 1999 Free Software Foundation, Inc.',&
' 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA',&
' Everyone is permitted to copy and distribute verbatim copies',&
' of this license document, but changing it is not allowed.   ',&
'                                                             ',&
'[This is the first released version of the Lesser GPL.  It also counts',&
' as the successor of the GNU Library Public License, version 2, hence ',&
' the version number 2.1.]                                             ',&
'                                                                      ',&
'                            Preamble                                  ',&
'                                                                      ',&
'  The licenses for most software are designed to take away your       ',&
'freedom to share and change it.  By contrast, the GNU General Public  ',&
'Licenses are intended to guarantee your freedom to share and change   ',&
'free software--to make sure the software is free for all its users.   ',&
'                                                                      ',&
'  This license, the Lesser General Public License, applies to some    ',&
'specially designated software packages--typically libraries--of the   ',&
'Free Software Foundation and other authors who decide to use it.  You ',&
'can use it too, but we suggest you first think carefully about whether',&
'this license or the ordinary General Public License is the better     ',&
'strategy to use in any particular case, based on the explanations below.',&
'                                                                        ',&
'  When we speak of free software, we are referring to freedom of use,   ',&
'not price.  Our General Public Licenses are designed to make sure that  ',&
'you have the freedom to distribute copies of free software (and charge  ',&
'for this service if you wish); that you receive source code or can get  ',&
'it if you want it; that you can change the software and use pieces of   ',&
'it in new free programs; and that you are informed that you can do      ',&
'these things.                                                           ',&
'                                                                        ',&
'  To protect your rights, we need to make restrictions that forbid      ',&
'distributors to deny you these rights or to ask you to surrender these  ',&
'rights.  These restrictions translate to certain responsibilities for   ',&
'you if you distribute copies of the library or if you modify it.        ',&
'                                                                        ',&
'  For example, if you distribute copies of the library, whether gratis  ',&
'or for a fee, you must give the recipients all the rights that we gave  ',&
'you.  You must make sure that they, too, receive or can get the source  ',&
'code.  If you link other code with the library, you must provide        ',&
'complete object files to the recipients, so that they can relink them   ',&
'with the library after making changes to the library and recompiling    ',&
'it.  And you must show them these terms so they know their rights.      ',&
'                                                                        ',&
'  We protect your rights with a two-step method: (1) we copyright the   ',&
'library, and (2) we offer you this license, which gives you legal       ',&
'permission to copy, distribute and/or modify the library.               ',&
'                                                                        ',&
'  To protect each distributor, we want to make it very clear that       ',&
'there is no warranty for the free library.  Also, if the library is     ',&
'modified by someone else and passed on, the recipients should know      ',&
'that what they have is not the original version, so that the original   ',&
'author''s reputation will not be affected by problems that might be     ',&
'introduced by others.                                                   ',&
'                                                                        ',&
'  Finally, software patents pose a constant threat to the existence of  ',&
'any free program.  We wish to make sure that a company cannot           ',&
'effectively restrict the users of a free program by obtaining a         ',&
'restrictive license from a patent holder.  Therefore, we insist that    ',&
'any patent license obtained for a version of the library must be        ',&
'consistent with the full freedom of use specified in this license.      ',&
'                                                                        ',&
'  Most GNU software, including some libraries, is covered by the        ',&
'ordinary GNU General Public License.  This license, the GNU Lesser      ',&
'General Public License, applies to certain designated libraries, and    ',&
'is quite different from the ordinary General Public License.  We use    ',&
'this license for certain libraries in order to permit linking those     ',&
'libraries into non-free programs.                                       ',&
'                                                                        ',&
'  When a program is linked with a library, whether statically or using  ',&
'a shared library, the combination of the two is legally speaking a      ',&
'combined work, a derivative of the original library.  The ordinary      ',&
'General Public License therefore permits such linking only if the       ',&
'entire combination fits its criteria of freedom.  The Lesser General    ',&
'Public License permits more lax criteria for linking other code with    ',&
'the library.                                                            ',&
'                                                                        ',&
'  We call this license the "Lesser" General Public License because it   ',&
'does Less to protect the user''s freedom than the ordinary General      ',&
'Public License.  It also provides other free software developers Less   ',&
'of an advantage over competing non-free programs.  These disadvantages  ',&
'are the reason we use the ordinary General Public License for many      ',&
'libraries.  However, the Lesser license provides advantages in certain  ',&
'special circumstances.                                                  ',&
'                                                                        ',&
'  For example, on rare occasions, there may be a special need to        ',&
'encourage the widest possible use of a certain library, so that it becomes',&
'a de-facto standard.  To achieve this, non-free programs must be          ',&
'allowed to use the library.  A more frequent case is that a free          ',&
'library does the same job as widely used non-free libraries.  In this     ',&
'case, there is little to gain by limiting the free library to free        ',&
'software only, so we use the Lesser General Public License.               ',&
'                                                                          ',&
'  In other cases, permission to use a particular library in non-free      ',&
'programs enables a greater number of people to use a large body of        ',&
'free software.  For example, permission to use the GNU C Library in       ',&
'non-free programs enables many more people to use the whole GNU           ',&
'operating system, as well as its variant, the GNU/Linux operating         ',&
'system.                                                                   ',&
'                                                                          ',&
'  Although the Lesser General Public License is Less protective of the    ',&
'users'' freedom, it does ensure that the user of a program that is        ',&
'linked with the Library has the freedom and the wherewithal to run        ',&
'that program using a modified version of the Library.                     ',&
'                                                                          ',&
'  The precise terms and conditions for copying, distribution and          ',&
'modification follow.  Pay close attention to the difference between a     ',&
'"work based on the library" and a "work that uses the library".  The      ',&
'former contains code derived from the library, whereas the latter must    ',&
'be combined with the library in order to run.                             ',&
'                                                                          ',&
'                  GNU LESSER GENERAL PUBLIC LICENSE                       ',&
'   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION        ',&
'                                                                          ',&
'  0. This License Agreement applies to any software library or other      ',&
'program which contains a notice placed by the copyright holder or         ',&
'other authorized party saying it may be distributed under the terms of    ',&
'this Lesser General Public License (also called "this License").          ',&
'Each licensee is addressed as "you".                                      ',&
'                                                                          ',&
'  A "library" means a collection of software functions and/or data        ',&
'prepared so as to be conveniently linked with application programs        ',&
'(which use some of those functions and data) to form executables.         ',&
'                                                                          ',&
'  The "Library", below, refers to any such software library or work       ',&
'which has been distributed under these terms.  A "work based on the       ',&
'Library" means either the Library or any derivative work under            ',&
'copyright law: that is to say, a work containing the Library or a         ',&
'portion of it, either verbatim or with modifications and/or translated    ',&
'straightforwardly into another language.  (Hereinafter, translation is    ',&
'included without limitation in the term "modification".)                  ',&
'                                                                          ',&
'  "Source code" for a work means the preferred form of the work for       ',&
'making modifications to it.  For a library, complete source code means    ',&
'all the source code for all modules it contains, plus any associated      ',&
'interface definition files, plus the scripts used to control compilation  ',&
'and installation of the library.                                          ',&
'                                                                          ',&
'  Activities other than copying, distribution and modification are not    ',&
'covered by this License; they are outside its scope.  The act of          ',&
'running a program using the Library is not restricted, and output from    ',&
'such a program is covered only if its contents constitute a work based    ',&
'on the Library (independent of the use of the Library in a tool for       ',&
'writing it).  Whether that is true depends on what the Library does       ',&
'and what the program that uses the Library does.                          ',&
'                                                                          ',&
'  1. You may copy and distribute verbatim copies of the Library''s        ',&
'complete source code as you receive it, in any medium, provided that      ',&
'you conspicuously and appropriately publish on each copy an               ',&
'appropriate copyright notice and disclaimer of warranty; keep intact      ',&
'all the notices that refer to this License and to the absence of any      ',&
'warranty; and distribute a copy of this License along with the            ',&
'Library.                                                                  ',&
'                                                                          ',&
'  You may charge a fee for the physical act of transferring a copy,       ',&
'and you may at your option offer warranty protection in exchange for a    ',&
'fee.                                                                      ',&
'                                                                          ',&
'  2. You may modify your copy or copies of the Library or any portion     ',&
'of it, thus forming a work based on the Library, and copy and             ',&
'distribute such modifications or work under the terms of Section 1        ',&
'above, provided that you also meet all of these conditions:               ',&
'                                                                          ',&
'    a) The modified work must itself be a software library.               ',&
'                                                                          ',&
'    b) You must cause the files modified to carry prominent notices       ',&
'    stating that you changed the files and the date of any change.        ',&
'                                                                          ',&
'    c) You must cause the whole of the work to be licensed at no          ',&
'    charge to all third parties under the terms of this License.          ',&
'                                                                          ',&
'    d) If a facility in the modified Library refers to a function or a    ',&
'    table of data to be supplied by an application program that uses      ',&
'    the facility, other than as an argument passed when the facility      ',&
'    is invoked, then you must make a good faith effort to ensure that,    ',&
'    in the event an application does not supply such function or          ',&
'    table, the facility still operates, and performs whatever part of     ',&
'    its purpose remains meaningful.                                       ',&
'                                                                          ',&
'    (For example, a function in a library to compute square roots has     ',&
'    a purpose that is entirely well-defined independent of the            ',&
'    application.  Therefore, Subsection 2d requires that any              ',&
'    application-supplied function or table used by this function must     ',&
'    be optional: if the application does not supply it, the square        ',&
'    root function must still compute square roots.)                       ',&
'                                                                          ',&
'These requirements apply to the modified work as a whole.  If             ',&
'identifiable sections of that work are not derived from the Library,      ',&
'and can be reasonably considered independent and separate works in        ',&
'themselves, then this License, and its terms, do not apply to those       ',&
'sections when you distribute them as separate works.  But when you        ',&
'distribute the same sections as part of a whole which is a work based     ',&
'on the Library, the distribution of the whole must be on the terms of     ',&
'this License, whose permissions for other licensees extend to the         ',&
'entire whole, and thus to each and every part regardless of who wrote     ',&
'it.                                                                       ',&
'                                                                          ',&
'Thus, it is not the intent of this section to claim rights or contest     ',&
'your rights to work written entirely by you; rather, the intent is to     ',&
'exercise the right to control the distribution of derivative or           ',&
'collective works based on the Library.                                    ',&
'                                                                          ',&
'In addition, mere aggregation of another work not based on the Library    ',&
'with the Library (or with a work based on the Library) on a volume of     ',&
'a storage or distribution medium does not bring the other work under      ',&
'the scope of this License.                                                ',&
'                                                                          ',&
'  3. You may opt to apply the terms of the ordinary GNU General Public    ',&
'License instead of this License to a given copy of the Library.  To do    ',&
'this, you must alter all the notices that refer to this License, so       ',&
'that they refer to the ordinary GNU General Public License, version 2,    ',&
'instead of to this License.  (If a newer version than version 2 of the    ',&
'ordinary GNU General Public License has appeared, then you can specify    ',&
'that version instead if you wish.)  Do not make any other change in       ',&
'these notices.                                                            ',&
'                                                                          ',&
'  Once this change is made in a given copy, it is irreversible for        ',&
'that copy, so the ordinary GNU General Public License applies to all      ',&
'subsequent copies and derivative works made from that copy.               ',&
'                                                                          ',&
'  This option is useful when you wish to copy part of the code of         ',&
'the Library into a program that is not a library.                         ',&
'                                                                          ',&
'  4. You may copy and distribute the Library (or a portion or             ',&
'derivative of it, under Section 2) in object code or executable form      ',&
'under the terms of Sections 1 and 2 above provided that you accompany     ',&
'it with the complete corresponding machine-readable source code, which    ',&
'must be distributed under the terms of Sections 1 and 2 above on a        ',&
'medium customarily used for software interchange.                         ',&
'                                                                          ',&
'  If distribution of object code is made by offering access to copy       ',&
'from a designated place, then offering equivalent access to copy the      ',&
'source code from the same place satisfies the requirement to              ',&
'distribute the source code, even though third parties are not             ',&
'compelled to copy the source along with the object code.                  ',&
'                                                                          ',&
'  5. A program that contains no derivative of any portion of the          ',&
'Library, but is designed to work with the Library by being compiled or    ',&
'linked with it, is called a "work that uses the Library".  Such a         ',&
'work, in isolation, is not a derivative work of the Library, and          ',&
'therefore falls outside the scope of this License.                        ',&
'                                                                          ',&
'  However, linking a "work that uses the Library" with the Library        ',&
'creates an executable that is a derivative of the Library (because it     ',&
'contains portions of the Library), rather than a "work that uses the      ',&
'library".  The executable is therefore covered by this License.           ',&
'Section 6 states terms for distribution of such executables.              ',&
'                                                                          ',&
'  When a "work that uses the Library" uses material from a header file    ',&
'that is part of the Library, the object code for the work may be a        ',&
'derivative work of the Library even though the source code is not.        ',&
'Whether this is true is especially significant if the work can be         ',&
'linked without the Library, or if the work is itself a library.  The      ',&
'threshold for this to be true is not precisely defined by law.            ',&
'                                                                          ',&
'  If such an object file uses only numerical parameters, data             ',&
'structure layouts and accessors, and small macros and small inline        ',&
'functions (ten lines or less in length), then the use of the object       ',&
'file is unrestricted, regardless of whether it is legally a derivative    ',&
'work.  (Executables containing this object code plus portions of the      ',&
'Library will still fall under Section 6.)                                 ',&
'                                                                          ',&
'  Otherwise, if the work is a derivative of the Library, you may          ',&
'distribute the object code for the work under the terms of Section 6.     ',&
'Any executables containing that work also fall under Section 6,           ',&
'whether or not they are linked directly with the Library itself.          ',&
'                                                                          ',&
'  6. As an exception to the Sections above, you may also combine or       ',&
'link a "work that uses the Library" with the Library to produce a         ',&
'work containing portions of the Library, and distribute that work         ',&
'under terms of your choice, provided that the terms permit                ',&
'modification of the work for the customer''s own use and reverse          ',&
'engineering for debugging such modifications.                             ',&
'                                                                          ',&
'  You must give prominent notice with each copy of the work that the      ',&
'Library is used in it and that the Library and its use are covered by     ',&
'this License.  You must supply a copy of this License.  If the work       ',&
'during execution displays copyright notices, you must include the         ',&
'copyright notice for the Library among them, as well as a reference       ',&
'directing the user to the copy of this License.  Also, you must do one    ',&
'of these things:                                                          ',&
'                                                                          ',&
'    a) Accompany the work with the complete corresponding                 ',&
'    machine-readable source code for the Library including whatever       ',&
'    changes were used in the work (which must be distributed under        ',&
'    Sections 1 and 2 above); and, if the work is an executable linked     ',&
'    with the Library, with the complete machine-readable "work that       ',&
'    uses the Library", as object code and/or source code, so that the     ',&
'    user can modify the Library and then relink to produce a modified     ',&
'    executable containing the modified Library.  (It is understood        ',&
'    that the user who changes the contents of definitions files in the    ',&
'    Library will not necessarily be able to recompile the application     ',&
'    to use the modified definitions.)                                     ',&
'                                                                          ',&
'    b) Use a suitable shared library mechanism for linking with the       ',&
'    Library.  A suitable mechanism is one that (1) uses at run time a     ',&
'    copy of the library already present on the user''s computer system,   ',&
'    rather than copying library functions into the executable, and (2)    ',&
'    will operate properly with a modified version of the library, if      ',&
'    the user installs one, as long as the modified version is             ',&
'    interface-compatible with the version that the work was made with.    ',&
'                                                                          ',&
'    c) Accompany the work with a written offer, valid for at              ',&
'    least three years, to give the same user the materials                ',&
'    specified in Subsection 6a, above, for a charge no more               ',&
'    than the cost of performing this distribution.                        ',&
'                                                                          ',&
'    d) If distribution of the work is made by offering access to copy     ',&
'    from a designated place, offer equivalent access to copy the above    ',&
'    specified materials from the same place.                              ',&
'                                                                          ',&
'    e) Verify that the user has already received a copy of these          ',&
'    materials or that you have already sent this user a copy.             ',&
'                                                                          ',&
'  For an executable, the required form of the "work that uses the         ',&
'Library" must include any data and utility programs needed for            ',&
'reproducing the executable from it.  However, as a special exception,     ',&
'the materials to be distributed need not include anything that is         ',&
'normally distributed (in either source or binary form) with the major     ',&
'components (compiler, kernel, and so on) of the operating system on       ',&
'which the executable runs, unless that component itself accompanies       ',&
'the executable.                                                           ',&
'                                                                          ',&
'  It may happen that this requirement contradicts the license             ',&
'restrictions of other proprietary libraries that do not normally          ',&
'accompany the operating system.  Such a contradiction means you cannot    ',&
'use both them and the Library together in an executable that you          ',&
'distribute.                                                               ',&
'                                                                          ',&
'  7. You may place library facilities that are a work based on the        ',&
'Library side-by-side in a single library together with other library      ',&
'facilities not covered by this License, and distribute such a combined    ',&
'library, provided that the separate distribution of the work based on     ',&
'the Library and of the other library facilities is otherwise              ',&
'permitted, and provided that you do these two things:                     ',&
'                                                                          ',&
'    a) Accompany the combined library with a copy of the same work        ',&
'    based on the Library, uncombined with any other library               ',&
'    facilities.  This must be distributed under the terms of the          ',&
'    Sections above.                                                       ',&
'                                                                          ',&
'    b) Give prominent notice with the combined library of the fact        ',&
'    that part of it is a work based on the Library, and explaining        ',&
'    where to find the accompanying uncombined form of the same work.      ',&
'                                                                          ',&
'  8. You may not copy, modify, sublicense, link with, or distribute       ',&
'the Library except as expressly provided under this License.  Any         ',&
'attempt otherwise to copy, modify, sublicense, link with, or              ',&
'distribute the Library is void, and will automatically terminate your     ',&
'rights under this License.  However, parties who have received copies,    ',&
'or rights, from you under this License will not have their licenses       ',&
'terminated so long as such parties remain in full compliance.             ',&
'                                                                          ',&
'  9. You are not required to accept this License, since you have not      ',&
'signed it.  However, nothing else grants you permission to modify or      ',&
'distribute the Library or its derivative works.  These actions are        ',&
'prohibited by law if you do not accept this License.  Therefore, by       ',&
'modifying or distributing the Library (or any work based on the           ',&
'Library), you indicate your acceptance of this License to do so, and      ',&
'all its terms and conditions for copying, distributing or modifying       ',&
'the Library or works based on it.                                         ',&
'                                                                          ',&
'  10. Each time you redistribute the Library (or any work based on the    ',&
'Library), the recipient automatically receives a license from the         ',&
'original licensor to copy, distribute, link with or modify the Library    ',&
'subject to these terms and conditions.  You may not impose any further    ',&
'restrictions on the recipients'' exercise of the rights granted herein.   ',&
'You are not responsible for enforcing compliance by third parties with    ',&
'this License.                                                             ',&
'                                                                          ',&
'  11. If, as a consequence of a court judgment or allegation of patent    ',&
'infringement or for any other reason (not limited to patent issues),      ',&
'conditions are imposed on you (whether by court order, agreement or       ',&
'otherwise) that contradict the conditions of this License, they do not    ',&
'excuse you from the conditions of this License.  If you cannot            ',&
'distribute so as to satisfy simultaneously your obligations under this    ',&
'License and any other pertinent obligations, then as a consequence you    ',&
'may not distribute the Library at all.  For example, if a patent          ',&
'license would not permit royalty-free redistribution of the Library by    ',&
'all those who receive copies directly or indirectly through you, then     ',&
'the only way you could satisfy both it and this License would be to       ',&
'refrain entirely from distribution of the Library.                        ',&
'                                                                          ',&
'If any portion of this section is held invalid or unenforceable under any ',&
'particular circumstance, the balance of the section is intended to apply, ',&
'and the section as a whole is intended to apply in other circumstances.   ',&
'                                                                          ',&
'It is not the purpose of this section to induce you to infringe any       ',&
'patents or other property right claims or to contest validity of any      ',&
'such claims; this section has the sole purpose of protecting the          ',&
'integrity of the free software distribution system which is               ',&
'implemented by public license practices.  Many people have made           ',&
'generous contributions to the wide range of software distributed          ',&
'through that system in reliance on consistent application of that         ',&
'system; it is up to the author/donor to decide if he or she is willing    ',&
'to distribute software through any other system and a licensee cannot     ',&
'impose that choice.                                                       ',&
'                                                                          ',&
'This section is intended to make thoroughly clear what is believed to     ',&
'be a consequence of the rest of this License.                             ',&
'                                                                          ',&
'  12. If the distribution and/or use of the Library is restricted in      ',&
'certain countries either by patents or by copyrighted interfaces, the     ',&
'original copyright holder who places the Library under this License may add',&
'an explicit geographical distribution limitation excluding those countries,',&
'so that distribution is permitted only in or among countries not thus      ',&
'excluded.  In such case, this License incorporates the limitation as if    ',&
'written in the body of this License.                                       ',&
'                                                                           ',&
'  13. The Free Software Foundation may publish revised and/or new          ',&
'versions of the Lesser General Public License from time to time.           ',&
'Such new versions will be similar in spirit to the present version,        ',&
'but may differ in detail to address new problems or concerns.              ',&
'                                                                           ',&
'Each version is given a distinguishing version number.  If the Library     ',&
'specifies a version number of this License which applies to it and         ',&
'"any later version", you have the option of following the terms and        ',&
'conditions either of that version or of any later version published by     ',&
'the Free Software Foundation.  If the Library does not specify a           ',&
'license version number, you may choose any version ever published by       ',&
'the Free Software Foundation.                                              ',&
'                                                                           ',&
'  14. If you wish to incorporate parts of the Library into other free      ',&
'programs whose distribution conditions are incompatible with these,        ',&
'write to the author to ask for permission.  For software which is          ',&
'copyrighted by the Free Software Foundation, write to the Free             ',&
'Software Foundation; we sometimes make exceptions for this.  Our           ',&
'decision will be guided by the two goals of preserving the free status     ',&
'of all derivatives of our free software and of promoting the sharing       ',&
'and reuse of software generally.                                           ',&
'                                                                           ',&
'                            NO WARRANTY                                    ',&
'                                                                           ',&
'  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO          ',&
'WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.       ',&
'EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR       ',&
'OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY          ',&
'KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE      ',&
'IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR         ',&
'PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE         ',&
'LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME       ',&
'THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.                 ',&
'                                                                           ',&
'  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN        ',&
'WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY       ',&
'AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU       ',&
'FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR                 ',&
'CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE       ',&
'LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING           ',&
'RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A       ',&
'FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF        ',&
'SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH     ',&
'DAMAGES.                                                                   ',&
'                                                                           ',&
'                     END OF TERMS AND CONDITIONS                           ',&
'                                                                           ',&
'           How to Apply These Terms to Your New Libraries                  ',&
'                                                                           ',&
'  If you develop a new library, and you want it to be of the greatest      ',&
'possible use to the public, we recommend making it free software that      ',&
'everyone can redistribute and change.  You can do so by permitting         ',&
'redistribution under these terms (or, alternatively, under the terms of the',&
'ordinary General Public License).                                          ',&
'                                                                           ',&
'  To apply these terms, attach the following notices to the library.  It is',&
'safest to attach them to the start of each source file to most effectively ',&
'convey the exclusion of warranty; and each file should have at least the   ',&
'"copyright" line and a pointer to where the full notice is found.          ',&
'                                                                           ',&
'    <one line to give the library''s name and a brief idea of what it does.>',&
'    Copyright (C) @YEAR@  @NAME_OF_AUTHOR@                                  ',&
'                                                                            ',&
'    This library is free software; you can redistribute it and/or           ',&
'    modify it under the terms of the GNU Lesser General Public              ',&
'    License as published by the Free Software Foundation; either            ',&
'    version 2.1 of the License, or (at your option) any later version.      ',&
'                                                                            ',&
'    This library is distributed in the hope that it will be useful,         ',&
'    but WITHOUT ANY WARRANTY; without even the implied warranty of          ',&
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       ',&
'    Lesser General Public License for more details.                         ',&
'                                                                            ',&
'    You should have received a copy of the GNU Lesser General Public        ',&
'    License along with this library; if not, write to the Free Software     ',&
'    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301',&
'    USA                                                                      ',&
'                                                                             ',&
'Also add information on how to contact you by electronic and paper mail.     ',&
'                                                                             ',&
'You should also get your employer (if you work as a programmer) or your      ',&
'school, if any, to sign a "copyright disclaimer" for the library, if         ',&
'necessary.  Here is a sample; alter the names:                               ',&
'                                                                             ',&
'  Yoyodyne, Inc., hereby disclaims all copyright interest in the             ',&
'  library `Frob'' (a library for tweaking knobs) written by James Random     ',&
'  Hacker.                                                                    ',&
'                                                                             ',&
'  <signature of Ty Coon>, 1 April 1990                                       ',&
'  Ty Coon, President of Vice                                                 ',&
'                                                                             ',&
'That''s all there is to it!                                                  ',&
'                                                                             ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('30','lgpl-3.0')
textblock=[ CHARACTER(LEN=128) :: &
'lgpl-3.0',&
'        ',&
'                   GNU LESSER GENERAL PUBLIC LICENSE',&
'                       Version 3, 29 June 2007      ',&
'                                                    ',&
' Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>',&
' Everyone is permitted to copy and distribute verbatim copies        ',&
' of this license document, but changing it is not allowed.           ',&
'                                                                     ',&
'                                                                     ',&
'  This version of the GNU Lesser General Public License incorporates ',&
'the terms and conditions of version 3 of the GNU General Public      ',&
'License, supplemented by the additional permissions listed below.    ',&
'                                                                     ',&
'  0. Additional Definitions.                                         ',&
'                                                                     ',&
'  As used herein, "this License" refers to version 3 of the GNU Lesser',&
'General Public License, and the "GNU GPL" refers to version 3 of the GNU',&
'General Public License.                                                 ',&
'                                                                        ',&
'  "The Library" refers to a covered work governed by this License,      ',&
'other than an Application or a Combined Work as defined below.          ',&
'                                                                        ',&
'  An "Application" is any work that makes use of an interface provided  ',&
'by the Library, but which is not otherwise based on the Library.        ',&
'Defining a subclass of a class defined by the Library is deemed a mode  ',&
'of using an interface provided by the Library.                          ',&
'                                                                        ',&
'  A "Combined Work" is a work produced by combining or linking an       ',&
'Application with the Library.  The particular version of the Library    ',&
'with which the Combined Work was made is also called the "Linked        ',&
'Version".                                                               ',&
'                                                                        ',&
'  The "Minimal Corresponding Source" for a Combined Work means the      ',&
'Corresponding Source for the Combined Work, excluding any source code   ',&
'for portions of the Combined Work that, considered in isolation, are    ',&
'based on the Application, and not on the Linked Version.                ',&
'                                                                        ',&
'  The "Corresponding Application Code" for a Combined Work means the    ',&
'object code and/or source code for the Application, including any data  ',&
'and utility programs needed for reproducing the Combined Work from the  ',&
'Application, but excluding the System Libraries of the Combined Work.   ',&
'                                                                        ',&
'  1. Exception to Section 3 of the GNU GPL.                             ',&
'                                                                        ',&
'  You may convey a covered work under sections 3 and 4 of this License  ',&
'without being bound by section 3 of the GNU GPL.                        ',&
'                                                                        ',&
'  2. Conveying Modified Versions.                                       ',&
'                                                                        ',&
'  If you modify a copy of the Library, and, in your modifications, a    ',&
'facility refers to a function or data to be supplied by an Application  ',&
'that uses the facility (other than as an argument passed when the       ',&
'facility is invoked), then you may convey a copy of the modified        ',&
'version:                                                                ',&
'                                                                        ',&
'   a) under this License, provided that you make a good faith effort to ',&
'   ensure that, in the event an Application does not supply the         ',&
'   function or data, the facility still operates, and performs          ',&
'   whatever part of its purpose remains meaningful, or                  ',&
'                                                                        ',&
'   b) under the GNU GPL, with none of the additional permissions of     ',&
'   this License applicable to that copy.                                ',&
'                                                                        ',&
'  3. Object Code Incorporating Material from Library Header Files.      ',&
'                                                                        ',&
'  The object code form of an Application may incorporate material from  ',&
'a header file that is part of the Library.  You may convey such object  ',&
'code under terms of your choice, provided that, if the incorporated     ',&
'material is not limited to numerical parameters, data structure         ',&
'layouts and accessors, or small macros, inline functions and templates  ',&
'(ten or fewer lines in length), you do both of the following:           ',&
'                                                                        ',&
'   a) Give prominent notice with each copy of the object code that the  ',&
'   Library is used in it and that the Library and its use are           ',&
'   covered by this License.                                             ',&
'                                                                        ',&
'   b) Accompany the object code with a copy of the GNU GPL and this license',&
'   document.                                                               ',&
'                                                                           ',&
'  4. Combined Works.                                                       ',&
'                                                                           ',&
'  You may convey a Combined Work under terms of your choice that,          ',&
'taken together, effectively do not restrict modification of the            ',&
'portions of the Library contained in the Combined Work and reverse         ',&
'engineering for debugging such modifications, if you also do each of       ',&
'the following:                                                             ',&
'                                                                           ',&
'   a) Give prominent notice with each copy of the Combined Work that       ',&
'   the Library is used in it and that the Library and its use are          ',&
'   covered by this License.                                                ',&
'                                                                           ',&
'   b) Accompany the Combined Work with a copy of the GNU GPL and this license',&
'   document.                                                                 ',&
'                                                                             ',&
'   c) For a Combined Work that displays copyright notices during             ',&
'   execution, include the copyright notice for the Library among             ',&
'   these notices, as well as a reference directing the user to the           ',&
'   copies of the GNU GPL and this license document.                          ',&
'                                                                             ',&
'   d) Do one of the following:                                               ',&
'                                                                             ',&
'       0) Convey the Minimal Corresponding Source under the terms of this    ',&
'       License, and the Corresponding Application Code in a form             ',&
'       suitable for, and under terms that permit, the user to                ',&
'       recombine or relink the Application with a modified version of        ',&
'       the Linked Version to produce a modified Combined Work, in the        ',&
'       manner specified by section 6 of the GNU GPL for conveying            ',&
'       Corresponding Source.                                                 ',&
'                                                                             ',&
'       1) Use a suitable shared library mechanism for linking with the       ',&
'       Library.  A suitable mechanism is one that (a) uses at run time       ',&
'       a copy of the Library already present on the user''s computer         ',&
'       system, and (b) will operate properly with a modified version         ',&
'       of the Library that is interface-compatible with the Linked           ',&
'       Version.                                                              ',&
'                                                                             ',&
'   e) Provide Installation Information, but only if you would otherwise      ',&
'   be required to provide such information under section 6 of the            ',&
'   GNU GPL, and only to the extent that such information is                  ',&
'   necessary to install and execute a modified version of the                ',&
'   Combined Work produced by recombining or relinking the                    ',&
'   Application with a modified version of the Linked Version. (If            ',&
'   you use option 4d0, the Installation Information must accompany           ',&
'   the Minimal Corresponding Source and Corresponding Application            ',&
'   Code. If you use option 4d1, you must provide the Installation            ',&
'   Information in the manner specified by section 6 of the GNU GPL           ',&
'   for conveying Corresponding Source.)                                      ',&
'                                                                             ',&
'  5. Combined Libraries.                                                     ',&
'                                                                             ',&
'  You may place library facilities that are a work based on the              ',&
'Library side by side in a single library together with other library         ',&
'facilities that are not Applications and are not covered by this             ',&
'License, and convey such a combined library under terms of your              ',&
'choice, if you do both of the following:                                     ',&
'                                                                             ',&
'   a) Accompany the combined library with a copy of the same work based      ',&
'   on the Library, uncombined with any other library facilities,             ',&
'   conveyed under the terms of this License.                                 ',&
'                                                                             ',&
'   b) Give prominent notice with the combined library that part of it        ',&
'   is a work based on the Library, and explaining where to find the          ',&
'   accompanying uncombined form of the same work.                            ',&
'                                                                             ',&
'  6. Revised Versions of the GNU Lesser General Public License.              ',&
'                                                                             ',&
'  The Free Software Foundation may publish revised and/or new versions       ',&
'of the GNU Lesser General Public License from time to time. Such new         ',&
'versions will be similar in spirit to the present version, but may           ',&
'differ in detail to address new problems or concerns.                        ',&
'                                                                             ',&
'  Each version is given a distinguishing version number. If the              ',&
'Library as you received it specifies that a certain numbered version         ',&
'of the GNU Lesser General Public License "or any later version"              ',&
'applies to it, you have the option of following the terms and                ',&
'conditions either of that published version or of any later version          ',&
'published by the Free Software Foundation. If the Library as you             ',&
'received it does not specify a version number of the GNU Lesser              ',&
'General Public License, you may choose any version of the GNU Lesser         ',&
'General Public License ever published by the Free Software Foundation.       ',&
'                                                                             ',&
'  If the Library as you received it specifies that a proxy can decide        ',&
'whether future versions of the GNU Lesser General Public License shall       ',&
'apply, that proxy''s public statement of acceptance of any version is        ',&
'permanent authorization for you to choose that version for the               ',&
'Library.                                                                     ',&
'                                                                             ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('31','lppl-1.3c')
textblock=[ CHARACTER(LEN=128) :: &
'lppl-1.3c',&
'         ',&
'The LaTeX Project Public License',&
'=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-',&
'                                ',&
'LPPL Version 1.3c  2008-05-04   ',&
'                                ',&
'Copyright 1999 2002-2008 LaTeX3 Project',&
'    Everyone is allowed to distribute verbatim copies of this',&
'    license document, but modification of it is not allowed. ',&
'                                                             ',&
'                                                             ',&
'PREAMBLE                                                     ',&
'========                                                     ',&
'                                                             ',&
'The LaTeX Project Public License (LPPL) is the primary license under',&
'which the LaTeX kernel and the base LaTeX packages are distributed. ',&
'                                                                    ',&
'You may use this license for any work of which you hold the copyright',&
'and which you wish to distribute.  This license may be particularly  ',&
'suitable if your work is TeX-related (such as a LaTeX package), but  ',&
'it is written in such a way that you can use it even if your work is ',&
'unrelated to TeX.                                                    ',&
'                                                                     ',&
'The section `WHETHER AND HOW TO DISTRIBUTE WORKS UNDER THIS LICENSE'',',&
'below, gives instructions, examples, and recommendations for authors  ',&
'who are considering distributing their works under this license.      ',&
'                                                                      ',&
'This license gives conditions under which a work may be distributed   ',&
'and modified, as well as conditions under which modified versions of  ',&
'that work may be distributed.                                         ',&
'                                                                      ',&
'We, the LaTeX3 Project, believe that the conditions below give you    ',&
'the freedom to make and distribute modified versions of your work     ',&
'that conform with whatever technical specifications you wish while    ',&
'maintaining the availability, integrity, and reliability of           ',&
'that work.  If you do not see how to achieve your goal while          ',&
'meeting these conditions, then read the document `cfgguide.tex''      ',&
'and `modguide.tex'' in the base LaTeX distribution for suggestions.   ',&
'                                                                      ',&
'                                                                      ',&
'DEFINITIONS                                                           ',&
'===========                                                           ',&
'                                                                      ',&
'In this license document the following terms are used:                ',&
'                                                                      ',&
'   `Work''                                                            ',&
'    Any work being distributed under this License.                    ',&
'                                                                      ',&
'   `Derived Work''                                                    ',&
'    Any work that under any applicable law is derived from the Work.  ',&
'                                                                      ',&
'   `Modification''                                                    ',&
'    Any procedure that produces a Derived Work under any applicable   ',&
'    law -- for example, the production of a file containing an        ',&
'    original file associated with the Work or a significant portion of',&
'    such a file, either verbatim or with modifications and/or         ',&
'    translated into another language.                                 ',&
'                                                                      ',&
'   `Modify''                                                          ',&
'    To apply any procedure that produces a Derived Work under any     ',&
'    applicable law.                                                   ',&
'                                                                      ',&
'   `Distribution''                                                    ',&
'    Making copies of the Work available from one person to another, in',&
'    whole or in part.  Distribution includes (but is not limited to)  ',&
'    making any electronic components of the Work accessible by        ',&
'    file transfer protocols such as FTP or HTTP or by shared file     ',&
'    systems such as Sun''s Network File System (NFS).                 ',&
'                                                                      ',&
'   `Compiled Work''                                                   ',&
'    A version of the Work that has been processed into a form where it',&
'    is directly usable on a computer system.  This processing may     ',&
'    include using installation facilities provided by the Work,       ',&
'    transformations of the Work, copying of components of the Work, or',&
'    other activities.  Note that modification of any installation     ',&
'    facilities provided by the Work constitutes modification of the Work.',&
'                                                                         ',&
'   `Current Maintainer''                                                 ',&
'    A person or persons nominated as such within the Work.  If there is  ',&
'    no such explicit nomination then it is the `Copyright Holder'' under ',&
'    any applicable law.                                                  ',&
'                                                                         ',&
'   `Base Interpreter''                                                   ',&
'    A program or process that is normally needed for running or          ',&
'    interpreting a part or the whole of the Work.                        ',&
'                                                                         ',&
'    A Base Interpreter may depend on external components but these       ',&
'    are not considered part of the Base Interpreter provided that each   ',&
'    external component clearly identifies itself whenever it is used     ',&
'    interactively.  Unless explicitly specified when applying the        ',&
'    license to the Work, the only applicable Base Interpreter is a       ',&
'    `LaTeX-Format'' or in the case of files belonging to the             ',&
'    `LaTeX-format'' a program implementing the `TeX language''.          ',&
'                                                                         ',&
'                                                                         ',&
'                                                                         ',&
'CONDITIONS ON DISTRIBUTION AND MODIFICATION                              ',&
'===========================================                              ',&
'                                                                         ',&
'1.  Activities other than distribution and/or modification of the Work   ',&
'are not covered by this license; they are outside its scope.  In         ',&
'particular, the act of running the Work is not restricted and no         ',&
'requirements are made concerning any offers of support for the Work.     ',&
'                                                                         ',&
'2.  You may distribute a complete, unmodified copy of the Work as you    ',&
'received it.  Distribution of only part of the Work is considered        ',&
'modification of the Work, and no right to distribute such a Derived      ',&
'Work may be assumed under the terms of this clause.                      ',&
'                                                                         ',&
'3.  You may distribute a Compiled Work that has been generated from a    ',&
'complete, unmodified copy of the Work as distributed under Clause 2      ',&
'above, as long as that Compiled Work is distributed in such a way that   ',&
'the recipients may install the Compiled Work on their system exactly     ',&
'as it would have been installed if they generated a Compiled Work        ',&
'directly from the Work.                                                  ',&
'                                                                         ',&
'4.  If you are the Current Maintainer of the Work, you may, without      ',&
'restriction, modify the Work, thus creating a Derived Work.  You may     ',&
'also distribute the Derived Work without restriction, including          ',&
'Compiled Works generated from the Derived Work.  Derived Works           ',&
'distributed in this manner by the Current Maintainer are considered to   ',&
'be updated versions of the Work.                                         ',&
'                                                                         ',&
'5.  If you are not the Current Maintainer of the Work, you may modify    ',&
'your copy of the Work, thus creating a Derived Work based on the Work,   ',&
'and compile this Derived Work, thus creating a Compiled Work based on    ',&
'the Derived Work.                                                        ',&
'                                                                         ',&
'6.  If you are not the Current Maintainer of the Work, you may           ',&
'distribute a Derived Work provided the following conditions are met      ',&
'for every component of the Work unless that component clearly states     ',&
'in the copyright notice that it is exempt from that condition.  Only     ',&
'the Current Maintainer is allowed to add such statements of exemption    ',&
'to a component of the Work.                                              ',&
'                                                                         ',&
'  a. If a component of this Derived Work can be a direct replacement     ',&
'     for a component of the Work when that component is used with the    ',&
'     Base Interpreter, then, wherever this component of the Work         ',&
'     identifies itself to the user when used interactively with that     ',&
'     Base Interpreter, the replacement component of this Derived Work    ',&
'     clearly and unambiguously identifies itself as a modified version   ',&
'     of this component to the user when used interactively with that     ',&
'     Base Interpreter.                                                   ',&
'                                                                         ',&
'  b. Every component of the Derived Work contains prominent notices      ',&
'     detailing the nature of the changes to that component, or a         ',&
'     prominent reference to another file that is distributed as part     ',&
'     of the Derived Work and that contains a complete and accurate log   ',&
'     of the changes.                                                     ',&
'                                                                         ',&
'  c. No information in the Derived Work implies that any persons,        ',&
'     including (but not limited to) the authors of the original version  ',&
'     of the Work, provide any support, including (but not limited to)    ',&
'     the reporting and handling of errors, to recipients of the          ',&
'     Derived Work unless those persons have stated explicitly that       ',&
'     they do provide such support for the Derived Work.                  ',&
'                                                                         ',&
'  d. You distribute at least one of the following with the Derived Work: ',&
'                                                                         ',&
'       1. A complete, unmodified copy of the Work;                       ',&
'          if your distribution of a modified component is made by        ',&
'          offering access to copy the modified component from a          ',&
'          designated place, then offering equivalent access to copy      ',&
'          the Work from the same or some similar place meets this        ',&
'          condition, even though third parties are not compelled to      ',&
'          copy the Work along with the modified component;               ',&
'                                                                         ',&
'       2. Information that is sufficient to obtain a complete,           ',&
'          unmodified copy of the Work.                                   ',&
'                                                                         ',&
'7.  If you are not the Current Maintainer of the Work, you may           ',&
'distribute a Compiled Work generated from a Derived Work, as long as     ',&
'the Derived Work is distributed to all recipients of the Compiled        ',&
'Work, and as long as the conditions of Clause 6, above, are met with     ',&
'regard to the Derived Work.                                              ',&
'                                                                         ',&
'8.  The conditions above are not intended to prohibit, and hence do not  ',&
'apply to, the modification, by any method, of any component so that it   ',&
'becomes identical to an updated version of that component of the Work as ',&
'it is distributed by the Current Maintainer under Clause 4, above.       ',&
'                                                                         ',&
'9.  Distribution of the Work or any Derived Work in an alternative       ',&
'format, where the Work or that Derived Work (in whole or in part) is     ',&
'then produced by applying some process to that format, does not relax or ',&
'nullify any sections of this license as they pertain to the results of   ',&
'applying that process.                                                   ',&
'                                                                         ',&
'10. a. A Derived Work may be distributed under a different license       ',&
'       provided that license itself honors the conditions listed in      ',&
'       Clause 6 above, in regard to the Work, though it does not have    ',&
'       to honor the rest of the conditions in this license.              ',&
'                                                                         ',&
'    b. If a Derived Work is distributed under a different license, that  ',&
'       Derived Work must provide sufficient documentation as part of     ',&
'       itself to allow each recipient of that Derived Work to honor the  ',&
'       restrictions in Clause 6 above, concerning changes from the Work. ',&
'                                                                         ',&
'11. This license places no restrictions on works that are unrelated to   ',&
'the Work, nor does this license place any restrictions on aggregating    ',&
'such works with the Work by any means.                                   ',&
'                                                                         ',&
'12.  Nothing in this license is intended to, or may be used to, prevent  ',&
'complete compliance by all parties with all applicable laws.             ',&
'                                                                         ',&
'                                                                         ',&
'NO WARRANTY                                                              ',&
'===========                                                              ',&
'                                                                         ',&
'There is no warranty for the Work.  Except when otherwise stated in      ',&
'writing, the Copyright Holder provides the Work `as is'', without        ',&
'warranty of any kind, either expressed or implied, including, but not    ',&
'limited to, the implied warranties of merchantability and fitness for a  ',&
'particular purpose.  The entire risk as to the quality and performance   ',&
'of the Work is with you.  Should the Work prove defective, you assume    ',&
'the cost of all necessary servicing, repair, or correction.              ',&
'                                                                         ',&
'In no event unless required by applicable law or agreed to in writing    ',&
'will The Copyright Holder, or any author named in the components of the  ',&
'Work, or any other party who may distribute and/or modify the Work as    ',&
'permitted above, be liable to you for damages, including any general,    ',&
'special, incidental or consequential damages arising out of any use of   ',&
'the Work or out of inability to use the Work (including, but not limited ',&
'to, loss of data, data being rendered inaccurate, or losses sustained by ',&
'anyone as a result of any failure of the Work to operate with any other  ',&
'programs), even if the Copyright Holder or said author or said other     ',&
'party has been advised of the possibility of such damages.               ',&
'                                                                         ',&
'                                                                         ',&
'MAINTENANCE OF THE WORK                                                  ',&
'=======================                                                  ',&
'                                                                         ',&
'The Work has the status `author-maintained'' if the Copyright Holder     ',&
'explicitly and prominently states near the primary copyright notice in   ',&
'the Work that the Work can only be maintained by the Copyright Holder    ',&
'or simply that it is `author-maintained''.                               ',&
'                                                                         ',&
'The Work has the status `maintained'' if there is a Current Maintainer   ',&
'who has indicated in the Work that they are willing to receive error     ',&
'reports for the Work (for example, by supplying a valid e-mail           ',&
'address). It is not required for the Current Maintainer to acknowledge   ',&
'or act upon these error reports.                                         ',&
'                                                                         ',&
'The Work changes from status `maintained'' to `unmaintained'' if there   ',&
'is no Current Maintainer, or the person stated to be Current             ',&
'Maintainer of the work cannot be reached through the indicated means     ',&
'of communication for a period of six months, and there are no other      ',&
'significant signs of active maintenance.                                 ',&
'                                                                         ',&
'You can become the Current Maintainer of the Work by agreement with      ',&
'any existing Current Maintainer to take over this role.                  ',&
'                                                                         ',&
'If the Work is unmaintained, you can become the Current Maintainer of    ',&
'the Work through the following steps:                                    ',&
'                                                                         ',&
' 1.  Make a reasonable attempt to trace the Current Maintainer (and      ',&
'     the Copyright Holder, if the two differ) through the means of       ',&
'     an Internet or similar search.                                      ',&
'                                                                         ',&
' 2.  If this search is successful, then enquire whether the Work         ',&
'     is still maintained.                                                ',&
'                                                                         ',&
'  a. If it is being maintained, then ask the Current Maintainer          ',&
'     to update their communication data within one month.                ',&
'                                                                         ',&
'  b. If the search is unsuccessful or no action to resume active         ',&
'     maintenance is taken by the Current Maintainer, then announce       ',&
'     within the pertinent community your intention to take over          ',&
'     maintenance.  (If the Work is a LaTeX work, this could be           ',&
'     done, for example, by posting to comp.text.tex.)                    ',&
'                                                                         ',&
' 3a. If the Current Maintainer is reachable and agrees to pass           ',&
'     maintenance of the Work to you, then this takes effect              ',&
'     immediately upon announcement.                                      ',&
'                                                                         ',&
'  b. If the Current Maintainer is not reachable and the Copyright        ',&
'     Holder agrees that maintenance of the Work be passed to you,        ',&
'     then this takes effect immediately upon announcement.               ',&
'                                                                         ',&
' 4.  If you make an `intention announcement'' as described in 2b. above  ',&
'     and after three months your intention is challenged neither by      ',&
'     the Current Maintainer nor by the Copyright Holder nor by other     ',&
'     people, then you may arrange for the Work to be changed so as       ',&
'     to name you as the (new) Current Maintainer.                        ',&
'                                                                         ',&
' 5.  If the previously unreachable Current Maintainer becomes            ',&
'     reachable once more within three months of a change completed       ',&
'     under the terms of 3b) or 4), then that Current Maintainer must     ',&
'     become or remain the Current Maintainer upon request provided       ',&
'     they then update their communication data within one month.         ',&
'                                                                         ',&
'A change in the Current Maintainer does not, of itself, alter the fact   ',&
'that the Work is distributed under the LPPL license.                     ',&
'                                                                         ',&
'If you become the Current Maintainer of the Work, you should             ',&
'immediately provide, within the Work, a prominent and unambiguous        ',&
'statement of your status as Current Maintainer.  You should also         ',&
'announce your new status to the same pertinent community as              ',&
'in 2b) above.                                                            ',&
'                                                                         ',&
'                                                                         ',&
'WHETHER AND HOW TO DISTRIBUTE WORKS UNDER THIS LICENSE                   ',&
'======================================================                   ',&
'                                                                         ',&
'This section contains important instructions, examples, and              ',&
'recommendations for authors who are considering distributing their       ',&
'works under this license.  These authors are addressed as `you'' in      ',&
'this section.                                                            ',&
'                                                                         ',&
'Choosing This License or Another License                                 ',&
'----------------------------------------                                 ',&
'                                                                         ',&
'If for any part of your work you want or need to use *distribution*      ',&
'conditions that differ significantly from those in this license, then    ',&
'do not refer to this license anywhere in your work but, instead,         ',&
'distribute your work under a different license.  You may use the text    ',&
'of this license as a model for your own license, but your license        ',&
'should not refer to the LPPL or otherwise give the impression that       ',&
'your work is distributed under the LPPL.                                 ',&
'                                                                         ',&
'The document `modguide.tex'' in the base LaTeX distribution explains     ',&
'the motivation behind the conditions of this license.  It explains,      ',&
'for example, why distributing LaTeX under the GNU General Public         ',&
'License (GPL) was considered inappropriate.  Even if your work is        ',&
'unrelated to LaTeX, the discussion in `modguide.tex'' may still be       ',&
'relevant, and authors intending to distribute their works under any      ',&
'license are encouraged to read it.                                       ',&
'                                                                         ',&
'A Recommendation on Modification Without Distribution                    ',&
'-----------------------------------------------------                    ',&
'                                                                         ',&
'It is wise never to modify a component of the Work, even for your own    ',&
'personal use, without also meeting the above conditions for              ',&
'distributing the modified component.  While you might intend that such   ',&
'modifications will never be distributed, often this will happen by       ',&
'accident -- you may forget that you have modified that component; or     ',&
'it may not occur to you when allowing others to access the modified      ',&
'version that you are thus distributing it and violating the conditions   ',&
'of this license in ways that could have legal implications and, worse,   ',&
'cause problems for the community.  It is therefore usually in your       ',&
'best interest to keep your copy of the Work identical with the public    ',&
'one.  Many works provide ways to control the behavior of that work       ',&
'without altering any of its licensed components.                         ',&
'                                                                         ',&
'How to Use This License                                                  ',&
'-----------------------                                                  ',&
'                                                                         ',&
'To use this license, place in each of the components of your work both   ',&
'an explicit copyright notice including your name and the year the work   ',&
'was authored and/or last substantially modified.  Include also a         ',&
'statement that the distribution and/or modification of that              ',&
'component is constrained by the conditions in this license.              ',&
'                                                                         ',&
'Here is an example of such a notice and statement:                       ',&
'                                                                         ',&
'  %% pig.dtx                                                             ',&
'  %% Copyright 2005 M. Y. Name                                           ',&
'  %                                                                      ',&
'  % This work may be distributed and/or modified under the               ',&
'  % conditions of the LaTeX Project Public License, either version 1.3   ',&
'  % of this license or (at your option) any later version.               ',&
'  % The latest version of this license is in                             ',&
'  %   http://www.latex-project.org/lppl.txt                              ',&
'  % and version 1.3 or later is part of all distributions of LaTeX       ',&
'  % version 2005/12/01 or later.                                         ',&
'  %                                                                      ',&
'  % This work has the LPPL maintenance status `maintained''.             ',&
'  %                                                                      ',&
'  % The Current Maintainer of this work is M. Y. Name.                   ',&
'  %                                                                      ',&
'  % This work consists of the files pig.dtx and pig.ins                  ',&
'  % and the derived file pig.sty.                                        ',&
'                                                                         ',&
'Given such a notice and statement in a file, the conditions              ',&
'given in this license document would apply, with the `Work'' referring   ',&
'to the three files `pig.dtx'', `pig.ins'', and `pig.sty'' (the last being',&
'generated from `pig.dtx'' using `pig.ins''), the `Base Interpreter''     ',&
'referring to any `LaTeX-Format'', and both `Copyright Holder'' and       ',&
'`Current Maintainer'' referring to the person `M. Y. Name''.             ',&
'                                                                         ',&
'If you do not want the Maintenance section of LPPL to apply to your      ',&
'Work, change `maintained'' above into `author-maintained''.              ',&
'However, we recommend that you use `maintained'', as the Maintenance     ',&
'section was added in order to ensure that your Work remains useful to    ',&
'the community even when you can no longer maintain and support it        ',&
'yourself.                                                                ',&
'                                                                         ',&
'Derived Works That Are Not Replacements                                  ',&
'---------------------------------------                                  ',&
'                                                                         ',&
'Several clauses of the LPPL specify means to provide reliability and     ',&
'stability for the user community. They therefore concern themselves      ',&
'with the case that a Derived Work is intended to be used as a            ',&
'(compatible or incompatible) replacement of the original Work. If        ',&
'this is not the case (e.g., if a few lines of code are reused for a      ',&
'completely different task), then clauses 6b and 6d shall not apply.      ',&
'                                                                         ',&
'                                                                         ',&
'Important Recommendations                                                ',&
'-------------------------                                                ',&
'                                                                         ',&
' Defining What Constitutes the Work                                      ',&
'                                                                         ',&
'   The LPPL requires that distributions of the Work contain all the      ',&
'   files of the Work.  It is therefore important that you provide a      ',&
'   way for the licensee to determine which files constitute the Work.    ',&
'   This could, for example, be achieved by explicitly listing all the    ',&
'   files of the Work near the copyright notice of each file or by        ',&
'   using a line such as:                                                 ',&
'                                                                         ',&
'    % This work consists of all files listed in manifest.txt.            ',&
'                                                                         ',&
'   in that place.  In the absence of an unequivocal list it might be     ',&
'   impossible for the licensee to determine what is considered by you    ',&
'   to comprise the Work and, in such a case, the licensee would be       ',&
'   entitled to make reasonable conjectures as to which files comprise    ',&
'   the Work.                                                             ',&
'                                                                         ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('32','mit-0')
textblock=[ CHARACTER(LEN=128) :: &
'mit-0',&
'     ',&
'MIT No Attribution',&
'                  ',&
'Copyright @YEAR@ @FULLNAME@',&
'                           ',&
'Permission is hereby granted, free of charge, to any person obtaining a copy',&
'of this software and associated documentation files (the "Software"), to deal',&
'in the Software without restriction, including without limitation the rights ',&
'to use, copy, modify, merge, publish, distribute, sublicense, and/or sell    ',&
'copies of the Software, and to permit persons to whom the Software is        ',&
'furnished to do so.                                                          ',&
'                                                                             ',&
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   ',&
'IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     ',&
'FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  ',&
'AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER       ',&
'LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,',&
'OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE',&
'SOFTWARE.                                                                    ',&
'                                                                             ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('33','mit')
textblock=[ CHARACTER(LEN=128) :: &
'mit',&
'   ',&
'MIT License',&
'           ',&
'Copyright (c) @YEAR@ @FULLNAME@',&
'                               ',&
'Permission is hereby granted, free of charge, to any person obtaining a copy',&
'of this software and associated documentation files (the "Software"), to deal',&
'in the Software without restriction, including without limitation the rights ',&
'to use, copy, modify, merge, publish, distribute, sublicense, and/or sell    ',&
'copies of the Software, and to permit persons to whom the Software is        ',&
'furnished to do so, subject to the following conditions:                     ',&
'                                                                             ',&
'The above copyright notice and this permission notice shall be included in all',&
'copies or substantial portions of the Software.                               ',&
'                                                                              ',&
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    ',&
'IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      ',&
'FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   ',&
'AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        ',&
'LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ',&
'OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ',&
'SOFTWARE.                                                                     ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('34','mpl-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'mpl-2.0',&
'       ',&
'Mozilla Public License Version 2.0',&
'==================================',&
'                                  ',&
'1. Definitions                    ',&
'--------------                    ',&
'                                  ',&
'1.1. "Contributor"                ',&
'    means each individual or legal entity that creates, contributes to',&
'    the creation of, or owns Covered Software.                        ',&
'                                                                      ',&
'1.2. "Contributor Version"                                            ',&
'    means the combination of the Contributions of others (if any) used',&
'    by a Contributor and that particular Contributor''s Contribution. ',&
'                                                                      ',&
'1.3. "Contribution"                                                   ',&
'    means Covered Software of a particular Contributor.               ',&
'                                                                      ',&
'1.4. "Covered Software"                                               ',&
'    means Source Code Form to which the initial Contributor has attached',&
'    the notice in Exhibit A, the Executable Form of such Source Code    ',&
'    Form, and Modifications of such Source Code Form, in each case      ',&
'    including portions thereof.                                         ',&
'                                                                        ',&
'1.5. "Incompatible With Secondary Licenses"                             ',&
'    means                                                               ',&
'                                                                        ',&
'    (a) that the initial Contributor has attached the notice described  ',&
'        in Exhibit B to the Covered Software; or                        ',&
'                                                                        ',&
'    (b) that the Covered Software was made available under the terms of ',&
'        version 1.1 or earlier of the License, but not also under the   ',&
'        terms of a Secondary License.                                   ',&
'                                                                        ',&
'1.6. "Executable Form"                                                  ',&
'    means any form of the work other than Source Code Form.             ',&
'                                                                        ',&
'1.7. "Larger Work"                                                      ',&
'    means a work that combines Covered Software with other material, in ',&
'    a separate file or files, that is not Covered Software.             ',&
'                                                                        ',&
'1.8. "License"                                                          ',&
'    means this document.                                                ',&
'                                                                        ',&
'1.9. "Licensable"                                                       ',&
'    means having the right to grant, to the maximum extent possible,    ',&
'    whether at the time of the initial grant or subsequently, any and   ',&
'    all of the rights conveyed by this License.                         ',&
'                                                                        ',&
'1.10. "Modifications"                                                   ',&
'    means any of the following:                                         ',&
'                                                                        ',&
'    (a) any file in Source Code Form that results from an addition to,  ',&
'        deletion from, or modification of the contents of Covered       ',&
'        Software; or                                                    ',&
'                                                                        ',&
'    (b) any new file in Source Code Form that contains any Covered      ',&
'        Software.                                                       ',&
'                                                                        ',&
'1.11. "Patent Claims" of a Contributor                                  ',&
'    means any patent claim(s), including without limitation, method,    ',&
'    process, and apparatus claims, in any patent Licensable by such     ',&
'    Contributor that would be infringed, but for the grant of the       ',&
'    License, by the making, using, selling, offering for sale, having   ',&
'    made, import, or transfer of either its Contributions or its        ',&
'    Contributor Version.                                                ',&
'                                                                        ',&
'1.12. "Secondary License"                                               ',&
'    means either the GNU General Public License, Version 2.0, the GNU   ',&
'    Lesser General Public License, Version 2.1, the GNU Affero General  ',&
'    Public License, Version 3.0, or any later versions of those         ',&
'    licenses.                                                           ',&
'                                                                        ',&
'1.13. "Source Code Form"                                                ',&
'    means the form of the work preferred for making modifications.      ',&
'                                                                        ',&
'1.14. "You" (or "Your")                                                 ',&
'    means an individual or a legal entity exercising rights under this  ',&
'    License. For legal entities, "You" includes any entity that         ',&
'    controls, is controlled by, or is under common control with You. For',&
'    purposes of this definition, "control" means (a) the power, direct  ',&
'    or indirect, to cause the direction or management of such entity,   ',&
'    whether by contract or otherwise, or (b) ownership of more than     ',&
'    fifty percent (50%) of the outstanding shares or beneficial         ',&
'    ownership of such entity.                                           ',&
'                                                                        ',&
'2. License Grants and Conditions                                        ',&
'--------------------------------                                        ',&
'                                                                        ',&
'2.1. Grants                                                             ',&
'                                                                        ',&
'Each Contributor hereby grants You a world-wide, royalty-free,          ',&
'non-exclusive license:                                                  ',&
'                                                                        ',&
'(a) under intellectual property rights (other than patent or trademark) ',&
'    Licensable by such Contributor to use, reproduce, make available,   ',&
'    modify, display, perform, distribute, and otherwise exploit its     ',&
'    Contributions, either on an unmodified basis, with Modifications, or',&
'    as part of a Larger Work; and                                       ',&
'                                                                        ',&
'(b) under Patent Claims of such Contributor to make, use, sell, offer   ',&
'    for sale, have made, import, and otherwise transfer either its      ',&
'    Contributions or its Contributor Version.                           ',&
'                                                                        ',&
'2.2. Effective Date                                                     ',&
'                                                                        ',&
'The licenses granted in Section 2.1 with respect to any Contribution    ',&
'become effective for each Contribution on the date the Contributor first',&
'distributes such Contribution.                                          ',&
'                                                                        ',&
'2.3. Limitations on Grant Scope                                         ',&
'                                                                        ',&
'The licenses granted in this Section 2 are the only rights granted under',&
'this License. No additional rights or licenses will be implied from the ',&
'distribution or licensing of Covered Software under this License.       ',&
'Notwithstanding Section 2.1(b) above, no patent license is granted by a ',&
'Contributor:                                                            ',&
'                                                                        ',&
'(a) for any code that a Contributor has removed from Covered Software;  ',&
'    or                                                                  ',&
'                                                                        ',&
'(b) for infringements caused by: (i) Your and any other third party''s  ',&
'    modifications of Covered Software, or (ii) the combination of its   ',&
'    Contributions with other software (except as part of its Contributor',&
'    Version); or                                                        ',&
'                                                                        ',&
'(c) under Patent Claims infringed by Covered Software in the absence of ',&
'    its Contributions.                                                  ',&
'                                                                        ',&
'This License does not grant any rights in the trademarks, service marks,',&
'or logos of any Contributor (except as may be necessary to comply with  ',&
'the notice requirements in Section 3.4).                                ',&
'                                                                        ',&
'2.4. Subsequent Licenses                                                ',&
'                                                                        ',&
'No Contributor makes additional grants as a result of Your choice to    ',&
'distribute the Covered Software under a subsequent version of this      ',&
'License (see Section 10.2) or under the terms of a Secondary License (if',&
'permitted under the terms of Section 3.3).                              ',&
'                                                                        ',&
'2.5. Representation                                                     ',&
'                                                                        ',&
'Each Contributor represents that the Contributor believes its           ',&
'Contributions are its original creation(s) or it has sufficient rights  ',&
'to grant the rights to its Contributions conveyed by this License.      ',&
'                                                                        ',&
'2.6. Fair Use                                                           ',&
'                                                                        ',&
'This License is not intended to limit any rights You have under         ',&
'applicable copyright doctrines of fair use, fair dealing, or other      ',&
'equivalents.                                                            ',&
'                                                                        ',&
'2.7. Conditions                                                         ',&
'                                                                        ',&
'Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted  ',&
'in Section 2.1.                                                         ',&
'                                                                        ',&
'3. Responsibilities                                                     ',&
'-------------------                                                     ',&
'                                                                        ',&
'3.1. Distribution of Source Form                                        ',&
'                                                                        ',&
'All distribution of Covered Software in Source Code Form, including any ',&
'Modifications that You create or to which You contribute, must be under ',&
'the terms of this License. You must inform recipients that the Source   ',&
'Code Form of the Covered Software is governed by the terms of this      ',&
'License, and how they can obtain a copy of this License. You may not    ',&
'attempt to alter or restrict the recipients'' rights in the Source Code ',&
'Form.                                                                   ',&
'                                                                        ',&
'3.2. Distribution of Executable Form                                    ',&
'                                                                        ',&
'If You distribute Covered Software in Executable Form then:             ',&
'                                                                        ',&
'(a) such Covered Software must also be made available in Source Code    ',&
'    Form, as described in Section 3.1, and You must inform recipients of',&
'    the Executable Form how they can obtain a copy of such Source Code  ',&
'    Form by reasonable means in a timely manner, at a charge no more    ',&
'    than the cost of distribution to the recipient; and                 ',&
'                                                                        ',&
'(b) You may distribute such Executable Form under the terms of this     ',&
'    License, or sublicense it under different terms, provided that the  ',&
'    license for the Executable Form does not attempt to limit or alter  ',&
'    the recipients'' rights in the Source Code Form under this License. ',&
'                                                                        ',&
'3.3. Distribution of a Larger Work                                      ',&
'                                                                        ',&
'You may create and distribute a Larger Work under terms of Your choice, ',&
'provided that You also comply with the requirements of this License for ',&
'the Covered Software. If the Larger Work is a combination of Covered    ',&
'Software with a work governed by one or more Secondary Licenses, and the',&
'Covered Software is not Incompatible With Secondary Licenses, this      ',&
'License permits You to additionally distribute such Covered Software    ',&
'under the terms of such Secondary License(s), so that the recipient of  ',&
'the Larger Work may, at their option, further distribute the Covered    ',&
'Software under the terms of either this License or such Secondary       ',&
'License(s).                                                             ',&
'                                                                        ',&
'3.4. Notices                                                            ',&
'                                                                        ',&
'You may not remove or alter the substance of any license notices        ',&
'(including copyright notices, patent notices, disclaimers of warranty,  ',&
'or limitations of liability) contained within the Source Code Form of   ',&
'the Covered Software, except that You may alter any license notices to  ',&
'the extent required to remedy known factual inaccuracies.               ',&
'                                                                        ',&
'3.5. Application of Additional Terms                                    ',&
'                                                                        ',&
'You may choose to offer, and to charge a fee for, warranty, support,    ',&
'indemnity or liability obligations to one or more recipients of Covered ',&
'Software. However, You may do so only on Your own behalf, and not on    ',&
'behalf of any Contributor. You must make it absolutely clear that any   ',&
'such warranty, support, indemnity, or liability obligation is offered by',&
'You alone, and You hereby agree to indemnify every Contributor for any  ',&
'liability incurred by such Contributor as a result of warranty, support,',&
'indemnity or liability terms You offer. You may include additional      ',&
'disclaimers of warranty and limitations of liability specific to any    ',&
'jurisdiction.                                                           ',&
'                                                                        ',&
'4. Inability to Comply Due to Statute or Regulation                     ',&
'---------------------------------------------------                     ',&
'                                                                        ',&
'If it is impossible for You to comply with any of the terms of this     ',&
'License with respect to some or all of the Covered Software due to      ',&
'statute, judicial order, or regulation then You must: (a) comply with   ',&
'the terms of this License to the maximum extent possible; and (b)       ',&
'describe the limitations and the code they affect. Such description must',&
'be placed in a text file included with all distributions of the Covered ',&
'Software under this License. Except to the extent prohibited by statute ',&
'or regulation, such description must be sufficiently detailed for a     ',&
'recipient of ordinary skill to be able to understand it.                ',&
'                                                                        ',&
'5. Termination                                                          ',&
'--------------                                                          ',&
'                                                                        ',&
'5.1. The rights granted under this License will terminate automatically ',&
'if You fail to comply with any of its terms. However, if You become     ',&
'compliant, then the rights granted under this License from a particular ',&
'Contributor are reinstated (a) provisionally, unless and until such     ',&
'Contributor explicitly and finally terminates Your grants, and (b) on an',&
'ongoing basis, if such Contributor fails to notify You of the           ',&
'non-compliance by some reasonable means prior to 60 days after You have ',&
'come back into compliance. Moreover, Your grants from a particular      ',&
'Contributor are reinstated on an ongoing basis if such Contributor      ',&
'notifies You of the non-compliance by some reasonable means, this is the',&
'first time You have received notice of non-compliance with this License ',&
'from such Contributor, and You become compliant prior to 30 days after  ',&
'Your receipt of the notice.                                             ',&
'                                                                        ',&
'5.2. If You initiate litigation against any entity by asserting a patent',&
'infringement claim (excluding declaratory judgment actions,             ',&
'counter-claims, and cross-claims) alleging that a Contributor Version   ',&
'directly or indirectly infringes any patent, then the rights granted to ',&
'You by any and all Contributors for the Covered Software under Section  ',&
'2.1 of this License shall terminate.                                    ',&
'                                                                        ',&
'5.3. In the event of termination under Sections 5.1 or 5.2 above, all   ',&
'end user license agreements (excluding distributors and resellers) which',&
'have been validly granted by You or Your distributors under this License',&
'prior to termination shall survive termination.                         ',&
'                                                                        ',&
'************************************************************************',&
'*                                                                      *',&
'*  6. Disclaimer of Warranty                                           *',&
'*  -------------------------                                           *',&
'*                                                                      *',&
'*  Covered Software is provided under this License on an "as is"       *',&
'*  basis, without warranty of any kind, either expressed, implied, or  *',&
'*  statutory, including, without limitation, warranties that the       *',&
'*  Covered Software is free of defects, merchantable, fit for a        *',&
'*  particular purpose or non-infringing. The entire risk as to the     *',&
'*  quality and performance of the Covered Software is with You.        *',&
'*  Should any Covered Software prove defective in any respect, You     *',&
'*  (not any Contributor) assume the cost of any necessary servicing,   *',&
'*  repair, or correction. This disclaimer of warranty constitutes an   *',&
'*  essential part of this License. No use of any Covered Software is   *',&
'*  authorized under this License except under this disclaimer.         *',&
'*                                                                      *',&
'************************************************************************',&
'                                                                        ',&
'************************************************************************',&
'*                                                                      *',&
'*  7. Limitation of Liability                                          *',&
'*  --------------------------                                          *',&
'*                                                                      *',&
'*  Under no circumstances and under no legal theory, whether tort      *',&
'*  (including negligence), contract, or otherwise, shall any           *',&
'*  Contributor, or anyone who distributes Covered Software as          *',&
'*  permitted above, be liable to You for any direct, indirect,         *',&
'*  special, incidental, or consequential damages of any character      *',&
'*  including, without limitation, damages for lost profits, loss of    *',&
'*  goodwill, work stoppage, computer failure or malfunction, or any    *',&
'*  and all other commercial damages or losses, even if such party      *',&
'*  shall have been informed of the possibility of such damages. This   *',&
'*  limitation of liability shall not apply to liability for death or   *',&
'*  personal injury resulting from such party''s negligence to the       *',&
'*  extent applicable law prohibits such limitation. Some               * ',&
'*  jurisdictions do not allow the exclusion or limitation of           * ',&
'*  incidental or consequential damages, so this exclusion and          * ',&
'*  limitation may not apply to You.                                    * ',&
'*                                                                      * ',&
'************************************************************************ ',&
'                                                                         ',&
'8. Litigation                                                            ',&
'-------------                                                            ',&
'                                                                         ',&
'Any litigation relating to this License may be brought only in the       ',&
'courts of a jurisdiction where the defendant maintains its principal     ',&
'place of business and such litigation shall be governed by laws of that  ',&
'jurisdiction, without reference to its conflict-of-law provisions.       ',&
'Nothing in this Section shall prevent a party''s ability to bring        ',&
'cross-claims or counter-claims.                                          ',&
'                                                                         ',&
'9. Miscellaneous                                                         ',&
'----------------                                                         ',&
'                                                                         ',&
'This License represents the complete agreement concerning the subject    ',&
'matter hereof. If any provision of this License is held to be            ',&
'unenforceable, such provision shall be reformed only to the extent       ',&
'necessary to make it enforceable. Any law or regulation which provides   ',&
'that the language of a contract shall be construed against the drafter   ',&
'shall not be used to construe this License against a Contributor.        ',&
'                                                                         ',&
'10. Versions of the License                                              ',&
'---------------------------                                              ',&
'                                                                         ',&
'10.1. New Versions                                                       ',&
'                                                                         ',&
'Mozilla Foundation is the license steward. Except as provided in Section ',&
'10.3, no one other than the license steward has the right to modify or   ',&
'publish new versions of this License. Each version will be given a       ',&
'distinguishing version number.                                           ',&
'                                                                         ',&
'10.2. Effect of New Versions                                             ',&
'                                                                         ',&
'You may distribute the Covered Software under the terms of the version   ',&
'of the License under which You originally received the Covered Software, ',&
'or under the terms of any subsequent version published by the license    ',&
'steward.                                                                 ',&
'                                                                         ',&
'10.3. Modified Versions                                                  ',&
'                                                                         ',&
'If you create software not governed by this License, and you want to     ',&
'create a new license for such software, you may create and use a         ',&
'modified version of this License if you rename the license and remove    ',&
'any references to the name of the license steward (except to note that   ',&
'such modified license differs from this License).                        ',&
'                                                                         ',&
'10.4. Distributing Source Code Form that is Incompatible With Secondary  ',&
'Licenses                                                                 ',&
'                                                                         ',&
'If You choose to distribute Source Code Form that is Incompatible With   ',&
'Secondary Licenses under the terms of this version of the License, the   ',&
'notice described in Exhibit B of this License must be attached.          ',&
'                                                                         ',&
'Exhibit A - Source Code Form License Notice                              ',&
'-------------------------------------------                              ',&
'                                                                         ',&
'  This Source Code Form is subject to the terms of the Mozilla Public    ',&
'  License, v. 2.0. If a copy of the MPL was not distributed with this    ',&
'  file, You can obtain one at http://mozilla.org/MPL/2.0/.               ',&
'                                                                         ',&
'If it is not possible or desirable to put the notice in a particular     ',&
'file, then You may include the notice in a location (such as a LICENSE   ',&
'file in a relevant directory) where a recipient would be likely to look  ',&
'for such a notice.                                                       ',&
'                                                                         ',&
'You may add additional accurate notices of copyright ownership.          ',&
'                                                                         ',&
'Exhibit B - "Incompatible With Secondary Licenses" Notice                ',&
'---------------------------------------------------------                ',&
'                                                                         ',&
'  This Source Code Form is "Incompatible With Secondary Licenses", as    ',&
'  defined by the Mozilla Public License, v. 2.0.                         ',&
'                                                                         ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('35','ms-pl')
textblock=[ CHARACTER(LEN=128) :: &
'ms-pl',&
'     ',&
'Microsoft Public License (Ms-PL)',&
'                                ',&
'This license governs use of the accompanying software. If you use the',&
'software, you accept this license. If you do not accept the license, do not',&
'use the software.                                                          ',&
'                                                                           ',&
'1.  Definitions                                                            ',&
'The terms "reproduce," "reproduction," "derivative works," and "distribution"',&
'have the same meaning here as under U.S. copyright law. A "contribution" is  ',&
'the original software, or any additions or changes to the software. A        ',&
'"contributor" is any person that distributes its contribution under this     ',&
'license. "Licensed patents" are a contributor''s patent claims that read     ',&
'directly on its contribution.                                                ',&
'                                                                             ',&
'2.  Grant of Rights                                                          ',&
'     (A) Copyright Grant- Subject to the terms of this license, including the',&
'     license conditions and limitations in section 3, each contributor grants',&
'     you a non-exclusive, worldwide, royalty-free copyright license to       ',&
'     reproduce its contribution, prepare derivative works of its contribution,',&
'     and distribute its contribution or any derivative works that you create. ',&
'                                                                              ',&
'     (B) Patent Grant- Subject to the terms of this license, including the    ',&
'     license conditions and limitations in section 3, each contributor grants ',&
'     you a non-exclusive, worldwide, royalty-free license under its licensed  ',&
'     patents to make, have made, use, sell, offer for sale, import, and/or    ',&
'     otherwise dispose of its contribution in the software or derivative works',&
'     of the contribution in the software.                                     ',&
'                                                                              ',&
'3.  Conditions and Limitations                                                ',&
'     (A) No Trademark License- This license does not grant you rights to use  ',&
'     any contributors'' name, logo, or trademarks.                            ',&
'                                                                              ',&
'     (B) If you bring a patent claim against any contributor over patents that',&
'     you claim are infringed by the software, your patent license from such   ',&
'     contributor to the software ends automatically.                          ',&
'                                                                              ',&
'     (C) If you distribute any portion of the software, you must retain all   ',&
'     copyright, patent, trademark, and attribution notices that are present in',&
'     the software.                                                            ',&
'                                                                              ',&
'     (D) If you distribute any portion of the software in source code form,   ',&
'     you may do so only under this license by including a complete copy of    ',&
'     this license with your distribution. If you distribute any portion of the',&
'     software in compiled or object code form, you may only do so under a     ',&
'     license that complies with this license.                                 ',&
'                                                                              ',&
'     (E) The software is licensed "as-is." You bear the risk of using it. The ',&
'     contributors give no express warranties, guarantees, or conditions. You  ',&
'     may have additional consumer rights under your local laws which this     ',&
'     license cannot change. To the extent permitted under your local laws, the',&
'     contributors exclude the implied warranties of merchantability, fitness  ',&
'     for a particular purpose and non-infringement.                           ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('36','ms-rl')
textblock=[ CHARACTER(LEN=128) :: &
'ms-rl',&
'     ',&
'Microsoft Reciprocal License (Ms-RL)',&
'                                    ',&
'This license governs use of the accompanying software. If you use the',&
'software, you accept this license. If you do not accept the license, do not',&
'use the software.                                                          ',&
'                                                                           ',&
'1.  Definitions                                                            ',&
'The terms "reproduce," "reproduction," "derivative works," and "distribution"',&
'have the same meaning here as under U.S. copyright law.                      ',&
'                                                                             ',&
'A "contribution" is the original software, or any additions or changes to the',&
'software.                                                                    ',&
'                                                                             ',&
'A "contributor" is any person that distributes its contribution under this   ',&
'license.                                                                     ',&
'                                                                             ',&
'"Licensed patents" are a contributor''s patent claims that read directly on its',&
'contribution.                                                                  ',&
'                                                                               ',&
'2.  Grant of Rights                                                            ',&
'     (A) Copyright Grant- Subject to the terms of this license, including the  ',&
'     license conditions and limitations in section 3, each contributor grants  ',&
'     you a non-exclusive, worldwide, royalty-free copyright license to         ',&
'     reproduce its contribution, prepare derivative works of its contribution, ',&
'     and distribute its contribution or any derivative works that you create.  ',&
'                                                                               ',&
'     (B) Patent Grant- Subject to the terms of this license, including the     ',&
'     license conditions and limitations in section 3, each contributor grants  ',&
'     you a non-exclusive, worldwide, royalty-free license under its licensed   ',&
'     patents to make, have made, use, sell, offer for sale, import, and/or     ',&
'     otherwise dispose of its contribution in the software or derivative works ',&
'     of the contribution in the software.                                      ',&
'                                                                               ',&
'3.  Conditions and Limitations                                                 ',&
'     (A) Reciprocal Grants- For any file you distribute that contains code     ',&
'     from the software (in source code or binary format), you must provide     ',&
'     recipients the source code to that file along with a copy of this         ',&
'     license, which license will govern that file. You may license other files ',&
'     that are entirely your own work and do not contain code from the software ',&
'     under any terms you choose.                                               ',&
'                                                                               ',&
'     (B) No Trademark License- This license does not grant you rights to use   ',&
'     any contributors'' name, logo, or trademarks.                             ',&
'                                                                               ',&
'     (C) If you bring a patent claim against any contributor over patents that ',&
'     you claim are infringed by the software, your patent license from such    ',&
'     contributor to the software ends automatically.                           ',&
'                                                                               ',&
'     (D) If you distribute any portion of the software, you must retain all    ',&
'     copyright, patent, trademark, and attribution notices that are present in ',&
'     the software.                                                             ',&
'                                                                               ',&
'     (E) If you distribute any portion of the software in source code form,    ',&
'     you may do so only under this license by including a complete copy of     ',&
'     this license with your distribution. If you distribute any portion of the ',&
'     software in compiled or object code form, you may only do so under a      ',&
'     license that complies with this license.                                  ',&
'                                                                               ',&
'     (F) The software is licensed "as-is." You bear the risk of using it. The  ',&
'     contributors give no express warranties, guarantees, or conditions. You   ',&
'     may have additional consumer rights under your local laws which this      ',&
'     license cannot change. To the extent permitted under your local laws, the ',&
'     contributors exclude the implied warranties of merchantability, fitness   ',&
'     for a particular purpose and non-infringement.                            ',&
'                                                                               ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('37','mulanpsl-2.0')
textblock=[ CHARACTER(LEN=128) :: &
'mulanpsl-2.0',&
'            ',&
', 2',&
'                              ',&
' 2',&
'                                ',&
'20201 http://license.coscl.org.cn/MulanPSL2',&
'                                                 ',&
'2',&
'                                                                                                                                ',&
'0.                                                                                                                        ',&
'                                                                                                                                ',&
'                    ',&
'                                                                                                                                ',&
'                       ',&
'                                                                                                                                ',&
'           ',&
'                                                                                                                                ',&
'                                                        ',&
'                                                                                                                                ',&
' ',&
'50%                          ',&
'                                                                                                                                ',&
'1.                                                                                                            ',&
'                                                                                                                                ',&
'',&
'                                                     ',&
'                                                                                                                                ',&
'2.                                                                                                            ',&
'                                                                                                                                ',&
'',&
'',&
'',&
'',&
'',&
'',&
'                                                                                                           ',&
'                                                                                                                                ',&
'3.                                                                                                               ',&
'                                                                                                                                ',&
'',&
'                                                                                         ',&
'                                                                                                                                ',&
'4.                                                                                                                  ',&
'                                                                                                                                ',&
'',&
'                                ',&
'                                                                                                                                ',&
'5.                                                                                                   ',&
'                                                                                                                                ',&
'',&
'',&
'                                                        ',&
'                                                                                                                                ',&
'6.                                                                                                                        ',&
'                                                                                                                                ',&
'',&
'                                                                                                                    ',&
'                                                                                                                                ',&
'                                                                                                                    ',&
'                                                                                                                                ',&
'2                                                                ',&
'                                                                                                                                ',&
'2',&
'                                                                                                                                ',&
'1    ',&
'                                                                                                                                ',&
'2 LICENSE  ',&
'                                                                                                                                ',&
'3                                                          ',&
'                                                                                                                                ',&
'Copyright (c) @YEAR@ [name of copyright holder]                                                                                 ',&
'[Software Name] is licensed under Mulan PSL v2.                                                                                 ',&
'You can use this software according to the terms and conditions of the Mulan                                                    ',&
'PSL v2.                                                                                                                         ',&
'You may obtain a copy of Mulan PSL v2 at:                                                                                       ',&
'         http://license.coscl.org.cn/MulanPSL2                                                                                  ',&
'THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY                                                        ',&
'KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO                                                                   ',&
'NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.                                                              ',&
'See the Mulan PSL v2 for more details.                                                                                          ',&
'                                                                                                                                ',&
'Mulan Permissive Software LicenseVersion 2                                                                                   ',&
'                                                                                                                                ',&
'Mulan Permissive Software LicenseVersion 2 (Mulan PSL v2)                                                                    ',&
'                                                                                                                                ',&
'January 2020 http://license.coscl.org.cn/MulanPSL2                                                                              ',&
'                                                                                                                                ',&
'Your reproduction, use, modification and distribution of the Software shall                                                     ',&
'be subject to Mulan PSL v2 (this License) with the following terms and                                                          ',&
'conditions:                                                                                                                     ',&
'                                                                                                                                ',&
'0. Definition                                                                                                                   ',&
'                                                                                                                                ',&
'Software means the program and related documents which are licensed under                                                       ',&
'this License and comprise all Contribution(s).                                                                                  ',&
'                                                                                                                                ',&
'Contribution means the copyrightable work licensed by a particular                                                              ',&
'Contributor under this License.                                                                                                 ',&
'                                                                                                                                ',&
'Contributor means the Individual or Legal Entity who licenses its                                                               ',&
'copyrightable work under this License.                                                                                          ',&
'                                                                                                                                ',&
'Legal Entity means the entity making a Contribution and all its                                                                 ',&
'Affiliates.                                                                                                                     ',&
'                                                                                                                                ',&
'Affiliates means entities that control, are controlled by, or are under                                                         ',&
'common control with the acting entity under this License, control means                                                   ',&
'direct or indirect ownership of at least fifty percent (50%) of the voting                                                      ',&
'power, capital or other securities of controlled or commonly controlled                                                         ',&
'entity.                                                                                                                         ',&
'                                                                                                                                ',&
'1. Grant of Copyright License                                                                                                   ',&
'                                                                                                                                ',&
'Subject to the terms and conditions of this License, each Contributor hereby                                                    ',&
'grants to you a perpetual, worldwide, royalty-free, non-exclusive,                                                              ',&
'irrevocable copyright license to reproduce, use, modify, or distribute its                                                      ',&
'Contribution, with modification or not.                                                                                         ',&
'                                                                                                                                ',&
'2. Grant of Patent License                                                                                                      ',&
'                                                                                                                                ',&
'Subject to the terms and conditions of this License, each Contributor hereby                                                    ',&
'grants to you a perpetual, worldwide, royalty-free, non-exclusive,                                                              ',&
'irrevocable (except for revocation under this Section) patent license to                                                        ',&
'make, have made, use, offer for sale, sell, import or otherwise transfer its                                                    ',&
'Contribution, where such patent license is only limited to the patent claims                                                    ',&
'owned or controlled by such Contributor now or in future which will be                                                          ',&
'necessarily infringed by its Contribution alone, or by combination of the                                                       ',&
'Contribution with the Software to which the Contribution was contributed.                                                       ',&
'The patent license shall not apply to any modification of the Contribution,                                                     ',&
'and any other combination which includes the Contribution. If you or your                                                       ',&
'Affiliates directly or indirectly institute patent litigation (including a                                                      ',&
'cross claim or counterclaim in a litigation) or other patent enforcement                                                        ',&
'activities against any individual or entity by alleging that the Software or                                                    ',&
'any Contribution in it infringes patents, then any patent license granted to                                                    ',&
'you under this License for the Software shall terminate as of the date such                                                     ',&
'litigation or activity is filed or taken.                                                                                       ',&
'                                                                                                                                ',&
'3. No Trademark License                                                                                                         ',&
'                                                                                                                                ',&
'No trademark license is granted to use the trade names, trademarks, service                                                     ',&
'marks, or product names of Contributor, except as required to fulfill notice                                                    ',&
'requirements in section 4.                                                                                                      ',&
'                                                                                                                                ',&
'4. Distribution Restriction                                                                                                     ',&
'                                                                                                                                ',&
'You may distribute the Software in any medium with or without modification,                                                     ',&
'whether in source or executable forms, provided that you provide recipients                                                     ',&
'with a copy of this License and retain copyright, patent, trademark and                                                         ',&
'disclaimer statements in the Software.                                                                                          ',&
'                                                                                                                                ',&
'5. Disclaimer of Warranty and Limitation of Liability                                                                           ',&
'                                                                                                                                ',&
'THE SOFTWARE AND CONTRIBUTION IN IT ARE PROVIDED WITHOUT WARRANTIES OF ANY                                                      ',&
'KIND, EITHER EXPRESS OR IMPLIED. IN NO EVENT SHALL ANY CONTRIBUTOR OR                                                           ',&
'COPYRIGHT HOLDER BE LIABLE TO YOU FOR ANY DAMAGES, INCLUDING, BUT NOT                                                           ',&
'LIMITED TO ANY DIRECT, OR INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING                                                    ',&
'FROM YOUR USE OR INABILITY TO USE THE SOFTWARE OR THE CONTRIBUTION IN IT, NO                                                    ',&
'MATTER HOW ITS CAUSED OR BASED ON WHICH LEGAL THEORY, EVEN IF ADVISED OF                                                     ',&
'THE POSSIBILITY OF SUCH DAMAGES.                                                                                                ',&
'                                                                                                                                ',&
'6. Language                                                                                                                     ',&
'                                                                                                                                ',&
'THIS LICENSE IS WRITTEN IN BOTH CHINESE AND ENGLISH, AND THE CHINESE VERSION                                                    ',&
'AND ENGLISH VERSION SHALL HAVE THE SAME LEGAL EFFECT. IN THE CASE OF                                                            ',&
'DIVERGENCE BETWEEN THE CHINESE AND ENGLISH VERSIONS, THE CHINESE VERSION                                                        ',&
'SHALL PREVAIL.                                                                                                                  ',&
'                                                                                                                                ',&
'END OF THE TERMS AND CONDITIONS                                                                                                 ',&
'                                                                                                                                ',&
'How to Apply the Mulan Permissive Software LicenseVersion 2                                                                  ',&
'(Mulan PSL v2) to Your Software                                                                                                 ',&
'                                                                                                                                ',&
'To apply the Mulan PSL v2 to your work, for easy identification by                                                              ',&
'recipients, you are suggested to complete following three steps:                                                                ',&
'                                                                                                                                ',&
'i. Fill in the blanks in following statement, including insert your software                                                    ',&
'name, the year of the first publication of your software, and your name                                                         ',&
'identified as the copyright owner;                                                                                              ',&
'ii. Create a file named "LICENSE" which contains the whole context of this                                                      ',&
'License in the first directory of your software package;                                                                        ',&
'iii. Attach the statement to the appropriate annotated syntax at the                                                            ',&
'beginning of each source file.                                                                                                  ',&
'                                                                                                                                ',&
'Copyright (c) @YEAR@ [name of copyright holder]                                                                                 ',&
'[Software Name] is licensed under Mulan PSL v2.                                                                                 ',&
'You can use this software according to the terms and conditions of the Mulan                                                    ',&
'PSL v2.                                                                                                                         ',&
'You may obtain a copy of Mulan PSL v2 at:                                                                                       ',&
'         http://license.coscl.org.cn/MulanPSL2                                                                                  ',&
'THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY                                                        ',&
'KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO                                                                   ',&
'NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.                                                              ',&
'See the Mulan PSL v2 for more details.                                                                                          ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('38','ncsa')
textblock=[ CHARACTER(LEN=128) :: &
'ncsa',&
'    ',&
'University of Illinois/NCSA Open Source License',&
'                                               ',&
'Copyright (c) @YEAR@ @FULLNAME@. All rights reserved.',&
'                                                     ',&
'Developed by: @PROJECT@                              ',&
'              @FULLNAME@                             ',&
'              [projecturl]                           ',&
'                                                     ',&
'Permission is hereby granted, free of charge, to any person',&
'obtaining a copy of this software and associated documentation files',&
'(the "Software"), to deal with the Software without restriction,    ',&
'including without limitation the rights to use, copy, modify, merge,',&
'publish, distribute, sublicense, and/or sell copies of the Software,',&
'and to permit persons to whom the Software is furnished to do so,   ',&
'subject to the following conditions:                                ',&
'                                                                    ',&
'* Redistributions of source code must retain the above copyright notice,',&
'  this list of conditions and the following disclaimers.                ',&
'                                                                        ',&
'* Redistributions in binary form must reproduce the above copyright     ',&
'  notice, this list of conditions and the following disclaimers in the  ',&
'  documentation and/or other materials provided with the distribution.  ',&
'                                                                        ',&
'* Neither the names of @FULLNAME@, @PROJECT@ nor the names of its       ',&
'  contributors may be used to endorse or promote products derived from  ',&
'  this Software without specific prior written permission.              ',&
'                                                                        ',&
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ',&
'OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,',&
'FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE',&
'CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER',&
'LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,',&
'OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH  ',&
'THE SOFTWARE.                                                                ',&
'                                                                             ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('39','odbl-1.0')
textblock=[ CHARACTER(LEN=128) :: &
'odbl-1.0',&
'        ',&
'## ODC Open Database License (ODbL)',&
'                                   ',&
'### Preamble                       ',&
'                                   ',&
'The Open Database License (ODbL) is a license agreement intended to',&
'allow users to freely share, modify, and use this Database while   ',&
'maintaining this same freedom for others. Many databases are covered by',&
'copyright, and therefore this document licenses these rights. Some     ',&
'jurisdictions, mainly in the European Union, have specific rights that ',&
'cover databases, and so the ODbL addresses these rights, too. Finally, ',&
'the ODbL is also an agreement in contract for users of this Database to',&
'act in certain ways in return for accessing this Database.             ',&
'                                                                       ',&
'Databases can contain a wide variety of types of content (images,      ',&
'audiovisual material, and sounds all in the same database, for example),',&
'and so the ODbL only governs the rights over the Database, and not the  ',&
'contents of the Database individually. Licensors should use the ODbL    ',&
'together with another license for the contents, if the contents have a  ',&
'single set of rights that uniformly covers all of the contents. If the  ',&
'contents have multiple sets of different rights, Licensors should       ',&
'describe what rights govern what contents together in the individual    ',&
'record or in some other way that clarifies what rights apply.           ',&
'                                                                        ',&
'Sometimes the contents of a database, or the database itself, can be    ',&
'covered by other rights not addressed here (such as private contracts,  ',&
'trade mark over the name, or privacy rights / data protection rights    ',&
'over information in the contents), and so you are advised that you may  ',&
'have to consult other documents or clear other rights before doing      ',&
'activities not covered by this License.                                 ',&
'                                                                        ',&
'------                                                                  ',&
'                                                                        ',&
'The Licensor (as defined below)                                         ',&
'                                                                        ',&
'and                                                                     ',&
'                                                                        ',&
'You (as defined below)                                                  ',&
'                                                                        ',&
'agree as follows:                                                       ',&
'                                                                        ',&
'### 1.0 Definitions of Capitalised Words                                ',&
'                                                                        ',&
'"Collective Database"  Means this Database in unmodified form as part',&
'of a collection of independent databases in themselves that together are',&
'assembled into a collective whole. A work that constitutes a Collective ',&
'Database will not be considered a Derivative Database.                  ',&
'                                                                        ',&
'"Convey"  As a verb, means Using the Database, a Derivative Database,',&
'or the Database as part of a Collective Database in any way that enables',&
'a Person to make or receive copies of the Database or a Derivative      ',&
'Database.  Conveying does not include interaction with a user through a ',&
'computer network, or creating and Using a Produced Work, where no       ',&
'transfer of a copy of the Database or a Derivative Database occurs.     ',&
'"Contents"  The contents of this Database, which includes the        ',&
'information, independent works, or other material collected into the    ',&
'Database. For example, the contents of the Database could be factual    ',&
'data or works such as images, audiovisual material, text, or sounds.    ',&
'                                                                        ',&
'"Database"  A collection of material (the Contents) arranged in a    ',&
'systematic or methodical way and individually accessible by electronic  ',&
'or other means offered under the terms of this License.                 ',&
'                                                                        ',&
'"Database Directive"  Means Directive 96/9/EC of the European        ',&
'Parliament and of the Council of 11 March 1996 on the legal protection  ',&
'of databases, as amended or succeeded.                                  ',&
'                                                                        ',&
'"Database Right"  Means rights resulting from the Chapter III ("sui  ',&
'generis") rights in the Database Directive (as amended and as transposed',&
'by member states), which includes the Extraction and Re-utilisation of  ',&
'the whole or a Substantial part of the Contents, as well as any similar ',&
'rights available in the relevant jurisdiction under Section 10.4.       ',&
'                                                                        ',&
'"Derivative Database"  Means a database based upon the Database, and ',&
'includes any translation, adaptation, arrangement, modification, or any ',&
'other alteration of the Database or of a Substantial part of the        ',&
'Contents. This includes, but is not limited to, Extracting or           ',&
'Re-utilising the whole or a Substantial part of the Contents in a new   ',&
'Database.                                                               ',&
'                                                                        ',&
'"Extraction"  Means the permanent or temporary transfer of all or a  ',&
'Substantial part of the Contents to another medium by any means or in   ',&
'any form.                                                               ',&
'                                                                        ',&
'"License"  Means this license agreement and is both a license of rights',&
'such as copyright and Database Rights and an agreement in contract.       ',&
'                                                                          ',&
'"Licensor"  Means the Person that offers the Database under the terms  ',&
'of this License.                                                          ',&
'                                                                          ',&
'"Person"  Means a natural or legal person or a body of persons         ',&
'corporate or incorporate.                                                 ',&
'                                                                          ',&
'"Produced Work"   a work (such as an image, audiovisual material, text,',&
'or sounds) resulting from using the whole or a Substantial part of the    ',&
'Contents (via a search or other query) from this Database, a Derivative   ',&
'Database, or this Database as part of a Collective Database.              ',&
'                                                                          ',&
'"Publicly"  means to Persons other than You or under Your control by   ',&
'either more than 50% ownership or by the power to direct their            ',&
'activities (such as contracting with an independent consultant).          ',&
'                                                                          ',&
'"Re-utilisation"  means any form of making available to the public all ',&
'or a Substantial part of the Contents by the distribution of copies, by   ',&
'renting, by online or other forms of transmission.                        ',&
'                                                                          ',&
'"Substantial"  Means substantial in terms of quantity or quality or a  ',&
'combination of both. The repeated and systematic Extraction or            ',&
'Re-utilisation of insubstantial parts of the Contents may amount to the   ',&
'Extraction or Re-utilisation of a Substantial part of the Contents.       ',&
'                                                                          ',&
'"Use"  As a verb, means doing any act that is restricted by copyright  ',&
'or Database Rights whether in the original medium or any other; and       ',&
'includes without limitation distributing, copying, publicly performing,   ',&
'publicly displaying, and preparing derivative works of the Database, as   ',&
'well as modifying the Database as may be technically necessary to use it  ',&
'in a different mode or format.                                            ',&
'                                                                          ',&
'"You"  Means a Person exercising rights under this License who has not ',&
'previously violated the terms of this License with respect to the         ',&
'Database, or who has received express permission from the Licensor to     ',&
'exercise rights under this License despite a previous violation.          ',&
'                                                                          ',&
'Words in the singular include the plural and vice versa.                  ',&
'                                                                          ',&
'### 2.0 What this License covers                                          ',&
'                                                                          ',&
'2.1. Legal effect of this document. This License is:                      ',&
'                                                                          ',&
'  a. A license of applicable copyright and neighbouring rights;           ',&
'                                                                          ',&
'  b. A license of the Database Right; and                                 ',&
'                                                                          ',&
'  c. An agreement in contract between You and the Licensor.               ',&
'                                                                          ',&
'2.2 Legal rights covered. This License covers the legal rights in the     ',&
'Database, including:                                                      ',&
'                                                                          ',&
'  a. Copyright. Any copyright or neighbouring rights in the Database.     ',&
'  The copyright licensed includes any individual elements of the          ',&
'  Database, but does not cover the copyright over the Contents            ',&
'  independent of this Database. See Section 2.4 for details. Copyright    ',&
'  law varies between jurisdictions, but is likely to cover: the Database  ',&
'  model or schema, which is the structure, arrangement, and organisation  ',&
'  of the Database, and can also include the Database tables and table     ',&
'  indexes; the data entry and output sheets; and the Field names of       ',&
'  Contents stored in the Database;                                        ',&
'                                                                          ',&
'  b. Database Rights. Database Rights only extend to the Extraction and   ',&
'  Re-utilisation of the whole or a Substantial part of the Contents.      ',&
'  Database Rights can apply even when there is no copyright over the      ',&
'  Database. Database Rights can also apply when the Contents are removed  ',&
'  from the Database and are selected and arranged in a way that would     ',&
'  not infringe any applicable copyright; and                              ',&
'                                                                          ',&
'  c. Contract. This is an agreement between You and the Licensor for      ',&
'  access to the Database. In return you agree to certain conditions of    ',&
'  use on this access as outlined in this License.                         ',&
'                                                                          ',&
'2.3 Rights not covered.                                                   ',&
'                                                                          ',&
'  a. This License does not apply to computer programs used in the making  ',&
'  or operation of the Database;                                           ',&
'                                                                          ',&
'  b. This License does not cover any patents over the Contents or the     ',&
'  Database; and                                                           ',&
'                                                                          ',&
'  c. This License does not cover any trademarks associated with the       ',&
'  Database.                                                               ',&
'                                                                          ',&
'2.4 Relationship to Contents in the Database. The individual items of     ',&
'the Contents contained in this Database may be covered by other rights,   ',&
'including copyright, patent, data protection, privacy, or personality     ',&
'rights, and this License does not cover any rights (other than Database   ',&
'Rights or in contract) in individual Contents contained in the Database.  ',&
'For example, if used on a Database of images (the Contents), this         ',&
'License would not apply to copyright over individual images, which could  ',&
'have their own separate licenses, or one single license covering all of   ',&
'the rights over the images.                                               ',&
'                                                                          ',&
'### 3.0 Rights granted                                                    ',&
'                                                                          ',&
'3.1 Subject to the terms and conditions of this License, the Licensor     ',&
'grants to You a worldwide, royalty-free, non-exclusive, terminable (but   ',&
'only under Section 9) license to Use the Database for the duration of     ',&
'any applicable copyright and Database Rights. These rights explicitly     ',&
'include commercial use, and do not exclude any field of endeavour. To     ',&
'the extent possible in the relevant jurisdiction, these rights may be     ',&
'exercised in all media and formats whether now known or created in the    ',&
'future.                                                                   ',&
'                                                                          ',&
'The rights granted cover, for example:                                    ',&
'                                                                          ',&
'  a. Extraction and Re-utilisation of the whole or a Substantial part of  ',&
'  the Contents;                                                           ',&
'                                                                          ',&
'  b. Creation of Derivative Databases;                                    ',&
'                                                                          ',&
'  c. Creation of Collective Databases;                                    ',&
'                                                                          ',&
'  d. Creation of temporary or permanent reproductions by any means and    ',&
'  in any form, in whole or in part, including of any Derivative           ',&
'  Databases or as a part of Collective Databases; and                     ',&
'                                                                          ',&
'  e. Distribution, communication, display, lending, making available, or  ',&
'  performance to the public by any means and in any form, in whole or in  ',&
'  part, including of any Derivative Database or as a part of Collective   ',&
'  Databases.                                                              ',&
'                                                                          ',&
'3.2 Compulsory license schemes. For the avoidance of doubt:               ',&
'                                                                          ',&
'  a. Non-waivable compulsory license schemes. In those jurisdictions in   ',&
'  which the right to collect royalties through any statutory or           ',&
'  compulsory licensing scheme cannot be waived, the Licensor reserves     ',&
'  the exclusive right to collect such royalties for any exercise by You   ',&
'  of the rights granted under this License;                               ',&
'                                                                          ',&
'  b. Waivable compulsory license schemes. In those jurisdictions in       ',&
'  which the right to collect royalties through any statutory or           ',&
'  compulsory licensing scheme can be waived, the Licensor waives the      ',&
'  exclusive right to collect such royalties for any exercise by You of    ',&
'  the rights granted under this License; and,                             ',&
'                                                                          ',&
'  c. Voluntary license schemes. The Licensor waives the right to collect  ',&
'  royalties, whether individually or, in the event that the Licensor is   ',&
'  a member of a collecting society that administers voluntary licensing   ',&
'  schemes, via that society, from any exercise by You of the rights       ',&
'  granted under this License.                                             ',&
'                                                                          ',&
'3.3 The right to release the Database under different terms, or to stop   ',&
'distributing or making available the Database, is reserved. Note that     ',&
'this Database may be multiple-licensed, and so You may have the choice    ',&
'of using alternative licenses for this Database. Subject to Section       ',&
'10.4, all other rights not expressly granted by Licensor are reserved.    ',&
'                                                                          ',&
'### 4.0 Conditions of Use                                                 ',&
'                                                                          ',&
'4.1 The rights granted in Section 3 above are expressly made subject to   ',&
'Your complying with the following conditions of use. These are important  ',&
'conditions of this License, and if You fail to follow them, You will be   ',&
'in material breach of its terms.                                          ',&
'                                                                          ',&
'4.2 Notices. If You Publicly Convey this Database, any Derivative         ',&
'Database, or the Database as part of a Collective Database, then You      ',&
'must:                                                                     ',&
'                                                                          ',&
'  a. Do so only under the terms of this License or another license        ',&
'  permitted under Section 4.4;                                            ',&
'                                                                          ',&
'  b. Include a copy of this License (or, as applicable, a license         ',&
'  permitted under Section 4.4) or its Uniform Resource Identifier (URI)   ',&
'  with the Database or Derivative Database, including both in the         ',&
'  Database or Derivative Database and in any relevant documentation; and  ',&
'                                                                          ',&
'  c. Keep intact any copyright or Database Right notices and notices      ',&
'  that refer to this License.                                             ',&
'                                                                          ',&
'  d. If it is not possible to put the required notices in a particular    ',&
'  file due to its structure, then You must include the notices in a       ',&
'  location (such as a relevant directory) where users would be likely to  ',&
'  look for it.                                                            ',&
'                                                                          ',&
'4.3 Notice for using output (Contents). Creating and Using a Produced     ',&
'Work does not require the notice in Section 4.2. However, if you          ',&
'Publicly Use a Produced Work, You must include a notice associated with   ',&
'the Produced Work reasonably calculated to make any Person that uses,     ',&
'views, accesses, interacts with, or is otherwise exposed to the Produced  ',&
'Work aware that Content was obtained from the Database, Derivative        ',&
'Database, or the Database as part of a Collective Database, and that it   ',&
'is available under this License.                                          ',&
'                                                                          ',&
'  a. Example notice. The following text will satisfy notice under         ',&
'  Section 4.3:                                                            ',&
'                                                                          ',&
'        Contains information from DATABASE NAME, which is made available  ',&
'        here under the Open Database License (ODbL).                      ',&
'                                                                          ',&
'DATABASE NAME should be replaced with the name of the Database and a      ',&
'hyperlink to the URI of the Database. "Open Database License" should      ',&
'contain a hyperlink to the URI of the text of this License. If            ',&
'hyperlinks are not possible, You should include the plain text of the     ',&
'required URI''s with the above notice.                                    ',&
'                                                                          ',&
'4.4 Share alike.                                                          ',&
'                                                                          ',&
'  a. Any Derivative Database that You Publicly Use must be only under     ',&
'  the terms of:                                                           ',&
'                                                                          ',&
'    i. This License;                                                      ',&
'                                                                          ',&
'    ii. A later version of this License similar in spirit to this         ',&
'      License; or                                                         ',&
'                                                                          ',&
'    iii. A compatible license.                                            ',&
'                                                                          ',&
'  If You license the Derivative Database under one of the licenses        ',&
'  mentioned in (iii), You must comply with the terms of that license.     ',&
'                                                                          ',&
'  b. For the avoidance of doubt, Extraction or Re-utilisation of the      ',&
'  whole or a Substantial part of the Contents into a new database is a    ',&
'  Derivative Database and must comply with Section 4.4.                   ',&
'                                                                          ',&
'  c. Derivative Databases and Produced Works.  A Derivative Database is   ',&
'  Publicly Used and so must comply with Section 4.4. if a Produced Work   ',&
'  created from the Derivative Database is Publicly Used.                  ',&
'                                                                          ',&
'  d. Share Alike and additional Contents. For the avoidance of doubt,     ',&
'  You must not add Contents to Derivative Databases under Section 4.4 a   ',&
'  that are incompatible with the rights granted under this License.       ',&
'                                                                          ',&
'  e. Compatible licenses. Licensors may authorise a proxy to determine    ',&
'  compatible licenses under Section 4.4 a iii. If they do so, the         ',&
'  authorised proxy''s public statement of acceptance of a compatible      ',&
'  license grants You permission to use the compatible license.            ',&
'                                                                          ',&
'                                                                          ',&
'4.5 Limits of Share Alike.  The requirements of Section 4.4 do not apply  ',&
'in the following:                                                         ',&
'                                                                          ',&
'  a. For the avoidance of doubt, You are not required to license          ',&
'  Collective Databases under this License if You incorporate this         ',&
'  Database or a Derivative Database in the collection, but this License   ',&
'  still applies to this Database or a Derivative Database as a part of    ',&
'  the Collective Database;                                                ',&
'                                                                          ',&
'  b. Using this Database, a Derivative Database, or this Database as      ',&
'  part of a Collective Database to create a Produced Work does not        ',&
'  create a Derivative Database for purposes of  Section 4.4; and          ',&
'                                                                          ',&
'  c. Use of a Derivative Database internally within an organisation is    ',&
'  not to the public and therefore does not fall under the requirements    ',&
'  of Section 4.4.                                                         ',&
'                                                                          ',&
'4.6 Access to Derivative Databases. If You Publicly Use a Derivative      ',&
'Database or a Produced Work from a Derivative Database, You must also     ',&
'offer to recipients of the Derivative Database or Produced Work a copy    ',&
'in a machine readable form of:                                            ',&
'                                                                          ',&
'  a. The entire Derivative Database; or                                   ',&
'                                                                          ',&
'  b. A file containing all of the alterations made to the Database or     ',&
'  the method of making the alterations to the Database (such as an        ',&
'  algorithm), including any additional Contents, that make up all the     ',&
'  differences between the Database and the Derivative Database.           ',&
'                                                                          ',&
'The Derivative Database (under a.) or alteration file (under b.) must be  ',&
'available at no more than a reasonable production cost for physical       ',&
'distributions and free of charge if distributed over the internet.        ',&
'                                                                          ',&
'4.7 Technological measures and additional terms                           ',&
'                                                                          ',&
'  a. This License does not allow You to impose (except subject to         ',&
'  Section 4.7 b.)  any terms or any technological measures on the         ',&
'  Database, a Derivative Database, or the whole or a Substantial part of  ',&
'  the Contents that alter or restrict the terms of this License, or any   ',&
'  rights granted under it, or have the effect or intent of restricting    ',&
'  the ability of any person to exercise those rights.                     ',&
'                                                                          ',&
'  b. Parallel distribution. You may impose terms or technological         ',&
'  measures on the Database, a Derivative Database, or the whole or a      ',&
'  Substantial part of the Contents (a "Restricted Database") in           ',&
'  contravention of Section 4.74 a. only if You also make a copy of the    ',&
'  Database or a Derivative Database available to the recipient of the     ',&
'  Restricted Database:                                                    ',&
'                                                                          ',&
'    i. That is available without additional fee;                          ',&
'                                                                          ',&
'    ii. That is available in a medium that does not alter or restrict     ',&
'    the terms of this License, or any rights granted under it, or have    ',&
'    the effect or intent of restricting the ability of any person to      ',&
'    exercise those rights (an "Unrestricted Database"); and               ',&
'                                                                          ',&
'    iii. The Unrestricted Database is at least as accessible to the       ',&
'    recipient as a practical matter as the Restricted Database.           ',&
'                                                                          ',&
'  c. For the avoidance of doubt, You may place this Database or a         ',&
'  Derivative Database in an authenticated environment, behind a           ',&
'  password, or within a similar access control scheme provided that You   ',&
'  do not alter or restrict the terms of this License or any rights        ',&
'  granted under it or have the effect or intent of restricting the        ',&
'  ability of any person to exercise those rights.                         ',&
'                                                                          ',&
'4.8 Licensing of others. You may not sublicense the Database. Each time   ',&
'You communicate the Database, the whole or Substantial part of the        ',&
'Contents, or any Derivative Database to anyone else in any way, the       ',&
'Licensor offers to the recipient a license to the Database on the same    ',&
'terms and conditions as this License. You are not responsible for         ',&
'enforcing compliance by third parties with this License, but You may      ',&
'enforce any rights that You have over a Derivative Database. You are      ',&
'solely responsible for any modifications of a Derivative Database made    ',&
'by You or another Person at Your direction. You may not impose any        ',&
'further restrictions on the exercise of the rights granted or affirmed    ',&
'under this License.                                                       ',&
'                                                                          ',&
'### 5.0 Moral rights                                                      ',&
'                                                                          ',&
'5.1 Moral rights. This section covers moral rights, including any rights  ',&
'to be identified as the author of the Database or to object to treatment  ',&
'that would otherwise prejudice the author''s honour and reputation, or    ',&
'any other derogatory treatment:                                           ',&
'                                                                          ',&
'  a. For jurisdictions allowing waiver of moral rights, Licensor waives   ',&
'  all moral rights that Licensor may have in the Database to the fullest  ',&
'  extent possible by the law of the relevant jurisdiction under Section   ',&
'  10.4;                                                                   ',&
'                                                                          ',&
'  b. If waiver of moral rights under Section 5.1 a in the relevant        ',&
'  jurisdiction is not possible, Licensor agrees not to assert any moral   ',&
'  rights over the Database and waives all claims in moral rights to the   ',&
'  fullest extent possible by the law of the relevant jurisdiction under   ',&
'  Section 10.4; and                                                       ',&
'                                                                          ',&
'  c. For jurisdictions not allowing waiver or an agreement not to assert  ',&
'  moral rights under Section 5.1 a and b, the author may retain their     ',&
'  moral rights over certain aspects of the Database.                      ',&
'                                                                          ',&
'Please note that some jurisdictions do not allow for the waiver of moral  ',&
'rights, and so moral rights may still subsist over the Database in some   ',&
'jurisdictions.                                                            ',&
'                                                                          ',&
'### 6.0 Fair dealing, Database exceptions, and other rights not affected  ',&
'                                                                          ',&
'6.1 This License does not affect any rights that You or anyone else may   ',&
'independently have under any applicable law to make any use of this       ',&
'Database, including without limitation:                                   ',&
'                                                                          ',&
'  a. Exceptions to the Database Right including: Extraction of Contents   ',&
'  from non-electronic Databases for private purposes, Extraction for      ',&
'  purposes of illustration for teaching or scientific research, and       ',&
'  Extraction or Re-utilisation for public security or an administrative   ',&
'  or judicial procedure.                                                  ',&
'                                                                          ',&
'  b. Fair dealing, fair use, or any other legally recognised limitation   ',&
'  or exception to infringement of copyright or other applicable laws.     ',&
'                                                                          ',&
'6.2 This License does not affect any rights of lawful users to Extract    ',&
'and Re-utilise insubstantial parts of the Contents, evaluated             ',&
'quantitatively or qualitatively, for any purposes whatsoever, including   ',&
'creating a Derivative Database (subject to other rights over the          ',&
'Contents, see Section 2.4). The repeated and systematic Extraction or     ',&
'Re-utilisation of insubstantial parts of the Contents may however amount  ',&
'to the Extraction or Re-utilisation of a Substantial part of the          ',&
'Contents.                                                                 ',&
'                                                                          ',&
'### 7.0 Warranties and Disclaimer                                         ',&
'                                                                          ',&
'7.1 The Database is licensed by the Licensor "as is" and without any      ',&
'warranty of any kind, either express, implied, or arising by statute,     ',&
'custom, course of dealing, or trade usage. Licensor specifically          ',&
'disclaims any and all implied warranties or conditions of title,          ',&
'non-infringement, accuracy or completeness, the presence or absence of    ',&
'errors, fitness for a particular purpose, merchantability, or otherwise.  ',&
'Some jurisdictions do not allow the exclusion of implied warranties, so   ',&
'this exclusion may not apply to You.                                      ',&
'                                                                          ',&
'### 8.0 Limitation of liability                                           ',&
'                                                                          ',&
'8.1 Subject to any liability that may not be excluded or limited by law,  ',&
'the Licensor is not liable for, and expressly excludes, all liability     ',&
'for loss or damage however and whenever caused to anyone by any use       ',&
'under this License, whether by You or by anyone else, and whether caused  ',&
'by any fault on the part of the Licensor or not. This exclusion of        ',&
'liability includes, but is not limited to, any special, incidental,       ',&
'consequential, punitive, or exemplary damages such as loss of revenue,    ',&
'data, anticipated profits, and lost business. This exclusion applies      ',&
'even if the Licensor has been advised of the possibility of such          ',&
'damages.                                                                  ',&
'                                                                          ',&
'8.2 If liability may not be excluded by law, it is limited to actual and  ',&
'direct financial loss to the extent it is caused by proved negligence on  ',&
'the part of the Licensor.                                                 ',&
'                                                                          ',&
'### 9.0 Termination of Your rights under this License                     ',&
'                                                                          ',&
'9.1 Any breach by You of the terms and conditions of this License         ',&
'automatically terminates this License with immediate effect and without   ',&
'notice to You. For the avoidance of doubt, Persons who have received the  ',&
'Database, the whole or a Substantial part of the Contents, Derivative     ',&
'Databases, or the Database as part of a Collective Database from You      ',&
'under this License will not have their licenses terminated provided       ',&
'their use is in full compliance with this License or a license granted    ',&
'under Section 4.8 of this License.  Sections 1, 2, 7, 8, 9 and 10 will    ',&
'survive any termination of this License.                                  ',&
'                                                                          ',&
'9.2 If You are not in breach of the terms of this License, the Licensor   ',&
'will not terminate Your rights under it.                                  ',&
'                                                                          ',&
'9.3 Unless terminated under Section 9.1, this License is granted to You   ',&
'for the duration of applicable rights in the Database.                    ',&
'                                                                          ',&
'9.4 Reinstatement of rights. If you cease any breach of the terms and     ',&
'conditions of this License, then your full rights under this License      ',&
'will be reinstated:                                                       ',&
'                                                                          ',&
'  a. Provisionally and subject to permanent termination until the 60th    ',&
'  day after cessation of breach;                                          ',&
'                                                                          ',&
'  b. Permanently on the 60th day after cessation of breach unless         ',&
'  otherwise reasonably notified by the Licensor; or                       ',&
'                                                                          ',&
'  c.  Permanently if reasonably notified by the Licensor of the           ',&
'  violation, this is the first time You have received notice of           ',&
'  violation of this License from  the Licensor, and You cure the          ',&
'  violation prior to 30 days after your receipt of the notice.            ',&
'                                                                          ',&
'Persons subject to permanent termination of rights are not eligible to    ',&
'be a recipient and receive a license under Section 4.8.                   ',&
'                                                                          ',&
'9.5 Notwithstanding the above, Licensor reserves the right to release     ',&
'the Database under different license terms or to stop distributing or     ',&
'making available the Database. Releasing the Database under different     ',&
'license terms or stopping the distribution of the Database will not       ',&
'withdraw this License (or any other license that has been, or is          ',&
'required to be, granted under the terms of this License), and this        ',&
'License will continue in full force and effect unless terminated as       ',&
'stated above.                                                             ',&
'                                                                          ',&
'### 10.0 General                                                          ',&
'                                                                          ',&
'10.1 If any provision of this License is held to be invalid or            ',&
'unenforceable, that must not affect the validity or enforceability of     ',&
'the remainder of the terms and conditions of this License and each        ',&
'remaining provision of this License shall be valid and enforced to the    ',&
'fullest extent permitted by law.                                          ',&
'                                                                          ',&
'10.2 This License is the entire agreement between the parties with        ',&
'respect to the rights granted here over the Database. It replaces any     ',&
'earlier understandings, agreements or representations with respect to     ',&
'the Database.                                                             ',&
'                                                                          ',&
'10.3 If You are in breach of the terms of this License, You will not be   ',&
'entitled to rely on the terms of this License or to complain of any       ',&
'breach by the Licensor.                                                   ',&
'                                                                          ',&
'10.4 Choice of law. This License takes effect in and will be governed by  ',&
'the laws of the relevant jurisdiction in which the License terms are      ',&
'sought to be enforced. If the standard suite of rights granted under      ',&
'applicable copyright law and Database Rights in the relevant              ',&
'jurisdiction includes additional rights not granted under this License,   ',&
'these additional rights are granted in this License in order to meet the  ',&
'terms of this License.                                                    ',&
'                                                                          ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('40','ofl-1.1')
textblock=[ CHARACTER(LEN=128) :: &
'ofl-1.1',&
'       ',&
'       ',&
'Copyright (c) @YEAR@ @FULLNAME@ (@EMAIL@)',&
'                                         ',&
'This Font Software is licensed under the SIL Open Font License, Version 1.1.',&
'This license is copied below, and is also available with a FAQ at:          ',&
'http://scripts.sil.org/OFL                                                  ',&
'                                                                            ',&
'-----------------------------------------------------------                 ',&
'SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007                        ',&
'-----------------------------------------------------------                 ',&
'                                                                            ',&
'PREAMBLE                                                                    ',&
'The goals of the Open Font License (OFL) are to stimulate worldwide         ',&
'development of collaborative font projects, to support the font creation    ',&
'efforts of academic and linguistic communities, and to provide a free and   ',&
'open framework in which fonts may be shared and improved in partnership     ',&
'with others.                                                                ',&
'                                                                            ',&
'The OFL allows the licensed fonts to be used, studied, modified and         ',&
'redistributed freely as long as they are not sold by themselves. The        ',&
'fonts, including any derivative works, can be bundled, embedded,            ',&
'redistributed and/or sold with any software provided that any reserved      ',&
'names are not used by derivative works. The fonts and derivatives,          ',&
'however, cannot be released under any other type of license. The            ',&
'requirement for fonts to remain under this license does not apply           ',&
'to any document created using the fonts or their derivatives.               ',&
'                                                                            ',&
'DEFINITIONS                                                                 ',&
'"Font Software" refers to the set of files released by the Copyright        ',&
'Holder(s) under this license and clearly marked as such. This may           ',&
'include source files, build scripts and documentation.                      ',&
'                                                                            ',&
'"Reserved Font Name" refers to any names specified as such after the        ',&
'copyright statement(s).                                                     ',&
'                                                                            ',&
'"Original Version" refers to the collection of Font Software components as  ',&
'distributed by the Copyright Holder(s).                                     ',&
'                                                                            ',&
'"Modified Version" refers to any derivative made by adding to, deleting,    ',&
'or substituting -- in part or in whole -- any of the components of the      ',&
'Original Version, by changing formats or by porting the Font Software to a  ',&
'new environment.                                                            ',&
'                                                                            ',&
'"Author" refers to any designer, engineer, programmer, technical            ',&
'writer or other person who contributed to the Font Software.                ',&
'                                                                            ',&
'PERMISSION AND CONDITIONS                                                   ',&
'Permission is hereby granted, free of charge, to any person obtaining       ',&
'a copy of the Font Software, to use, study, copy, merge, embed, modify,     ',&
'redistribute, and sell modified and unmodified copies of the Font           ',&
'Software, subject to the following conditions:                              ',&
'                                                                            ',&
'1) Neither the Font Software nor any of its individual components,          ',&
'in Original or Modified Versions, may be sold by itself.                    ',&
'                                                                            ',&
'2) Original or Modified Versions of the Font Software may be bundled,       ',&
'redistributed and/or sold with any software, provided that each copy        ',&
'contains the above copyright notice and this license. These can be          ',&
'included either as stand-alone text files, human-readable headers or        ',&
'in the appropriate machine-readable metadata fields within text or          ',&
'binary files as long as those fields can be easily viewed by the user.      ',&
'                                                                            ',&
'3) No Modified Version of the Font Software may use the Reserved Font       ',&
'Name(s) unless explicit written permission is granted by the corresponding  ',&
'Copyright Holder. This restriction only applies to the primary font name as ',&
'presented to the users.                                                     ',&
'                                                                            ',&
'4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font      ',&
'Software shall not be used to promote, endorse or advertise any             ',&
'Modified Version, except to acknowledge the contribution(s) of the          ',&
'Copyright Holder(s) and the Author(s) or with their explicit written        ',&
'permission.                                                                 ',&
'                                                                            ',&
'5) The Font Software, modified or unmodified, in part or in whole,          ',&
'must be distributed entirely under this license, and must not be            ',&
'distributed under any other license. The requirement for fonts to           ',&
'remain under this license does not apply to any document created            ',&
'using the Font Software.                                                    ',&
'                                                                            ',&
'TERMINATION                                                                 ',&
'This license becomes null and void if any of the above conditions are       ',&
'not met.                                                                    ',&
'                                                                            ',&
'DISCLAIMER                                                                  ',&
'THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        ',&
'EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF          ',&
'MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT       ',&
'OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE      ',&
'COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,       ',&
'INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL      ',&
'DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING       ',&
'FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM          ',&
'OTHER DEALINGS IN THE FONT SOFTWARE.                                        ',&
'                                                                            ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('41','osl-3.0')
textblock=[ CHARACTER(LEN=128) :: &
'osl-3.0',&
'       ',&
'Open Software License ("OSL") v. 3.0',&
'                                    ',&
'This Open Software License (the "License") applies to any original work of',&
'authorship (the "Original Work") whose owner (the "Licensor") has placed the',&
'following licensing notice adjacent to the copyright notice for the Original',&
'Work:                                                                       ',&
'                                                                            ',&
'  Licensed under the Open Software License version 3.0                      ',&
'                                                                            ',&
'1) Grant of Copyright License. Licensor grants You a worldwide, royalty-free,',&
'non-exclusive, sublicensable license, for the duration of the copyright, to do',&
'the following:                                                                ',&
'                                                                              ',&
'  a) to reproduce the Original Work in copies, either alone or as part of a   ',&
'  collective work;                                                            ',&
'                                                                              ',&
'  b) to translate, adapt, alter, transform, modify, or arrange the Original   ',&
'  Work, thereby creating derivative works ("Derivative Works") based upon the ',&
'  Original Work;                                                              ',&
'                                                                              ',&
'  c) to distribute or communicate copies of the Original Work and Derivative  ',&
'  Works to the public, with the proviso that copies of Original Work or       ',&
'  Derivative Works that You distribute or communicate shall be licensed under ',&
'  this Open Software License;                                                 ',&
'                                                                              ',&
'  d) to perform the Original Work publicly; and                               ',&
'                                                                              ',&
'  e) to display the Original Work publicly.                                   ',&
'                                                                              ',&
'2) Grant of Patent License. Licensor grants You a worldwide, royalty-free,    ',&
'non-exclusive, sublicensable license, under patent claims owned or controlled ',&
'by the Licensor that are embodied in the Original Work as furnished by the    ',&
'Licensor, for the duration of the patents, to make, use, sell, offer for sale,',&
'have made, and import the Original Work and Derivative Works.                 ',&
'                                                                              ',&
'3) Grant of Source Code License. The term "Source Code" means the preferred   ',&
'form of the Original Work for making modifications to it and all available    ',&
'documentation describing how to modify the Original Work. Licensor agrees to  ',&
'provide a machine-readable copy of the Source Code of the Original Work along ',&
'with each copy of the Original Work that Licensor distributes. Licensor       ',&
'reserves the right to satisfy this obligation by placing a machine-readable   ',&
'copy of the Source Code in an information repository reasonably calculated to ',&
'permit inexpensive and convenient access by You for as long as Licensor       ',&
'continues to distribute the Original Work.                                    ',&
'                                                                              ',&
'4) Exclusions From License Grant. Neither the names of Licensor, nor the names',&
'of any contributors to the Original Work, nor any of their trademarks or      ',&
'service marks, may be used to endorse or promote products derived from this   ',&
'Original Work without express prior permission of the Licensor. Except as     ',&
'expressly stated herein, nothing in this License grants any license to        ',&
'Licensor''s trademarks, copyrights, patents, trade secrets or any other       ',&
'intellectual property. No patent license is granted to make, use, sell, offer ',&
'for sale, have made, or import embodiments of any patent claims other than the',&
'licensed claims defined in Section 2. No license is granted to the trademarks ',&
'of Licensor even if such marks are included in the Original Work. Nothing in  ',&
'this License shall be interpreted to prohibit Licensor from licensing under   ',&
'terms different from this License any Original Work that Licensor otherwise   ',&
'would have a right to license.                                                ',&
'                                                                              ',&
'5) External Deployment. The term "External Deployment" means the use,         ',&
'distribution, or communication of the Original Work or Derivative Works in any',&
'way such that the Original Work or Derivative Works may be used by anyone     ',&
'other than You, whether those works are distributed or communicated to those  ',&
'persons or made available as an application intended for use over a network.  ',&
'As an express condition for the grants of license hereunder, You must treat   ',&
'any External Deployment by You of the Original Work or a Derivative Work as a ',&
'distribution under section 1(c).                                              ',&
'                                                                              ',&
'6) Attribution Rights. You must retain, in the Source Code of any Derivative  ',&
'Works that You create, all copyright, patent, or trademark notices from the   ',&
'Source Code of the Original Work, as well as any notices of licensing and any ',&
'descriptive text identified therein as an "Attribution Notice." You must cause',&
'the Source Code for any Derivative Works that You create to carry a prominent ',&
'Attribution Notice reasonably calculated to inform recipients that You have   ',&
'modified the Original Work.                                                   ',&
'                                                                              ',&
'7) Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that  ',&
'the copyright in and to the Original Work and the patent rights granted herein',&
'by Licensor are owned by the Licensor or are sublicensed to You under the     ',&
'terms of this License with the permission of the contributor(s) of those      ',&
'copyrights and patent rights. Except as expressly stated in the immediately   ',&
'preceding sentence, the Original Work is provided under this License on an "AS',&
'IS" BASIS and WITHOUT WARRANTY, either express or implied, including, without ',&
'limitation, the warranties of non-infringement, merchantability or fitness for',&
'a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK  ',&
'IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this',&
'License. No license to the Original Work is granted by this License except    ',&
'under this disclaimer.                                                        ',&
'                                                                              ',&
'8) Limitation of Liability. Under no circumstances and under no legal theory, ',&
'whether in tort (including negligence), contract, or otherwise, shall the     ',&
'Licensor be liable to anyone for any indirect, special, incidental, or        ',&
'consequential damages of any character arising as a result of this License or ',&
'the use of the Original Work including, without limitation, damages for loss  ',&
'of goodwill, work stoppage, computer failure or malfunction, or any and all   ',&
'other commercial damages or losses. This limitation of liability shall not    ',&
'apply to the extent applicable law prohibits such limitation.                 ',&
'                                                                              ',&
'9) Acceptance and Termination. If, at any time, You expressly assented to this',&
'License, that assent indicates your clear and irrevocable acceptance of this  ',&
'License and all of its terms and conditions. If You distribute or communicate ',&
'copies of the Original Work or a Derivative Work, You must make a reasonable  ',&
'effort under the circumstances to obtain the express assent of recipients to  ',&
'the terms of this License. This License conditions your rights to undertake   ',&
'the activities listed in Section 1, including your right to create Derivative ',&
'Works based upon the Original Work, and doing so without honoring these terms ',&
'and conditions is prohibited by copyright law and international treaty.       ',&
'Nothing in this License is intended to affect copyright exceptions and        ',&
'limitations (including "fair use" or "fair dealing"). This License shall      ',&
'terminate immediately and You may no longer exercise any of the rights granted',&
'to You by this License upon your failure to honor the conditions in Section   ',&
'1(c).                                                                         ',&
'                                                                              ',&
'10) Termination for Patent Action. This License shall terminate automatically ',&
'and You may no longer exercise any of the rights granted to You by this       ',&
'License as of the date You commence an action, including a cross-claim or     ',&
'counterclaim, against Licensor or any licensee alleging that the Original Work',&
'infringes a patent. This termination provision shall not apply for an action  ',&
'alleging patent infringement by combinations of the Original Work with other  ',&
'software or hardware.                                                         ',&
'                                                                              ',&
'11) Jurisdiction, Venue and Governing Law. Any action or suit relating to this',&
'License may be brought only in the courts of a jurisdiction wherein the       ',&
'Licensor resides or in which Licensor conducts its primary business, and under',&
'the laws of that jurisdiction excluding its conflict-of-law provisions. The   ',&
'application of the United Nations Convention on Contracts for the             ',&
'International Sale of Goods is expressly excluded. Any use of the Original    ',&
'Work outside the scope of this License or after its termination shall be      ',&
'subject to the requirements and penalties of copyright or patent law in the   ',&
'appropriate jurisdiction. This section shall survive the termination of this  ',&
'License.                                                                      ',&
'                                                                              ',&
'12) Attorneys'' Fees. In any action to enforce the terms of this License or   ',&
'seeking damages relating thereto, the prevailing party shall be entitled to   ',&
'recover its costs and expenses, including, without limitation, reasonable     ',&
'attorneys'' fees and costs incurred in connection with such action, including ',&
'any appeal of such action. This section shall survive the termination of this ',&
'License.                                                                      ',&
'                                                                              ',&
'13) Miscellaneous. If any provision of this License is held to be             ',&
'unenforceable, such provision shall be reformed only to the extent necessary  ',&
'to make it enforceable.                                                       ',&
'                                                                              ',&
'14) Definition of "You" in This License. "You" throughout this License,       ',&
'whether in upper or lower case, means an individual or a legal entity         ',&
'exercising rights under, and complying with all of the terms of, this License.',&
'For legal entities, "You" includes any entity that controls, is controlled by,',&
'or is under common control with you. For purposes of this definition,         ',&
'"control" means (i) the power, direct or indirect, to cause the direction or  ',&
'management of such entity, whether by contract or otherwise, or (ii) ownership',&
'of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ',&
'ownership of such entity.                                                     ',&
'                                                                              ',&
'15) Right to Use. You may use the Original Work in all ways not otherwise     ',&
'restricted or conditioned by this License or by law, and Licensor promises not',&
'to interfere with or be responsible for such uses by You.                     ',&
'                                                                              ',&
'16) Modification of This License. This License is Copyright  2005 Lawrence  ',&
'Rosen. Permission is granted to copy, distribute, or communicate this License ',&
'without modification. Nothing in this License permits You to modify this      ',&
'License as applied to the Original Work or to Derivative Works. However, You  ',&
'may modify the text of this License and copy, distribute or communicate your  ',&
'modified version (the "Modified License") and apply it to other original works',&
'of authorship subject to the following conditions: (i) You may not indicate in',&
'any way that your Modified License is the "Open Software License" or "OSL" and',&
'you may not use those names in the name of your Modified License; (ii) You    ',&
'must replace the notice specified in the first paragraph above with the notice',&
'"Licensed under <insert your license name here>" or with a notice of your own ',&
'that is not confusingly similar to the notice in this License; and (iii) You  ',&
'may not claim that your original works are open source software unless your   ',&
'Modified License has been approved by Open Source Initiative (OSI) and You    ',&
'comply with its license review and certification process.                     ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('42','postgresql')
textblock=[ CHARACTER(LEN=128) :: &
'postgresql',&
'          ',&
'PostgreSQL License',&
'                  ',&
'Copyright (c) @YEAR@, @FULLNAME@',&
'                                ',&
'Permission to use, copy, modify, and distribute this software and its',&
'documentation for any purpose, without fee, and without a written agreement is',&
'hereby granted, provided that the above copyright notice and this paragraph   ',&
'and the following two paragraphs appear in all copies.                        ',&
'                                                                              ',&
'IN NO EVENT SHALL @FULLNAME@ BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,     ',&
'SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING',&
'OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF @FULLNAME@     ',&
'HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                           ',&
'                                                                              ',&
'@FULLNAME@ SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT          ',&
'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A       ',&
'PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,   ',&
'AND @FULLNAME@ HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,   ',&
'ENHANCEMENTS, OR MODIFICATIONS.                                               ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('43','unlicense')
textblock=[ CHARACTER(LEN=128) :: &
'unlicense',&
'         ',&
'This is free and unencumbered software released into the public domain.',&
'                                                                       ',&
'Anyone is free to copy, modify, publish, use, compile, sell, or        ',&
'distribute this software, either in source code form or as a compiled  ',&
'binary, for any purpose, commercial or non-commercial, and by any      ',&
'means.                                                                 ',&
'                                                                       ',&
'In jurisdictions that recognize copyright laws, the author or authors  ',&
'of this software dedicate any and all copyright interest in the        ',&
'software to the public domain. We make this dedication for the benefit ',&
'of the public at large and to the detriment of our heirs and           ',&
'successors. We intend this dedication to be an overt act of            ',&
'relinquishment in perpetuity of all present and future rights to this  ',&
'software under copyright law.                                          ',&
'                                                                       ',&
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        ',&
'EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     ',&
'MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ',&
'IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR      ',&
'OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  ',&
'ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  ',&
'OTHER DEALINGS IN THE SOFTWARE.                                        ',&
'                                                                       ',&
'For more information, please refer to <https://unlicense.org>          ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('44','upl-1.0')
textblock=[ CHARACTER(LEN=128) :: &
'upl-1.0',&
'       ',&
'The Universal Permissive License (UPL), Version 1.0',&
'                                                   ',&
'Subject to the condition set forth below, permission is hereby granted to any',&
'person obtaining a copy of this software, associated documentation and/or data',&
'(collectively the "Software"), free of charge and under any and all copyright ',&
'rights in the Software, and any and all patent rights owned or freely         ',&
'licensable by each licensor hereunder covering either (i) the unmodified      ',&
'Software as contributed to or provided by such licensor, or (ii) the Larger   ',&
'Works (as defined below), to deal in both                                     ',&
'                                                                              ',&
'(a) the Software, and                                                         ',&
'(b) any piece of software and/or hardware listed in the lrgrwrks.txt file if  ',&
'one is included with the Software (each a "Larger Work" to which the Software ',&
'is contributed by such licensors),                                            ',&
'                                                                              ',&
'without restriction, including without limitation the rights to copy, create  ',&
'derivative works of, display, perform, and distribute the Software and make,  ',&
'use, sell, offer for sale, import, export, have made, and have sold the       ',&
'Software and the Larger Work(s), and to sublicense the foregoing rights on    ',&
'either these or other terms.                                                  ',&
'                                                                              ',&
'This license is subject to the following condition:                           ',&
'The above copyright notice and either this complete permission notice or at   ',&
'a minimum a reference to the UPL must be included in all copies or            ',&
'substantial portions of the Software.                                         ',&
'                                                                              ',&
'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    ',&
'IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      ',&
'FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   ',&
'AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        ',&
'LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ',&
'OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ',&
'SOFTWARE.                                                                     ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('45','vim')
textblock=[ CHARACTER(LEN=128) :: &
'vim',&
'   ',&
'VIM LICENSE',&
'           ',&
'I)  There are no restrictions on distributing unmodified copies of @PROJECT@',&
'    except that they must include this license text.  You can also distribute',&
'    unmodified parts of @PROJECT@, likewise unrestricted except that they must',&
'    include this license text.  You are also allowed to include executables   ',&
'    that you made from the unmodified @PROJECT@ sources, plus your own usage  ',&
'    examples and Vim scripts.                                                 ',&
'                                                                              ',&
'II) It is allowed to distribute a modified (or extended) version of @PROJECT@,',&
'    including executables and/or source code, when the following four         ',&
'    conditions are met:                                                       ',&
'    1) This license text must be included unmodified.                         ',&
'    2) The modified @PROJECT@ must be distributed in one of the following five',&
'       ways:                                                                  ',&
'       a) If you make changes to @PROJECT@ yourself, you must clearly describe',&
'          in the distribution how to contact you.  When the maintainer asks   ',&
'          you (in any way) for a copy of the modified @PROJECT@ you           ',&
'          distributed, you must make your changes, including source code,     ',&
'          available to the maintainer without fee.  The maintainer reserves   ',&
'          the right to include your changes in the official version of        ',&
'          @PROJECT@.  What the maintainer will do with your changes and under ',&
'          what license they will be distributed is negotiable.  If there has  ',&
'          been no negotiation then this license, or a later version, also     ',&
'          applies to your changes. The current maintainer is Bram Moolenaar   ',&
'          <Bram@vim.org>.  If this changes it will be announced in appropriate',&
'          places (most likely vim.sf.net, www.vim.org and/or comp.editors).   ',&
'          When it is completely impossible to contact the maintainer, the     ',&
'          obligation to send him your changes ceases.  Once the maintainer has',&
'          confirmed that he has received your changes they will not have to be',&
'          sent again.                                                         ',&
'       b) If you have received a modified @PROJECT@ that was distributed as   ',&
'          mentioned under a) you are allowed to further distribute it         ',&
'          unmodified, as mentioned at I).  If you make additional changes the ',&
'          text under a) applies to those changes.                             ',&
'       c) Provide all the changes, including source code, with every copy of  ',&
'          the modified @PROJECT@ you distribute.  This may be done in the form',&
'          of a context diff.  You can choose what license to use for new code ',&
'          you add.  The changes and their license must not restrict others    ',&
'          from making their own changes to the official version of @PROJECT@. ',&
'       d) When you have a modified @PROJECT@ which includes changes as        ',&
'          mentioned under c), you can distribute it without the source code   ',&
'          for the changes if the following three conditions are met:          ',&
'          - The license that applies to the changes permits you to distribute ',&
'            the changes to the Vim maintainer without fee or restriction, and ',&
'            permits the Vim maintainer to include the changes in the official ',&
'            version of @PROJECT@ without fee or restriction.                  ',&
'          - You keep the changes for at least three years after last          ',&
'            distributing the corresponding modified @PROJECT@.  When the      ',&
'            maintainer or someone who you distributed the modified @PROJECT@  ',&
'            to asks you (in any way) for the changes within this period, you  ',&
'            must make them available to him.                                  ',&
'          - You clearly describe in the distribution how to contact you.  This',&
'            contact information must remain valid for at least three years    ',&
'            after last distributing the corresponding modified @PROJECT@, or  ',&
'            as long as possible.                                              ',&
'       e) When the GNU General Public License (GPL) applies to the changes,   ',&
'          you can distribute the modified @PROJECT@ under the GNU GPL version ',&
'          2 or any later version.                                             ',&
'    3) A message must be added, at least in the output of the ":version"      ',&
'       command and in the intro screen, such that the user of the modified    ',&
'       @PROJECT@ is able to see that it was modified.  When distributing as   ',&
'       mentioned under 2)e) adding the message is only required for as far as ',&
'       this does not conflict with the license used for the changes.          ',&
'    4) The contact information as required under 2)a) and 2)d) must not be    ',&
'       removed or changed, except that the person himself can make            ',&
'       corrections.                                                           ',&
'                                                                              ',&
'III) If you distribute a modified version of @PROJECT@, you are encouraged to ',&
'     use the Vim license for your changes and make them available to the      ',&
'     maintainer, including the source code.  The preferred way to do this is  ',&
'     by e-mail or by uploading the files to a server and e-mailing the URL. If',&
'     the number of changes is small (e.g., a modified Makefile) e-mailing a   ',&
'     context diff will do.  The e-mail address to be used is                  ',&
'     <maintainer@vim.org>                                                     ',&
'                                                                              ',&
'IV)  It is not allowed to remove this license from the distribution of the    ',&
'     @PROJECT@ sources, parts of it or from a modified version.  You may use  ',&
'     this license for previous @PROJECT@ releases instead of the license that ',&
'     they came with, at your option.                                          ',&
'                                                                              ',&
'                                                                              ',&
'                                                                              ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('46','wtfpl')
textblock=[ CHARACTER(LEN=128) :: &
'wtfpl',&
'     ',&
'Do What The F*ck You Want To Public License',&
'                                           ',&
'   The easiest license out there. It gives the user permissions to do',&
'   whatever they want with your code.                                ',&
'      Permissions    Conditions Limitations                          ',&
'     * Commercial use                                                ',&
'     * Distribution                                                  ',&
'     * Modification                                                  ',&
'     * Private use                                                   ',&
'                                                                     ',&
'            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE              ',&
'                    Version 2, December 2004                         ',&
'                                                                     ',&
' Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>                    ',&
'                                                                     ',&
' Everyone is permitted to copy and distribute verbatim or modified   ',&
' copies of this license document, and changing it is allowed as long ',&
' as the name is changed.                                             ',&
'                                                                     ',&
'            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE              ',&
'   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION   ',&
'                                                                     ',&
'  0. You just DO WHAT THE FUCK YOU WANT TO.                          ',&
'                                                                     ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case('47','zlib')
textblock=[ CHARACTER(LEN=128) :: &
'zlib',&
'    ',&
'zlib License',&
'            ',&
'(C) @YEAR@ @FULLNAME@',&
'                     ',&
'This software is provided ''as-is'', without any express or implied',&
'warranty.  In no event will the authors be held liable for any damages',&
'arising from the use of this software.                                ',&
'                                                                      ',&
'Permission is granted to anyone to use this software for any purpose, ',&
'including commercial applications, and to alter it and redistribute it',&
'freely, subject to the following restrictions:                        ',&
'                                                                      ',&
'1. The origin of this software must not be misrepresented; you must not',&
'   claim that you wrote the original software. If you use this software',&
'   in a product, an acknowledgment in the product documentation would be',&
'   appreciated but is not required.                                     ',&
'2. Altered source versions must be plainly marked as such, and must not be',&
'   misrepresented as being the original software.                         ',&
'3. This notice may not be removed or altered from any source distribution.',&
'                                                                          ',&
'   [3]Copy license text to clipboard                                      ',&
'                                                                          ',&
'']
if(present(topic_only))then
   if(size(textblock)>0)then
      if(topic_only) textblock=[character(len=len(textblock(1))) :: textblock(1)]
   else
      textblock=['']
   endif
endif
case default
textblock=[character(len=20) :: 'UNKNOWN']
end select
end function show_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine replaceit()
   character(len=:),allocatable :: line
   integer :: i, j, k
   do i = 1, size(textblock)
      do j=1,size(configblock)
         k=index(configblock(j),'=>')
         if(k.ne.0)then
            line = replace(textblock(i),configblock(j)(1:k-1) , trim(configblock(j)(k+2:)))
            ! ignorecase  whether to ignore ASCII case or not. Defaults to .false. .
            ! ierr        error code. iF ier = -1 bad directive, >= 0 then count of changes made.
            if(len(line).gt.len(textblock))then
               textblock=[character(len=max(len(line),len(textblock))):: textblock] ! widen file is neccessary
            endif
            textblock(i) = line
         endif
      enddo
   end do
end subroutine replaceit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine codeit()
integer :: width
integer :: i
integer :: G_iout
integer :: ilength
character(len=:), allocatable :: buff
character(len=:), allocatable :: subname
   width = 0
   G_iout = stdout
   do i = min(2, size(textblock)), size(textblock)
      width = max(width, len_trim(textblock(i)))
   end do
   subname=trim(textblock(1))
   if(subname.ne.'')then
      subname=replace(subname,'-','_')
      subname=transliterate(subname,' !"#$%&''()*+,-./:;<=>?@[\]^`{|}~','')
      subname='_'//subname
   endif
   write (G_iout, '(a)') 'subroutine license'//subname//'()'
   write (G_iout, '(a)') 'integer :: i'
   write (G_iout, '(a)') 'character(len=:),allocatable :: license_text(:)'
   write (G_iout, '(a,i0,a)') 'license_text'//'=[ CHARACTER(LEN=', width, ') :: &'
   do i = min(2, size(textblock)), size(textblock)
      buff = trim(textblock(i))
      buff = replace(buff,"'","''")         ! change single quotes in input to two adjacent single quotes
      write (G_iout, '("''",a,"'',&")') stretch(buff, width)
   end do
   write (G_iout, '(a)') "'']"
   write (G_iout, '(a)') "write(*,'(a)') (trim(license_text(i)), i=1, size(license_text))"
   write (G_iout, '(a)') "end subroutine license"//subname
end subroutine codeit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine setup()
help=[ CHARACTER(LEN=128) :: &
'NAME',&
'   fpm-licenses(1f) - [FPM:LICENSES] write out common licenses as text files',&
'   (LICENSE:MIT)                                                            ',&
'                                                                            ',&
'SYNOPSIS                                                                    ',&
'    fpm-licenses [spdx_tagname(s)][--all][--fortran][--verbose][--config FILENAME]',&
'                                                                                  ',&
'    fpm-licenses --file FILENAME [--config FILENAME]                              ',&
'                                                                                  ',&
'    fpm-licenses --help|--version                                                 ',&
'                                                                                  ',&
'DESCRIPTION                                                                       ',&
'   fpm projects often require or preferably contain a LICENSE.txt file.           ',&
'   Some programs want to contain a subroutine that can be called to show          ',&
'   the license.                                                                   ',&
'                                                                                  ',&
'   Sometimes instead of a text file a subroutine is preferred for displaying      ',&
'   the license directory from the program.                                        ',&
'                                                                                  ',&
'   Typically the output requires editing to insert specific names,dates           ',&
'   and organizations as appropriate.                                              ',&
'                                                                                  ',&
'   Available license descriptions include                                         ',&
'                                                                                  ',&
'      ------------------------------------------      ----------------            ',&
'      License                                         License keyword             ',&
'      ------------------------------------------      ----------------            ',&
'      Academic Free License v3.0                      AFL-3.0                     ',&
'      Apache license 2.0                              Apache-2.0                  ',&
'      Artistic license 2.0                            Artistic-2.0                ',&
'      Boost Software License 1.0                      BSL-1.0                     ',&
'      BSD 2-clause "Simplified" license               BSD-2-Clause                ',&
'      BSD 3-clause "New" or "Revised" license         BSD-3-Clause                ',&
'      BSD 3-clause Clear license                      BSD-3-Clause-Clear          ',&
'      BSD 4-clause "Original" or "Old" license        BSD-4-Clause                ',&
'      BSD Zero-Clause license                         0BSD                        ',&
'      Creative Commons license family                 CC                          ',&
'      Creative Commons Zero v1.0 Universal            CC0-1.0                     ',&
'      Creative Commons Attribution 4.0                CC-BY-4.0                   ',&
'      Creative Commons Attribution ShareAlike 4.0     CC-BY-SA-4.0                ',&
'      Do What The F*ck You Want To Public License     WTFPL                       ',&
'      Educational Community License v2.0              ECL-2.0                     ',&
'      Eclipse Public License 1.0                      EPL-1.0                     ',&
'      Eclipse Public License 2.0                      EPL-2.0                     ',&
'      European Union Public License 1.1               EUPL-1.1                    ',&
'      GNU Affero General Public License v3.0          AGPL-3.0                    ',&
'      GNU General Public License family               GPL                         ',&
'      GNU General Public License v2.0                 GPL-2.0                     ',&
'      GNU General Public License v3.0                 GPL-3.0                     ',&
'      GNU Lesser General Public License family        LGPL                        ',&
'      GNU Lesser General Public License v2.1          LGPL-2.1                    ',&
'      GNU Lesser General Public License v3.0          LGPL-3.0                    ',&
'      Internet Software Consortium                    ISC                         ',&
'      LaTeX Project Public License v1.3c              LPPL-1.3c                   ',&
'      Microsoft Public License                        MS-PL                       ',&
'      Massachusetts Institute of Technology           MIT                         ',&
'      Mozilla Public License 2.0                      MPL-2.0                     ',&
'      Open Software License 3.0                       OSL-3.0                     ',&
'      PostgreSQL License                              PostgreSQL                  ',&
'      SIL Open Font License 1.1                       OFL-1.1                     ',&
'      University of Illinois/NCSA Open Source License NCSA                        ',&
'      The Unlicense                                   Unlicense                   ',&
'      zLib License                                    Zlib                        ',&
'                                                                                  ',&
'OPTIONS                                                                           ',&
'   SPDX tagnames(s)    SPDX tagname of license to display. All supported          ',&
'                       tag names are displayed by default.                        ',&
'    --fortran          format license as a Fortran subroutine                     ',&
'    --all              display all supported license text                         ',&
'    --file FILENAME    ignore other options and format file as a                  ',&
'                       Fortran subroutine. FILENAME defaults to stdin.            ',&
'    --config=FILENAME  File of form LHS=>RHS that is used to replace              ',&
'                       strings in the output. Built-in strings are                ',&
'                                                                                  ',&
'                         @YEAR@=>YYYY # where YYYY is current year                ',&
'                         @MONTH@=>MM  # where MM is current month                 ',&
'                         @DAY@=>DD    # where DD is current day                   ',&
'                                                                                  ',&
'                       Strings are case-sensitive and all spaces are              ',&
'                       significant except trailing space on the RHS.              ',&
'                       Strings requiring editing often appear delimited           ',&
'                       by an at sign (@), such as "@FULLNAME@". Lines             ',&
'                       not containing "=>" are ignored.                           ',&
'                                                                                  ',&
'                       The value of the environment variable                      ',&
'                       FPM_LICENSE_CONFIG is used as the default.                 ',&
'    --verbose,-V  verbose mode                                                    ',&
'    --version,-v  Print version information on standard output then               ',&
'                  exit successfully.                                              ',&
'    --help,-h     Print usage information on standard output then                 ',&
'                  exit successfully.                                              ',&
'                                                                                  ',&
'EXAMPLES                                                                          ',&
'                                                                                  ',&
'Sample commands:                                                                  ',&
'                                                                                  ',&
'     fpm-license  # display available license names                               ',&
'                                                                                  ',&
'     fpm-license mit > LICENSE.txt # create a specific license file               ',&
'                                                                                  ',&
'     fpm-license --help # display this help text                                  ',&
'                                                                                  ',&
'     fpm-license --all  # display all supported license descriptions              ',&
'                                                                                  ',&
'     fpm-license --fortran mit # write license as Fortran code                    ',&
'                                                                                  ',&
'     # write a license file using specified string substitutions                  ',&
'     # from configuration file                                                    ',&
'     fpm-license cc0-1.0 --config $HOME/.local/config/fpm-license.txt mit         ',&
'                                                                                  ',&
'SEE ALSO                                                                          ',&
'                                                                                  ',&
'    + Wikipedia contains descriptions of many license descriptions                ',&
'    + https://spdx.dev/learn/areas-of-interest/licensing                          ',&
'    + https://spdx.org/licenses/                                                  ',&
'    + https://docs.github.com/en/repositories/...                                 ',&
'    managing-your-repositorys-settings-and-features/...                           ',&
'    customizing-your-repository/licensing-a-repository                            ',&
'    + https://opensource.guide/legal/...                                          ',&
'    #which-open-source-license-is-appropriate-for-my-project                      ',&
'']
version=[ CHARACTER(LEN=128) :: &
'PRODUCT:        GPF (General Purpose Fortran) utilities and examples',&
'PROGRAM:        fpm-license(1f)                                     ',&
'DESCRIPTION:    fpm(1) create license files                         ',&
'VERSION:        1.0, 2024-05-17                                     ',&
'AUTHOR:         John S. Urban                                       ',&
'LICENSE:        MIT                                                 ',&
'']
end subroutine setup
end program license
 
