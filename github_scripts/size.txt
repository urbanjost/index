reinh-bader opened this issue on Feb 14 · 5 comments
Comments
@reinh-bader
reinh-bader commented on Feb 14

The concept of assumed rank permits definition of interfaces that are rank-agnostic.
The addition of the SELECT RANK block construct permits definitions and references to the object by resolving at run time to whatever rank the actual argument has. This is fine in case the array rank e.g. reflects different problem dimensions, requiring different algorithms for its solution. However, there are also cases in which uniform treatment of the argument's data irrespective of its rank is required. This is currently cumbersome to do.

This proposal suggests supporting this at least for the case of a CONTIGUOUS argument by remapping to a suitable rank-1 entity.

Variant 1: Permit pointer assignment

Assuming declarations
REAL, CONTIGUOUS, TARGET :: X(..)
REAL, POINTER :: XP(:)
it should be permissible to write
XP(1:SIZE(X)) => X
Note that for X assumed shape and any rank, this is already permitted. Some words would be needed to treat the rank 0 and rank "*" cases. The data in X could then be processed via XP.

Variant 2: Extend ASSOCIATE semantics

Assuming a declaration
REAL, CONTIGUOUS :: X(..)
it should be permissible to write
ASSOCIATE(XA(1:SIZE(X)) => X)
... ! definitions and references to XA
END ASSOCIATE

This variant would not require the TARGET attribute on X. Inside the ASSOCIATE block, the data could be processed via XA.

Requiring the CONTIGUOUS attribute imposes no limitation on functionality. Users need to be made aware of the potential performance impact for copy-in/out.
@reinh-bader reinh-bader mentioned this issue on Feb 14
Proposals for February 24 - 28, 2020 J3 committee meeting #122
Open
@arjenmarkus
arjenmarkus commented on Feb 14

Having read your proposal, I am inclined towards the ASSOCIATE alternative - it feels more inline with the newer constructs. I guess it also be possible to do:
M = 10 N = SIZE(X)/M ASSOCIATE( XA(1:N,1:M) => X)
irrespective of the rank of X.
Otherwise, if the ASSOCIATE is limited to one-dimensional "mappings", the "(1:SIZE(X)" could be replaced by "(:)" to indicate that a one-dimensional mapping is required. (I am sure I do not oversee all ramifications)
@reinh-bader
Author
reinh-bader commented on Feb 14 •

While permission of multi-rank mappings could certainly be allowed, it is not really germane to the use-case at hand. I also prefer the ASSOCIATE, but the rank-remapped pointer conveys the idea, since it is already in the language. The bounds specs, I think, are necessary. Especially for the rank "*" case.
@aradi
Contributor
aradi commented on Feb 24 •

I think, this possibility could/should be combined with the possibility of returning an array of arbitrary rank in a function, and a generic way to access the indexing of the arrays, similar how it can be already in C since Fortran 2018.

module test
  implicit none

contains

  function sum_wrapper(array, dim) result(redarray)
    real, dimension(..), intent(in) :: array
    integer, intent(in) :: dim
    ! Dimension would be an array of "slice-types" allowing dynamic
    ! determination of the shape of the returned array
    real, dimension(get_redarray_shape(array, dim)) :: redarray

    redarray(get_redarray_shape(array, dim)) = sum(array, dim=dim)

  end function sum_wrapper


  pure function get_redarray_shape(array, dim) result(redshape)
    real, dimension(..), intent(in) :: array
    integer, intent(in) :: dim
    type(slice), dimension(rank(array) - 1) :: redshape
    integer :: ii

    do ii = 1, dim - 1
      ! With the intrinsic function get_slices, we should get access to the
      ! slicing parameters of the array (similar, how you can do it in C since
      ! Fortran 2018)
      redshape(ii) = get_slices(array, dim=ii)
    end do
    do ii = dim + 1, rank(array)
      redshape(ii - 1) = get_slices(array, dim=ii)
    end do

  end function get_redarray_shape

end module test

This possibility, combined with the multi-rank mapping as suggested by @arjenmarkus would eliminate a lot of the Fypp-magic in the stdlib-statistical functions.
@reinh-bader
Author
reinh-bader commented on Feb 24

Has the concept of type(slice) already been submitted as an issue?
Further, how do you invoke sum_wrapper? Fortran currently defines no semantics for array expressions whose rank is not determined at compile time.
@aradi aradi mentioned this issue on Feb 24
General array indexing infrastructure #153
Open
@aradi
Contributor
aradi commented on Feb 24

I've now created issue #153 for that in order not to pollute this issue.
@urbanjost
Attach files by dragging & dropping, selecting or pasting them.
Remember, contributions to this repository should follow its code of conduct.
