#!/bin/bash
####################################################################################################################################
#@(#) make documentation module from .man pages
####################################################################################################################################
(
exec 2>&1
####################################################################################################################################
# setup
# where plain-text manpages are

HERE=$(realpath $(dirname $0))
BASE=$(dirname $HERE)
BASE=$(dirname $BASE)
DOCS=$BASE/docs

export PACKAGE=${1:-GPF}
export TEXTDIR=${2:${pwd}}

export NAME

####################################################################################################################################
# FUNCTIONS
####################################################################################################################################
TOCHARACTER(){
:
cat $NAME |
   sed -e "s/'/''/g" |
   sed -e "s/^/'/" |
   sed -e 's/$/'"'"', \&/'|
cat
}
####################################################################################################################################
WRITE_MODULE(){
(
cat <<EOF
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
module ${PACKAGE}_docs
EOF
cat <<\EOF
implicit none
private
public help_intrinsics
!interface help_intrinsics
!   module procedure help_intrinsics_all
!   module procedure help_intrinsics_one
!end interface help_intrinsics
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics(name,prefix,topic,m_help) result (textblock)
character(len=*),intent(in)                       :: name
logical,intent(in),optional                       :: prefix
logical,intent(in),optional                       :: topic
logical,intent(in),optional                       :: m_help
character(len=256),allocatable                    :: textblock(:)
character(len=:),allocatable                      :: a, b, c
integer                                           :: i, p, pg
   select case(name)
EOF
cat <<EOF
   case('','manual','${PACKAGE}')
EOF
cat <<\EOF
      textblock=help_intrinsics_all(prefix,topic,m_help)
   case('fortran','toc')
      textblock=help_intrinsics_section()
      do i=1,size(textblock)
         p = index(textblock(i), '[')
         pg = index(textblock(i), ']')
         if(p.gt.0.and.pg.gt.p)then
          a=textblock(i)(:p-1)
          b=textblock(i)(p:pg)
          c=textblock(i)(pg+1:)
          textblock(i)=b//' '//a//c
         endif
      enddo
      call sort_name(textblock)
   case default
      textblock=help_intrinsics_one(name,prefix,topic,m_help)
   end select
end function help_intrinsics
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_section() result (textblock)

!@(#) grab lines in NAME section and append them to generate an index of manpages

character(len=256),allocatable  :: textblock(:)
character(len=256),allocatable  :: add(:)
character(len=256),allocatable  :: label
character(len=10)               :: cnum
integer                         :: i
integer                         :: icount
logical                         :: is_label
logical                         :: grab
   allocate(textblock(0))
   icount=1
   do
      write(cnum,'(i0)') icount
      add=help_intrinsics_one(cnum)
      if( size(add) .eq. 0 ) exit
      label=''
      grab=.false.
      is_label=.false.
      do i=1,size(add)
         if(add(i).ne.'')then
            is_label=verify(add(i)(1:1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ ') == 0 &
            .and. verify(trim(add(i)),'ABCDEFGHIJKLMNOPQRSTUVWXYZ ') == 0
         endif
         if(add(i).eq.'')then
            ! skip
         elseif(is_label.and.add(i).eq.'NAME')then
            grab=.true.
         elseif(is_label)then
            exit
         elseif(grab)then
            label=adjustl(trim(label))//' '//adjustl(compact(trim(add(i))))
         endif
      enddo
      textblock=[character(len=256) :: textblock,compact(label)]
      icount=icount + 1
   enddo
end function help_intrinsics_section
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_all(prefix,topic,m_help) result (textblock)
logical,intent(in),optional     :: prefix
logical,intent(in),optional     :: topic
logical,intent(in),optional     :: m_help
character(len=256),allocatable  :: textblock(:)
character(len=256),allocatable  :: header(:)
character(len=256),allocatable  :: add(:)
character(len=10)               :: cnum
integer                         :: icount
   allocate(textblock(0))
   icount=1
   do
      write(cnum,'(i0)') icount
      add=help_intrinsics_one(cnum,prefix,topic,m_help)
      if( size(add) .eq. 0 ) exit
      textblock=[character(len=256) :: textblock,add]
      icount=icount + 1
   enddo
   if(present(m_help))then
      if(m_help)then
         header=[ character(len=256) :: &
         '================================================================================',    &
         'SUMMARY',    &
         ' The primary Fortran topics are',    &
         ' tan                   tanh                      this_image',    &
         '']
         textblock=[header,textblock]
      endif
   endif
end function help_intrinsics_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_one(name,prefix,topic,m_help) result (textblock)
character(len=*),intent(in)      :: name
logical,intent(in),optional      :: prefix
logical,intent(in),optional      :: m_help
logical,intent(in),optional      :: topic
character(len=256),allocatable   :: textblock(:)
character(len=:),allocatable     :: shortname
integer                          :: i
select case(name)
EOF
)
}
####################################################################################################################################
END_MODULE(){
(
cat <<\EOF
case default
   allocate (character(len=256) :: textblock(0))
end select
contains
subroutine select()
if(present(topic))then
   if(topic)then
      textblock=[shortname]
   endif
endif

if(present(prefix))then
   if(prefix)then
      do i=1,size(textblock)
         textblock(i)= shortname//':'//trim(textblock(i))
      enddo
   endif
endif

if(present(m_help))then
   if(m_help)then
      textblock=[character(len=len(textblock)+1) :: ' ',textblock] ! add blank line to put shortname into
      textblock=' '//textblock                                     ! shift to right by one character
      textblock(1)=shortname
   endif
endif
end subroutine select
end function help_intrinsics_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine sort_name(lines)
!@(#) sort_name(3fp):sort strings(a-z) over specified field using shell sort starting with [ character
character(len = *)                :: lines(:)
   character(len = :),allocatable :: ihold
   integer                        :: n, igap, i, j, k, jg
   n = size(lines)
   if(n.gt.0)then
      allocate(character(len = len(lines(1))) :: ihold)
   else
      ihold = ''
   endif
   igap = n
   INFINITE: do
      igap = igap/2
      if(igap.eq.0) exit INFINITE
      k = n-igap
      i = 1
      INNER: do
         j = i
         INSIDE: do
            jg = j+igap
            if( lle( lower(lines(j)), lower(lines(jg)) ) )exit INSIDE
            ihold = lines(j)
            lines(j) = lines(jg)
            lines(jg) = ihold
            j = j-igap
            if(j.lt.1) exit INSIDE
         enddo INSIDE
         i = i+1
         if(i.gt.k) exit INNER
      enddo INNER
   enddo INFINITE
end subroutine sort_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
elemental pure function lower(str) result (string)
!@(#) ${PACKAGE}::lower(3f): Changes a string to lowercase over specified range
character(*), intent(In)     :: str
character(len(str))          :: string
integer                      :: i
   string = str
   do i = 1, len_trim(str)     ! step thru each letter in the string
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32) ! change letter to miniscule
      case default
      end select
   end do
end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!elemental pure function compact(str,char) result (outstr)
function compact(str,char) result (outstr)

!$@(#) ${PACKAGE}::compact(3f): Converts white-space to single spaces; removes leading spaces

character(len=*),intent(in)          :: str
character(len=*),intent(in),optional :: char
character(len=len(str))              :: outstr
character(len=1)                     :: ch
integer                              :: i
integer                              :: position_in_output
logical                              :: last_was_space
character(len=1)                     :: char_p
logical                              :: nospace
if(present(char))then
   char_p=char
   if(len(char).eq.0)then
      nospace=.true.
   else
      nospace=.false.
   endif
else
   char_p=' '
   nospace=.false.
endif
   outstr=' '
   last_was_space=.false.
   position_in_output=0

   IFSPACE: do i=1,len_trim(str)
     ch=str(i:i)
     select case(iachar(ch))
       case(0:32,127)                                         ! space or tab character or control character
         if(position_in_output.eq.0)then                      ! still at beginning so ignore leading whitespace
            cycle IFSPACE
         elseif(.not.last_was_space) then                     ! if have not already put out a space output one
           if(.not.nospace)then
              position_in_output=position_in_output+1
              outstr(position_in_output:position_in_output)=char_p
           endif
         endif
         last_was_space=.true.
       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it
         position_in_output=position_in_output+1
         outstr(position_in_output:position_in_output)=ch
         last_was_space=.false.
     end select
   enddo IFSPACE

end function compact
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
EOF
cat <<EOF
end module ${PACKAGE}_docs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
EOF
)
}
####################################################################################################################################
NAME_HELP(){
(
cd $TEXTDIR
ls *3*.man|while read NAME
do
   SHORTNAME=${NAME/.*}
   (
   cat <<EOF
   function help_${SHORTNAME}(prefix,topic,m_help) result (textblock)
   character(len=256),allocatable   :: textblock(:)
   logical,intent(in),optional      :: prefix
   logical,intent(in),optional      :: topic
   logical,intent(in),optional      :: m_help
   character(len=*),parameter       :: shortname="$SHORTNAME"
   character(len=:),allocatable,intent(out),optional :: name
   textblock=[character(len=256)    :: &
   '', &
   $(TOCHARACTER)
   '']
      if(present(topic))then
         textblock=[shortname]
      elseif(present(prefix))then
         if(prefix)then
            do i=1,size(textblock)
               textblock(i)=shortname//':'//trim(textblock(i))
            enddo
         endif
      elseif(present(m_help))then
         if(m_help)then
            textblock=[character(len=len(textblock)+1) :: ' ',textblock] ! add blank line to put shortname in
   	 textblock=' '//textblock ! shift to right by one character 
            textblock(1)=shortname
         endif
      endif
   end function help_${SHORTNAME}
EOF
   )
done 
)
}
####################################################################################################################################
# MAIN
####################################################################################################################################
# rebuild ${PACKAGE}_docs.f90
cd $TEXTDIR
(
WRITE_MODULE

COUNT=0
ls *3*.man|while read NAME
do
   SHORTNAME=${NAME/.*}
   COUNT=$((COUNT+1))
   cat <<EOF

case('$COUNT','$SHORTNAME')

textblock=[character(len=256) :: &
'', &
$(TOCHARACTER)
'']

shortname="$SHORTNAME"

call select()

EOF
done

END_MODULE
) >$HOME/github/plugins/fpm-docs/src/${PACKAGE}_docs.f90
ls -ld  $HOME/github/plugins/fpm-docs/src/${PACKAGE}_docs.f90
####################################################################################################################################
# build new version of fman
#fpm build 
####################################################################################################################################
cat > $HOME/github/plugins/fpm-docs/app/fpm-${PACKAGE}.f90 <<EOF
!>>>>> app/fman.f90
program fpm_${PACKAGE}
use ${PACKAGE}_docs, only : help_intrinsics
use M_CLI2,       only : set_args, sget, lget, topics=>unnamed
use M_match,      only : getpat, match, regex_pattern
use M_match,      only : YES, ERR
use M_strings,    only : lower, indent, atleast
use M_escape,     only : esc
implicit none
type(regex_pattern)          :: p
character(len=:),allocatable :: help_text(:), version_text(:)
character(len=256),allocatable :: manual(:),section(:)
character(len=:),allocatable :: regex
integer                      :: i, j, k
logical                      :: topic
logical                      :: prefix, ignorecase, demo, color
integer                      :: start_keep, end_keep
    ! process command line
    call setup()
    call set_args(' --regex:e " " --ignorecase:i F --topic_only:t F --demo:d F --color:c',&
    & help_text,version_text)
    regex=sget('regex')
    topic=lget('topic_only')
    ignorecase=lget('ignorecase')
    demo=lget('demo')
    color=lget('color')

    ! if -t then just show topic names and exit
    if(topic)then
       manual = help_intrinsics('',topic=topic)
       ! could truncate if name is too long, could get a bit fancier or use
       ! M_display(3f) and have default just print one per line
       write(*,'(3(g0))') ( [character(len=80/3) :: manual(i)], i=1, size(manual) )
       stop
    endif

    ! compile any regular expression
    ! Also, if doing a regular expression and not the single topic "toc"
    ! add a section prefix when building manual


    ! initially assume prefixing is off unless a regular expression is used
    if(regex.ne.' ')then
       prefix=.true.
    else
       prefix=.false.
    endif

    ! normalize the topics list
    ! ensure there is at least one topic by applying a default
    if(size(topics).eq.0)then
       topics=['toc']
    endif

    if( ( size(topics).eq.1 .and. topics(1).eq.'toc') )then
       prefix=.false.
       ignorecase=.true.
    endif

    if(regex.ne.' ')then
       if (getpat(merge(lower(regex),regex,ignorecase), p%pat) .eq. ERR) then
          stop '*fpm-${PACKAGE}* Illegal pattern.'
       endif
    endif

    if(lget('verbose'))then
       write(*,'(*(g0:,1x))')'<INFO>AFTER NORMALIZING:'
       write(*,'(*(g0:,1x))')'<INFO>REGEX       ',regex
       write(*,'(*(g0:,1x))')'<INFO>IGNORECASE  ',ignorecase
       write(*,'(*(g0:,1x))')'<INFO>TOPIC_ONLY  ',topic
       write(*,'(*(g0:,1x))')'<INFO>PREFIX      ',prefix
       write(*,'(*(g0:,1x))')'<INFO>DEMO        ',demo
       write(*,'(*(g0:,1x))')'<INFO>TOPICS      ',topics
    endif
    ! build text to display or search
    manual=[character(len=0) ::]
    do i=1, size(topics)
       section = help_intrinsics(topics(i),prefix=prefix)
       if(color)section=crayons(section)

       ! extract demo program if found (has to follow specific format)
       if(demo)then
          call find_demo()
       endif

       manual = [character(len=max(len(manual),len(section))) :: manual,section]
    enddo

    ! display selected text
    if(size(manual).eq.0)then
       write(*,'(g0)')'Sorry. did not find that. Perhaps you should search the TOC. try'
       write(*,'(g0)')'   fpm-${PACKAGE} -e TOPIC'
       write(*,'(g0)')'or search the entire manual:'
       write(*,'(g0)')'   fpm-${PACKAGE} manual -i -e TOPIC'
       stop 1
    else
       ! display what was found
       do i=1,size(manual)
          if(regex.ne.'')then
             select case(ignorecase)
             case(.true.)
                if(match(lower(trim(manual(i)))//char(10), p%pat) .eq. YES) then
                  write(*,'(g0)')trim(manual(i))
                endif
             case(.false.)
                if (match(trim(manual(i))//char(10), p%pat) .eq. YES) then
                  write(*,'(g0)')trim(manual(i))
                endif
             end select
          else
             write(*,'(g0)')trim(manual(i))
          endif
       enddo
    endif
contains
subroutine find_demo()
character(len=256),allocatable :: newsection(:)
integer :: ii,jj,kk
   if(allocated(newsection)) deallocate(newsection)
   allocate(newsection(0))
   if(demo)then
      start_keep=0
      end_keep=0
      jj=0
      do ii=1,size(section)
         jj=jj+1
         if(jj.gt.size(section))exit
         if(index(lower(section(jj)),'program demo_').ne.0)then
            start_keep=jj
            do kk=start_keep+1,size(section)
               if(kk.gt.size(section))exit
               if(index(lower(section(kk)),'end program demo_').ne.0)then
                  end_keep=kk
                  if(start_keep.ne.0 .and. end_keep.ne.0)then
                     newsection=[character(len=max(len(newsection),len(section))) :: newsection,section(start_keep:end_keep)]
                     jj=kk+1
                  endif
                  exit
               endif
            enddo
         endif
      enddo
    endif
    if(size(newsection).eq.0)then
       write(*,*)'!<ERROR> *fpm-${PACKAGE}* standard demo code format not found for ',trim(topics(i))
       section=['']
    else
       section=newsection
       deallocate(newsection)
    endif
end subroutine find_demo
function crayons(oldblock) result(newblock)
! just playing. There is a lot of stuff not done robustly here
character(len=256),intent(in),allocatable :: oldblock(:)
character(len=256),allocatable :: newblock(:)
integer :: ilen
integer :: lead
logical :: program_text
   program_text=.false.
   newblock= oldblock
   do j=1,size(oldblock)
      if( index(oldblock(j),'end program demo_') .eq. 0 .and. index(oldblock(j),'program demo_') .ne. 0)then
         program_text=.true.
         lead=indent(oldblock(j))
      endif
      if(program_text .eqv. .true.)then
        newblock(j)=esc('<E>'//repeat(' ',lead)//'<E><y>'//atleast(oldblock(j)(lead+1:),80-lead) )
      elseif(verify(oldblock(j)(1:1), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ) == 0 .and. &
      & verify(oldblock(j), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ _') == 0 )then
         ilen=len_trim(oldblock(j))
         newblock(j)=esc('<E><y><bo> '//trim(oldblock(j))//' </bo>'//repeat(' ',max(0,80-ilen-2))//'<reset>')
       else
          ilen=len_trim(oldblock(j))
          ilen=len_trim(than(oldblock(j)))-ilen
          newblock(j)=esc('<E><w>'//atleast(than(oldblock(j)),80+ilen)//'<reset>')
       endif
      if( index(oldblock(j),'end program demo_') .ne.0)then
         program_text=.false.
      endif
   enddo
end function crayons

function than(in) result(out)
character(len=*),intent(in)  :: in
character(len=:),allocatable :: out
integer                      :: i
   out=''
   do i=1,len_trim(in)
      select case(in(i:i))
      case('<')
         out=out//'<lt>'
      case('>')
         out=out//'<gt>'
      case default
         out=out//in(i:i)
      endselect
   enddo
end function than

subroutine setup()
help_text=[ CHARACTER(LEN=128) :: &
'NAME                                                                            ',&
'    fpm-${PACKAGE}(1f) - [DEVELOPER] output descriptions of Fortran intrinsics  ',&
'    (LICENSE:PD)                                                                ',&
'                                                                                ',&
'SYNOPSIS                                                                        ',&
'    fpm-${PACKAGE} NAME(s) [[-ignorecase][--regex Regular_Expression]]|         ',&
'                [-topic_only][--color][--demo]                                  ',&
'                                                                                ',&
'    fpm-${PACKAGE} [ --help| --version]                                         ',&
'                                                                                ',&
'DESCRIPTION                                                                     ',&
'   fpm-${PACKAGE}(1) print descriptions of procedures as simple flat text.      ',&
'                                                                                ',&
'   The text is formatted in the txt2man(1) markdown language so one can easily  ',&
'   generate man-pages on ULS (Unix-Like Systems).                               ',&
'                                                                                ',&
'OPTIONS                                                                         ',&
'  TOPIC(s)          A list of Fortran intrinsic names or the special names      ',&
'                    "toc" and "manual" (which generate a table of contents      ',&
'                    and the entire set of documents respecively).               ',&
'                    The default is "toc" and to ignore case.                    ',&
'  --regex,-e        Search all output per the provided Regular Expression.      ',&
'                    Output is prefixed with the topic it was found in.          ',&
'  --itopic_only,-t  Only show topic names. Other switches are ignored.          ',&
'  --ignorecase,-i   Ignore case when searching for a Regular Expression.        ',&
'  --demo,-d         extract first demo program found for a topic (starting with ',&
'                    "program demo_" and ending with "end program demo_").       ',&
'  --color           Use ANSI in-line escape sequences to display the text in    ',&
'                    set colors. Does not work with all terminal emulators or    ',&
'                    terminals. Must use the -r switch with less(1) for less(1)  ',&
'                    to display colors.                                          ',&
'  --help            Display this help and exit                                  ',&
'  --version         Output version information and exit                         ',&
'                                                                                ',&
'EXAMPLES                                                                        ',&
'  Sample commands                                                               ',&
'                                                                                ',&
'   fpm-${PACKAGE}              # list table of contents                         ',&
'   fpm-${PACKAGE} -e character # check TOC for string. try "loc","prank","sort" ',&
'   fpm-${PACKAGE} tan|less     # display a description of tan(3f)               ',&
'                                                                                ',&
'   fpm-${PACKAGE} --regex ''character'' # look for string in TOC ignoring case  ',&
'                                                                                ',&
'   fpm-${PACKAGE} manual>fortran.txt    # create a copy of all descriptions     ',&
'                                                                                ',&
'   # list the topic "scan" if found and lines containing "scan" from the entire ',&
'   # manual, prefixing the lines with the section name, while ignoring case.    ',&
'   fpm-${PACKAGE} -e scan -i manual                                             ',&
'                                                                                ',&
'   fpm-${PACKAGE} -d pack >demo_pack.f90 # get sample program to try VERIFY(3f).',&
'']

version_text=[ CHARACTER(LEN=128) :: &
'PRODUCT:         GPF (General Purpose Fortran) utilities and examples           ',&
'PROGRAM:         fpm-${PACKAGE}(1)                                              ',&
'DESCRIPTION:     output Fortran intrinsic descriptions                          ',&
!'VERSION:         1.0.0, 20201215                                               ',&
!'VERSION:         1.0.1, 20201217                                               ',&
'VERSION:         1.0.2, 202100108                                               ',&
'AUTHOR:          John S. Urban                                                  ',&
'HOME PAGE:       http://www.urbanjost.altervista.org/index.html                 ',&
'LICENSE:         MIT License                                                    ',&
'']

end subroutine setup
end program fpm_${PACKAGE}
! kludge1: older versions of gfortran do not handle character arrays with both line and size allocatable
 
EOF
####################################################################################################################################
) |tee /tmp/all.log
####################################################################################################################################
exit
####################################################################################################################################
